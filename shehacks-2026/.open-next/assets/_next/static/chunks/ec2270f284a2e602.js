(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,67034,(e,t,r)=>{var n={675:function(e,t){"use strict";t.byteLength=function(e){var t=l(e),r=t[0],n=t[1];return(r+n)*3/4-n},t.toByteArray=function(e){var t,r,s=l(e),i=s[0],o=s[1],u=new a((i+o)*3/4-o),h=0,p=o>0?i-4:i;for(r=0;r<p;r+=4)t=n[e.charCodeAt(r)]<<18|n[e.charCodeAt(r+1)]<<12|n[e.charCodeAt(r+2)]<<6|n[e.charCodeAt(r+3)],u[h++]=t>>16&255,u[h++]=t>>8&255,u[h++]=255&t;return 2===o&&(t=n[e.charCodeAt(r)]<<2|n[e.charCodeAt(r+1)]>>4,u[h++]=255&t),1===o&&(t=n[e.charCodeAt(r)]<<10|n[e.charCodeAt(r+1)]<<4|n[e.charCodeAt(r+2)]>>2,u[h++]=t>>8&255,u[h++]=255&t),u},t.fromByteArray=function(e){for(var t,n=e.length,a=n%3,s=[],i=0,o=n-a;i<o;i+=16383)s.push(function(e,t,n){for(var a,s=[],i=t;i<n;i+=3)a=(e[i]<<16&0xff0000)+(e[i+1]<<8&65280)+(255&e[i+2]),s.push(r[a>>18&63]+r[a>>12&63]+r[a>>6&63]+r[63&a]);return s.join("")}(e,i,i+16383>o?o:i+16383));return 1===a?s.push(r[(t=e[n-1])>>2]+r[t<<4&63]+"=="):2===a&&s.push(r[(t=(e[n-2]<<8)+e[n-1])>>10]+r[t>>4&63]+r[t<<2&63]+"="),s.join("")};for(var r=[],n=[],a="undefined"!=typeof Uint8Array?Uint8Array:Array,s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0,o=s.length;i<o;++i)r[i]=s[i],n[s.charCodeAt(i)]=i;function l(e){var t=e.length;if(t%4>0)throw Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");-1===r&&(r=t);var n=r===t?0:4-r%4;return[r,n]}n[45]=62,n[95]=63},72:function(e,t,r){"use strict";var n=r(675),a=r(783),s="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;function i(e){if(e>0x7fffffff)throw RangeError('The value "'+e+'" is invalid for option "size"');var t=new Uint8Array(e);return Object.setPrototypeOf(t,o.prototype),t}function o(e,t,r){if("number"==typeof e){if("string"==typeof t)throw TypeError('The "string" argument must be of type string. Received type number');return h(e)}return l(e,t,r)}function l(e,t,r){if("string"==typeof e){var n=e,a=t;if(("string"!=typeof a||""===a)&&(a="utf8"),!o.isEncoding(a))throw TypeError("Unknown encoding: "+a);var s=0|c(n,a),l=i(s),u=l.write(n,a);return u!==s&&(l=l.slice(0,u)),l}if(ArrayBuffer.isView(e))return p(e);if(null==e)throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if($(e,ArrayBuffer)||e&&$(e.buffer,ArrayBuffer)||"undefined"!=typeof SharedArrayBuffer&&($(e,SharedArrayBuffer)||e&&$(e.buffer,SharedArrayBuffer)))return function(e,t,r){var n;if(t<0||e.byteLength<t)throw RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(r||0))throw RangeError('"length" is outside of buffer bounds');return Object.setPrototypeOf(n=void 0===t&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,t):new Uint8Array(e,t,r),o.prototype),n}(e,t,r);if("number"==typeof e)throw TypeError('The "value" argument must not be of type number. Received type number');var h=e.valueOf&&e.valueOf();if(null!=h&&h!==e)return o.from(h,t,r);var f=function(e){if(o.isBuffer(e)){var t=0|d(e.length),r=i(t);return 0===r.length||e.copy(r,0,0,t),r}return void 0!==e.length?"number"!=typeof e.length||function(e){return e!=e}(e.length)?i(0):p(e):"Buffer"===e.type&&Array.isArray(e.data)?p(e.data):void 0}(e);if(f)return f;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return o.from(e[Symbol.toPrimitive]("string"),t,r);throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function u(e){if("number"!=typeof e)throw TypeError('"size" argument must be of type number');if(e<0)throw RangeError('The value "'+e+'" is invalid for option "size"')}function h(e){return u(e),i(e<0?0:0|d(e))}function p(e){for(var t=e.length<0?0:0|d(e.length),r=i(t),n=0;n<t;n+=1)r[n]=255&e[n];return r}t.Buffer=o,t.SlowBuffer=function(e){return+e!=e&&(e=0),o.alloc(+e)},t.INSPECT_MAX_BYTES=50,t.kMaxLength=0x7fffffff,o.TYPED_ARRAY_SUPPORT=function(){try{var e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return!1}}(),o.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(o.prototype,"parent",{enumerable:!0,get:function(){if(o.isBuffer(this))return this.buffer}}),Object.defineProperty(o.prototype,"offset",{enumerable:!0,get:function(){if(o.isBuffer(this))return this.byteOffset}}),o.poolSize=8192,o.from=function(e,t,r){return l(e,t,r)},Object.setPrototypeOf(o.prototype,Uint8Array.prototype),Object.setPrototypeOf(o,Uint8Array),o.alloc=function(e,t,r){return(u(e),e<=0)?i(e):void 0!==t?"string"==typeof r?i(e).fill(t,r):i(e).fill(t):i(e)},o.allocUnsafe=function(e){return h(e)},o.allocUnsafeSlow=function(e){return h(e)};function d(e){if(e>=0x7fffffff)throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x7fffffff bytes");return 0|e}function c(e,t){if(o.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||$(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);var r=e.length,n=arguments.length>2&&!0===arguments[2];if(!n&&0===r)return 0;for(var a=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return I(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return C(e).length;default:if(a)return n?-1:I(e).length;t=(""+t).toLowerCase(),a=!0}}function f(e,t,r){var a,s,i,o=!1;if((void 0===t||t<0)&&(t=0),t>this.length||((void 0===r||r>this.length)&&(r=this.length),r<=0||(r>>>=0)<=(t>>>=0)))return"";for(e||(e="utf8");;)switch(e){case"hex":return function(e,t,r){var n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);for(var a="",s=t;s<r;++s)a+=A[e[s]];return a}(this,t,r);case"utf8":case"utf-8":return b(this,t,r);case"ascii":return function(e,t,r){var n="";r=Math.min(e.length,r);for(var a=t;a<r;++a)n+=String.fromCharCode(127&e[a]);return n}(this,t,r);case"latin1":case"binary":return function(e,t,r){var n="";r=Math.min(e.length,r);for(var a=t;a<r;++a)n+=String.fromCharCode(e[a]);return n}(this,t,r);case"base64":return a=this,s=t,i=r,0===s&&i===a.length?n.fromByteArray(a):n.fromByteArray(a.slice(s,i));case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return function(e,t,r){for(var n=e.slice(t,r),a="",s=0;s<n.length;s+=2)a+=String.fromCharCode(n[s]+256*n[s+1]);return a}(this,t,r);default:if(o)throw TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),o=!0}}function m(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function g(e,t,r,n,a){var s;if(0===e.length)return -1;if("string"==typeof r?(n=r,r=0):r>0x7fffffff?r=0x7fffffff:r<-0x80000000&&(r=-0x80000000),(s=r*=1)!=s&&(r=a?0:e.length-1),r<0&&(r=e.length+r),r>=e.length)if(a)return -1;else r=e.length-1;else if(r<0)if(!a)return -1;else r=0;if("string"==typeof t&&(t=o.from(t,n)),o.isBuffer(t))return 0===t.length?-1:y(e,t,r,n,a);if("number"==typeof t){if(t&=255,"function"==typeof Uint8Array.prototype.indexOf)if(a)return Uint8Array.prototype.indexOf.call(e,t,r);else return Uint8Array.prototype.lastIndexOf.call(e,t,r);return y(e,[t],r,n,a)}throw TypeError("val must be string, number or Buffer")}function y(e,t,r,n,a){var s,i=1,o=e.length,l=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return -1;i=2,o/=2,l/=2,r/=2}function u(e,t){return 1===i?e[t]:e.readUInt16BE(t*i)}if(a){var h=-1;for(s=r;s<o;s++)if(u(e,s)===u(t,-1===h?0:s-h)){if(-1===h&&(h=s),s-h+1===l)return h*i}else -1!==h&&(s-=s-h),h=-1}else for(r+l>o&&(r=o-l),s=r;s>=0;s--){for(var p=!0,d=0;d<l;d++)if(u(e,s+d)!==u(t,d)){p=!1;break}if(p)return s}return -1}o.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==o.prototype},o.compare=function(e,t){if($(e,Uint8Array)&&(e=o.from(e,e.offset,e.byteLength)),$(t,Uint8Array)&&(t=o.from(t,t.offset,t.byteLength)),!o.isBuffer(e)||!o.isBuffer(t))throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;for(var r=e.length,n=t.length,a=0,s=Math.min(r,n);a<s;++a)if(e[a]!==t[a]){r=e[a],n=t[a];break}return r<n?-1:+(n<r)},o.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},o.concat=function(e,t){if(!Array.isArray(e))throw TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return o.alloc(0);if(void 0===t)for(r=0,t=0;r<e.length;++r)t+=e[r].length;var r,n=o.allocUnsafe(t),a=0;for(r=0;r<e.length;++r){var s=e[r];if($(s,Uint8Array)&&(s=o.from(s)),!o.isBuffer(s))throw TypeError('"list" argument must be an Array of Buffers');s.copy(n,a),a+=s.length}return n},o.byteLength=c,o.prototype._isBuffer=!0,o.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)m(this,t,t+1);return this},o.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)m(this,t,t+3),m(this,t+1,t+2);return this},o.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)m(this,t,t+7),m(this,t+1,t+6),m(this,t+2,t+5),m(this,t+3,t+4);return this},o.prototype.toString=function(){var e=this.length;return 0===e?"":0==arguments.length?b(this,0,e):f.apply(this,arguments)},o.prototype.toLocaleString=o.prototype.toString,o.prototype.equals=function(e){if(!o.isBuffer(e))throw TypeError("Argument must be a Buffer");return this===e||0===o.compare(this,e)},o.prototype.inspect=function(){var e="",r=t.INSPECT_MAX_BYTES;return e=this.toString("hex",0,r).replace(/(.{2})/g,"$1 ").trim(),this.length>r&&(e+=" ... "),"<Buffer "+e+">"},s&&(o.prototype[s]=o.prototype.inspect),o.prototype.compare=function(e,t,r,n,a){if($(e,Uint8Array)&&(e=o.from(e,e.offset,e.byteLength)),!o.isBuffer(e))throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===a&&(a=this.length),t<0||r>e.length||n<0||a>this.length)throw RangeError("out of range index");if(n>=a&&t>=r)return 0;if(n>=a)return -1;if(t>=r)return 1;if(t>>>=0,r>>>=0,n>>>=0,a>>>=0,this===e)return 0;for(var s=a-n,i=r-t,l=Math.min(s,i),u=this.slice(n,a),h=e.slice(t,r),p=0;p<l;++p)if(u[p]!==h[p]){s=u[p],i=h[p];break}return s<i?-1:+(i<s)},o.prototype.includes=function(e,t,r){return -1!==this.indexOf(e,t,r)},o.prototype.indexOf=function(e,t,r){return g(this,e,t,r,!0)},o.prototype.lastIndexOf=function(e,t,r){return g(this,e,t,r,!1)};function b(e,t,r){r=Math.min(e.length,r);for(var n=[],a=t;a<r;){var s,i,o,l,u=e[a],h=null,p=u>239?4:u>223?3:u>191?2:1;if(a+p<=r)switch(p){case 1:u<128&&(h=u);break;case 2:(192&(s=e[a+1]))==128&&(l=(31&u)<<6|63&s)>127&&(h=l);break;case 3:s=e[a+1],i=e[a+2],(192&s)==128&&(192&i)==128&&(l=(15&u)<<12|(63&s)<<6|63&i)>2047&&(l<55296||l>57343)&&(h=l);break;case 4:s=e[a+1],i=e[a+2],o=e[a+3],(192&s)==128&&(192&i)==128&&(192&o)==128&&(l=(15&u)<<18|(63&s)<<12|(63&i)<<6|63&o)>65535&&l<1114112&&(h=l)}null===h?(h=65533,p=1):h>65535&&(h-=65536,n.push(h>>>10&1023|55296),h=56320|1023&h),n.push(h),a+=p}var d=n,c=d.length;if(c<=4096)return String.fromCharCode.apply(String,d);for(var f="",m=0;m<c;)f+=String.fromCharCode.apply(String,d.slice(m,m+=4096));return f}function x(e,t,r){if(e%1!=0||e<0)throw RangeError("offset is not uint");if(e+t>r)throw RangeError("Trying to access beyond buffer length")}function v(e,t,r,n,a,s){if(!o.isBuffer(e))throw TypeError('"buffer" argument must be a Buffer instance');if(t>a||t<s)throw RangeError('"value" argument is out of bounds');if(r+n>e.length)throw RangeError("Index out of range")}function w(e,t,r,n,a,s){if(r+n>e.length||r<0)throw RangeError("Index out of range")}function S(e,t,r,n,s){return t*=1,r>>>=0,s||w(e,t,r,4,34028234663852886e22,-34028234663852886e22),a.write(e,t,r,n,23,4),r+4}function N(e,t,r,n,s){return t*=1,r>>>=0,s||w(e,t,r,8,17976931348623157e292,-17976931348623157e292),a.write(e,t,r,n,52,8),r+8}o.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else if(isFinite(t))t>>>=0,isFinite(r)?(r>>>=0,void 0===n&&(n="utf8")):(n=r,r=void 0);else throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");var a,s,i,o,l,u,h,p,d=this.length-t;if((void 0===r||r>d)&&(r=d),e.length>0&&(r<0||t<0)||t>this.length)throw RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var c=!1;;)switch(n){case"hex":return function(e,t,r,n){r=Number(r)||0;var a=e.length-r;n?(n=Number(n))>a&&(n=a):n=a;var s=t.length;n>s/2&&(n=s/2);for(var i=0;i<n;++i){var o,l=parseInt(t.substr(2*i,2),16);if((o=l)!=o)break;e[r+i]=l}return i}(this,e,t,r);case"utf8":case"utf-8":return a=t,s=r,E(I(e,this.length-a),this,a,s);case"ascii":return i=t,o=r,E(T(e),this,i,o);case"latin1":case"binary":return function(e,t,r,n){return E(T(t),e,r,n)}(this,e,t,r);case"base64":return l=t,u=r,E(C(e),this,l,u);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return h=t,p=r,E(function(e,t){for(var r,n,a=[],s=0;s<e.length&&!((t-=2)<0);++s)n=(r=e.charCodeAt(s))>>8,a.push(r%256),a.push(n);return a}(e,this.length-h),this,h,p);default:if(c)throw TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),c=!0}},o.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}},o.prototype.slice=function(e,t){var r=this.length;e=~~e,t=void 0===t?r:~~t,e<0?(e+=r)<0&&(e=0):e>r&&(e=r),t<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e);var n=this.subarray(e,t);return Object.setPrototypeOf(n,o.prototype),n},o.prototype.readUIntLE=function(e,t,r){e>>>=0,t>>>=0,r||x(e,t,this.length);for(var n=this[e],a=1,s=0;++s<t&&(a*=256);)n+=this[e+s]*a;return n},o.prototype.readUIntBE=function(e,t,r){e>>>=0,t>>>=0,r||x(e,t,this.length);for(var n=this[e+--t],a=1;t>0&&(a*=256);)n+=this[e+--t]*a;return n},o.prototype.readUInt8=function(e,t){return e>>>=0,t||x(e,1,this.length),this[e]},o.prototype.readUInt16LE=function(e,t){return e>>>=0,t||x(e,2,this.length),this[e]|this[e+1]<<8},o.prototype.readUInt16BE=function(e,t){return e>>>=0,t||x(e,2,this.length),this[e]<<8|this[e+1]},o.prototype.readUInt32LE=function(e,t){return e>>>=0,t||x(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+0x1000000*this[e+3]},o.prototype.readUInt32BE=function(e,t){return e>>>=0,t||x(e,4,this.length),0x1000000*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},o.prototype.readIntLE=function(e,t,r){e>>>=0,t>>>=0,r||x(e,t,this.length);for(var n=this[e],a=1,s=0;++s<t&&(a*=256);)n+=this[e+s]*a;return n>=(a*=128)&&(n-=Math.pow(2,8*t)),n},o.prototype.readIntBE=function(e,t,r){e>>>=0,t>>>=0,r||x(e,t,this.length);for(var n=t,a=1,s=this[e+--n];n>0&&(a*=256);)s+=this[e+--n]*a;return s>=(a*=128)&&(s-=Math.pow(2,8*t)),s},o.prototype.readInt8=function(e,t){return(e>>>=0,t||x(e,1,this.length),128&this[e])?-((255-this[e]+1)*1):this[e]},o.prototype.readInt16LE=function(e,t){e>>>=0,t||x(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?0xffff0000|r:r},o.prototype.readInt16BE=function(e,t){e>>>=0,t||x(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?0xffff0000|r:r},o.prototype.readInt32LE=function(e,t){return e>>>=0,t||x(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},o.prototype.readInt32BE=function(e,t){return e>>>=0,t||x(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},o.prototype.readFloatLE=function(e,t){return e>>>=0,t||x(e,4,this.length),a.read(this,e,!0,23,4)},o.prototype.readFloatBE=function(e,t){return e>>>=0,t||x(e,4,this.length),a.read(this,e,!1,23,4)},o.prototype.readDoubleLE=function(e,t){return e>>>=0,t||x(e,8,this.length),a.read(this,e,!0,52,8)},o.prototype.readDoubleBE=function(e,t){return e>>>=0,t||x(e,8,this.length),a.read(this,e,!1,52,8)},o.prototype.writeUIntLE=function(e,t,r,n){if(e*=1,t>>>=0,r>>>=0,!n){var a=Math.pow(2,8*r)-1;v(this,e,t,r,a,0)}var s=1,i=0;for(this[t]=255&e;++i<r&&(s*=256);)this[t+i]=e/s&255;return t+r},o.prototype.writeUIntBE=function(e,t,r,n){if(e*=1,t>>>=0,r>>>=0,!n){var a=Math.pow(2,8*r)-1;v(this,e,t,r,a,0)}var s=r-1,i=1;for(this[t+s]=255&e;--s>=0&&(i*=256);)this[t+s]=e/i&255;return t+r},o.prototype.writeUInt8=function(e,t,r){return e*=1,t>>>=0,r||v(this,e,t,1,255,0),this[t]=255&e,t+1},o.prototype.writeUInt16LE=function(e,t,r){return e*=1,t>>>=0,r||v(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},o.prototype.writeUInt16BE=function(e,t,r){return e*=1,t>>>=0,r||v(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},o.prototype.writeUInt32LE=function(e,t,r){return e*=1,t>>>=0,r||v(this,e,t,4,0xffffffff,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},o.prototype.writeUInt32BE=function(e,t,r){return e*=1,t>>>=0,r||v(this,e,t,4,0xffffffff,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},o.prototype.writeIntLE=function(e,t,r,n){if(e*=1,t>>>=0,!n){var a=Math.pow(2,8*r-1);v(this,e,t,r,a-1,-a)}var s=0,i=1,o=0;for(this[t]=255&e;++s<r&&(i*=256);)e<0&&0===o&&0!==this[t+s-1]&&(o=1),this[t+s]=(e/i|0)-o&255;return t+r},o.prototype.writeIntBE=function(e,t,r,n){if(e*=1,t>>>=0,!n){var a=Math.pow(2,8*r-1);v(this,e,t,r,a-1,-a)}var s=r-1,i=1,o=0;for(this[t+s]=255&e;--s>=0&&(i*=256);)e<0&&0===o&&0!==this[t+s+1]&&(o=1),this[t+s]=(e/i|0)-o&255;return t+r},o.prototype.writeInt8=function(e,t,r){return e*=1,t>>>=0,r||v(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},o.prototype.writeInt16LE=function(e,t,r){return e*=1,t>>>=0,r||v(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},o.prototype.writeInt16BE=function(e,t,r){return e*=1,t>>>=0,r||v(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},o.prototype.writeInt32LE=function(e,t,r){return e*=1,t>>>=0,r||v(this,e,t,4,0x7fffffff,-0x80000000),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},o.prototype.writeInt32BE=function(e,t,r){return e*=1,t>>>=0,r||v(this,e,t,4,0x7fffffff,-0x80000000),e<0&&(e=0xffffffff+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},o.prototype.writeFloatLE=function(e,t,r){return S(this,e,t,!0,r)},o.prototype.writeFloatBE=function(e,t,r){return S(this,e,t,!1,r)},o.prototype.writeDoubleLE=function(e,t,r){return N(this,e,t,!0,r)},o.prototype.writeDoubleBE=function(e,t,r){return N(this,e,t,!1,r)},o.prototype.copy=function(e,t,r,n){if(!o.isBuffer(e))throw TypeError("argument should be a Buffer");if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r||0===e.length||0===this.length)return 0;if(t<0)throw RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw RangeError("Index out of range");if(n<0)throw RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var a=n-r;if(this===e&&"function"==typeof Uint8Array.prototype.copyWithin)this.copyWithin(t,r,n);else if(this===e&&r<t&&t<n)for(var s=a-1;s>=0;--s)e[s+t]=this[s+r];else Uint8Array.prototype.set.call(e,this.subarray(r,n),t);return a},o.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),void 0!==n&&"string"!=typeof n)throw TypeError("encoding must be a string");if("string"==typeof n&&!o.isEncoding(n))throw TypeError("Unknown encoding: "+n);if(1===e.length){var a,s=e.charCodeAt(0);("utf8"===n&&s<128||"latin1"===n)&&(e=s)}}else"number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<r)throw RangeError("Out of range index");if(r<=t)return this;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(a=t;a<r;++a)this[a]=e;else{var i=o.isBuffer(e)?e:o.from(e,n),l=i.length;if(0===l)throw TypeError('The value "'+e+'" is invalid for argument "value"');for(a=0;a<r-t;++a)this[a+t]=i[a%l]}return this};var k=/[^+/0-9A-Za-z-_]/g;function I(e,t){t=t||1/0;for(var r,n=e.length,a=null,s=[],i=0;i<n;++i){if((r=e.charCodeAt(i))>55295&&r<57344){if(!a){if(r>56319||i+1===n){(t-=3)>-1&&s.push(239,191,189);continue}a=r;continue}if(r<56320){(t-=3)>-1&&s.push(239,191,189),a=r;continue}r=(a-55296<<10|r-56320)+65536}else a&&(t-=3)>-1&&s.push(239,191,189);if(a=null,r<128){if((t-=1)<0)break;s.push(r)}else if(r<2048){if((t-=2)<0)break;s.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;s.push(r>>12|224,r>>6&63|128,63&r|128)}else if(r<1114112){if((t-=4)<0)break;s.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}else throw Error("Invalid code point")}return s}function T(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}function C(e){return n.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(k,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function E(e,t,r,n){for(var a=0;a<n&&!(a+r>=t.length)&&!(a>=e.length);++a)t[a+r]=e[a];return a}function $(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}var A=function(){for(var e="0123456789abcdef",t=Array(256),r=0;r<16;++r)for(var n=16*r,a=0;a<16;++a)t[n+a]=e[r]+e[a];return t}()},783:function(e,t){t.read=function(e,t,r,n,a){var s,i,o=8*a-n-1,l=(1<<o)-1,u=l>>1,h=-7,p=r?a-1:0,d=r?-1:1,c=e[t+p];for(p+=d,s=c&(1<<-h)-1,c>>=-h,h+=o;h>0;s=256*s+e[t+p],p+=d,h-=8);for(i=s&(1<<-h)-1,s>>=-h,h+=n;h>0;i=256*i+e[t+p],p+=d,h-=8);if(0===s)s=1-u;else{if(s===l)return i?NaN:1/0*(c?-1:1);i+=Math.pow(2,n),s-=u}return(c?-1:1)*i*Math.pow(2,s-n)},t.write=function(e,t,r,n,a,s){var i,o,l,u=8*s-a-1,h=(1<<u)-1,p=h>>1,d=5960464477539062e-23*(23===a),c=n?0:s-1,f=n?1:-1,m=+(t<0||0===t&&1/t<0);for(isNaN(t=Math.abs(t))||t===1/0?(o=+!!isNaN(t),i=h):(i=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-i))<1&&(i--,l*=2),i+p>=1?t+=d/l:t+=d*Math.pow(2,1-p),t*l>=2&&(i++,l/=2),i+p>=h?(o=0,i=h):i+p>=1?(o=(t*l-1)*Math.pow(2,a),i+=p):(o=t*Math.pow(2,p-1)*Math.pow(2,a),i=0));a>=8;e[r+c]=255&o,c+=f,o/=256,a-=8);for(i=i<<a|o,u+=a;u>0;e[r+c]=255&i,c+=f,i/=256,u-=8);e[r+c-f]|=128*m}}},a={};function s(e){var t=a[e];if(void 0!==t)return t.exports;var r=a[e]={exports:{}},i=!0;try{n[e](r,r.exports,s),i=!1}finally{i&&delete a[e]}return r.exports}s.ab="/ROOT/node_modules/next/dist/compiled/buffer/",t.exports=s(72)},1392,(e,t,r)=>{t.exports=a;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function a(e,t,r){this.low=0|e,this.high=0|t,this.unsigned=!!r}function s(e){return!0===(e&&e.__isLong__)}a.prototype.__isLong__,Object.defineProperty(a.prototype,"__isLong__",{value:!0}),a.isLong=s;var i={},o={};function l(e,t){var r,n,a;if(t)return(e>>>=0,(a=0<=e&&e<256)&&(n=o[e]))?n:(r=h(e,(0|e)<0?-1:0,!0),a&&(o[e]=r),r);return(e|=0,(a=-128<=e&&e<128)&&(n=i[e]))?n:(r=h(e,e<0?-1:0,!1),a&&(i[e]=r),r)}function u(e,t){if(isNaN(e))return t?x:b;if(t){if(e<0)return x;if(e>=m)return k}else{if(e<=-g)return I;if(e+1>=g)return N}return e<0?u(-e,t).neg():h(e%f|0,e/f|0,t)}function h(e,t,r){return new a(e,t,r)}a.fromInt=l,a.fromNumber=u,a.fromBits=h;var p=Math.pow;function d(e,t,r){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return b;if("number"==typeof t?(r=t,t=!1):t=!!t,(r=r||10)<2||36<r)throw RangeError("radix");if((n=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===n)return d(e.substring(1),t,r).neg();for(var n,a=u(p(r,8)),s=b,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),l=parseInt(e.substring(i,i+o),r);if(o<8){var h=u(p(r,o));s=s.mul(h).add(u(l))}else s=(s=s.mul(a)).add(u(l))}return s.unsigned=t,s}function c(e,t){return"number"==typeof e?u(e,t):"string"==typeof e?d(e,t):h(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}a.fromString=d,a.fromValue=c;var f=0x100000000,m=0xffffffffffffffff,g=0x8000000000000000,y=l(0x1000000),b=l(0);a.ZERO=b;var x=l(0,!0);a.UZERO=x;var v=l(1);a.ONE=v;var w=l(1,!0);a.UONE=w;var S=l(-1);a.NEG_ONE=S;var N=h(-1,0x7fffffff,!1);a.MAX_VALUE=N;var k=h(-1,-1,!0);a.MAX_UNSIGNED_VALUE=k;var I=h(0,-0x80000000,!1);a.MIN_VALUE=I;var T=a.prototype;T.toInt=function(){return this.unsigned?this.low>>>0:this.low},T.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},T.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(!this.eq(I))return"-"+this.neg().toString(e);else{var t=u(e),r=this.div(t),n=r.mul(t).sub(this);return r.toString(e)+n.toInt().toString(e)}for(var a=u(p(e,6),this.unsigned),s=this,i="";;){var o=s.div(a),l=(s.sub(o.mul(a)).toInt()>>>0).toString(e);if((s=o).isZero())return l+i;for(;l.length<6;)l="0"+l;i=""+l+i}},T.getHighBits=function(){return this.high},T.getHighBitsUnsigned=function(){return this.high>>>0},T.getLowBits=function(){return this.low},T.getLowBitsUnsigned=function(){return this.low>>>0},T.getNumBitsAbs=function(){if(this.isNegative())return this.eq(I)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return 0!=this.high?t+33:t+1},T.isZero=function(){return 0===this.high&&0===this.low},T.eqz=T.isZero,T.isNegative=function(){return!this.unsigned&&this.high<0},T.isPositive=function(){return this.unsigned||this.high>=0},T.isOdd=function(){return(1&this.low)==1},T.isEven=function(){return(1&this.low)==0},T.equals=function(e){return s(e)||(e=c(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},T.eq=T.equals,T.notEquals=function(e){return!this.eq(e)},T.neq=T.notEquals,T.ne=T.notEquals,T.lessThan=function(e){return 0>this.comp(e)},T.lt=T.lessThan,T.lessThanOrEqual=function(e){return 0>=this.comp(e)},T.lte=T.lessThanOrEqual,T.le=T.lessThanOrEqual,T.greaterThan=function(e){return this.comp(e)>0},T.gt=T.greaterThan,T.greaterThanOrEqual=function(e){return this.comp(e)>=0},T.gte=T.greaterThanOrEqual,T.ge=T.greaterThanOrEqual,T.compare=function(e){if(s(e)||(e=c(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},T.comp=T.compare,T.negate=function(){return!this.unsigned&&this.eq(I)?I:this.not().add(v)},T.neg=T.negate,T.add=function(e){s(e)||(e=c(e));var t,r,n=this.high>>>16,a=65535&this.high,i=this.low>>>16,o=65535&this.low,l=e.high>>>16,u=65535&e.high,p=e.low>>>16,d=65535&e.low,f=0,m=0;return t=0+((r=0+(o+d))>>>16),r&=65535,t+=i+p,m+=t>>>16,t&=65535,m+=a+u,f+=m>>>16,m&=65535,f+=n+l,h(t<<16|r,(f&=65535)<<16|m,this.unsigned)},T.subtract=function(e){return s(e)||(e=c(e)),this.add(e.neg())},T.sub=T.subtract,T.multiply=function(e){if(this.isZero())return b;if(s(e)||(e=c(e)),n)return h(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return b;if(this.eq(I))return e.isOdd()?I:b;if(e.eq(I))return this.isOdd()?I:b;if(this.isNegative())if(e.isNegative())return this.neg().mul(e.neg());else return this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(y)&&e.lt(y))return u(this.toNumber()*e.toNumber(),this.unsigned);var t,r,a=this.high>>>16,i=65535&this.high,o=this.low>>>16,l=65535&this.low,p=e.high>>>16,d=65535&e.high,f=e.low>>>16,m=65535&e.low,g=0,x=0;return t=0+((r=0+l*m)>>>16),r&=65535,t+=o*m,x+=t>>>16,t&=65535,t+=l*f,x+=t>>>16,t&=65535,x+=i*m,g+=x>>>16,x&=65535,x+=o*f,g+=x>>>16,x&=65535,x+=l*d,g+=x>>>16,x&=65535,g+=a*m+i*f+o*d+l*p,h(t<<16|r,(g&=65535)<<16|x,this.unsigned)},T.mul=T.multiply,T.divide=function(e){if(s(e)||(e=c(e)),e.isZero())throw Error("division by zero");if(n){var t,r,a;return this.unsigned||-0x80000000!==this.high||-1!==e.low||-1!==e.high?h((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this}if(this.isZero())return this.unsigned?x:b;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return x;if(e.gt(this.shru(1)))return w;a=x}else{if(this.eq(I))if(e.eq(v)||e.eq(S))return I;else return e.eq(I)?v:(t=this.shr(1).div(e).shl(1)).eq(b)?e.isNegative()?v:S:(r=this.sub(e.mul(t)),a=t.add(r.div(e)));if(e.eq(I))return this.unsigned?x:b;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=b}for(r=this;r.gte(e);){for(var i=Math.ceil(Math.log(t=Math.max(1,Math.floor(r.toNumber()/e.toNumber())))/Math.LN2),o=i<=48?1:p(2,i-48),l=u(t),d=l.mul(e);d.isNegative()||d.gt(r);)t-=o,d=(l=u(t,this.unsigned)).mul(e);l.isZero()&&(l=v),a=a.add(l),r=r.sub(d)}return a},T.div=T.divide,T.modulo=function(e){return(s(e)||(e=c(e)),n)?h((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},T.mod=T.modulo,T.rem=T.modulo,T.not=function(){return h(~this.low,~this.high,this.unsigned)},T.and=function(e){return s(e)||(e=c(e)),h(this.low&e.low,this.high&e.high,this.unsigned)},T.or=function(e){return s(e)||(e=c(e)),h(this.low|e.low,this.high|e.high,this.unsigned)},T.xor=function(e){return s(e)||(e=c(e)),h(this.low^e.low,this.high^e.high,this.unsigned)},T.shiftLeft=function(e){return(s(e)&&(e=e.toInt()),0==(e&=63))?this:e<32?h(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):h(0,this.low<<e-32,this.unsigned)},T.shl=T.shiftLeft,T.shiftRight=function(e){return(s(e)&&(e=e.toInt()),0==(e&=63))?this:e<32?h(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):h(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},T.shr=T.shiftRight,T.shiftRightUnsigned=function(e){if(s(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?h(this.low>>>e|t<<32-e,t>>>e,this.unsigned):32===e?h(t,0,this.unsigned):h(t>>>e-32,0,this.unsigned)},T.shru=T.shiftRightUnsigned,T.shr_u=T.shiftRightUnsigned,T.toSigned=function(){return this.unsigned?h(this.low,this.high,!1):this},T.toUnsigned=function(){return this.unsigned?this:h(this.low,this.high,!0)},T.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},T.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},T.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},a.fromBytes=function(e,t,r){return r?a.fromBytesLE(e,t):a.fromBytesBE(e,t)},a.fromBytesLE=function(e,t){return new a(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},a.fromBytesBE=function(e,t){return new a(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},87741,(e,t,r)=>{!function(t,r,n){function a(e){var t,r=this,n=(t=0xefc8249d,function(e){e=String(e);for(var r=0;r<e.length;r++){var n=.02519603282416938*(t+=e.charCodeAt(r));t=n>>>0,n-=t,n*=t,t=n>>>0,n-=t,t+=0x100000000*n}return(t>>>0)*23283064365386963e-26});r.next=function(){var e=2091639*r.s0+23283064365386963e-26*r.c;return r.s0=r.s1,r.s1=r.s2,r.s2=e-(r.c=0|e)},r.c=1,r.s0=n(" "),r.s1=n(" "),r.s2=n(" "),r.s0-=n(e),r.s0<0&&(r.s0+=1),r.s1-=n(e),r.s1<0&&(r.s1+=1),r.s2-=n(e),r.s2<0&&(r.s2+=1)}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function i(e,t){var r=new a(e),n=t&&t.state,i=r.next;return i.int32=function(){return 0x100000000*r.next()|0},i.double=function(){return i()+(2097152*i()|0)*11102230246251565e-32},i.quick=i,n&&("object"==typeof n&&s(n,r),i.state=function(){return s(r,{})}),i}if(r&&r.exports)r.exports=i;else if(n&&n.amd)e.r,void 0!==i&&e.v(i);else this.alea=i}(e.e,t,"function"==typeof define&&define)},89057,(e,t,r)=>{!function(t,r,n){function a(e){var t=this,r="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:r+=e;for(var n=0;n<r.length+64;n++)t.x^=r.charCodeAt(n),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function i(e,t){var r=new a(e),n=t&&t.state,i=function(){return(r.next()>>>0)/0x100000000};return i.double=function(){do var e=((r.next()>>>11)+(r.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=r.next,i.quick=i,n&&("object"==typeof n&&s(n,r),i.state=function(){return s(r,{})}),i}if(r&&r.exports)r.exports=i;else if(n&&n.amd)e.r,void 0!==i&&e.v(i);else this.xor128=i}(e.e,t,"function"==typeof define&&define)},26605,(e,t,r)=>{!function(t,r,n){function a(e){var t=this,r="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^(e^e<<1))|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:r+=e;for(var n=0;n<r.length+64;n++)t.x^=r.charCodeAt(n),n==r.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function i(e,t){var r=new a(e),n=t&&t.state,i=function(){return(r.next()>>>0)/0x100000000};return i.double=function(){do var e=((r.next()>>>11)+(r.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=r.next,i.quick=i,n&&("object"==typeof n&&s(n,r),i.state=function(){return s(r,{})}),i}if(r&&r.exports)r.exports=i;else if(n&&n.amd)e.r,void 0!==i&&e.v(i);else this.xorwow=i}(e.e,t,"function"==typeof define&&define)},58753,(e,t,r)=>{!function(t,r,n){function a(e){var t=this;t.next=function(){var e,r,n=t.x,a=t.i;return e=n[a],e^=e>>>7,r=e^e<<24^((e=n[a+1&7])^e>>>10)^((e=n[a+3&7])^e>>>3)^((e=n[a+4&7])^e<<7),e=n[a+7&7],e^=e<<13,r^=e^e<<9,n[a]=r,t.i=a+1&7,r};var r,n=e,a=[];if(n===(0|n))a[0]=n;else for(r=0,n=""+n;r<n.length;++r)a[7&r]=a[7&r]<<15^n.charCodeAt(r)+a[r+1&7]<<13;for(;a.length<8;)a.push(0);for(r=0;r<8&&0===a[r];++r);for(8==r?a[7]=-1:a[r],t.x=a,t.i=0,r=256;r>0;--r)t.next()}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function i(e,t){null==e&&(e=+new Date);var r=new a(e),n=t&&t.state,i=function(){return(r.next()>>>0)/0x100000000};return i.double=function(){do var e=((r.next()>>>11)+(r.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=r.next,i.quick=i,n&&(n.x&&s(n,r),i.state=function(){return s(r,{})}),i}if(r&&r.exports)r.exports=i;else if(n&&n.amd)e.r,void 0!==i&&e.v(i);else this.xorshift7=i}(e.e,t,"function"==typeof define&&define)},25600,(e,t,r)=>{!function(t,r,n){function a(e){var t=this;t.next=function(){var e,r,n=t.w,a=t.X,s=t.i;return t.w=n=n+0x61c88647|0,r=a[s+34&127],e=a[s=s+1&127],r^=r<<13,e^=e<<17,r^=r>>>15,e^=e>>>12,r=a[s]=r^e,t.i=s,r+(n^n>>>16)|0},!function(e,t){var r,n,a,s,i,o=[],l=128;for(t===(0|t)?(n=t,t=null):(t+="\0",n=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(n^=t.charCodeAt((s+32)%t.length)),0===s&&(i=n),n^=n<<10,n^=n>>>15,n^=n<<4,n^=n>>>13,s>=0&&(i=i+0x61c88647|0,a=0==(r=o[127&s]^=n+i)?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)n=o[a+34&127],r=o[a=a+1&127],n^=n<<13,r^=r<<17,n^=n>>>15,r^=r>>>12,o[a]=n^r;e.w=i,e.X=o,e.i=a}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function i(e,t){null==e&&(e=+new Date);var r=new a(e),n=t&&t.state,i=function(){return(r.next()>>>0)/0x100000000};return i.double=function(){do var e=((r.next()>>>11)+(r.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=r.next,i.quick=i,n&&(n.X&&s(n,r),i.state=function(){return s(r,{})}),i}if(r&&r.exports)r.exports=i;else if(n&&n.amd)e.r,void 0!==i&&e.v(i);else this.xor4096=i}(e.e,t,"function"==typeof define&&define)},14038,(e,t,r)=>{!function(t,r,n){function a(e){var t=this,r="";t.next=function(){var e=t.b,r=t.c,n=t.d,a=t.a;return e=e<<25^e>>>7^r,r=r-n|0,n=n<<24^n>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^r,t.c=r=r-n|0,t.d=n<<16^r>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-0x61c88647,t.d=0x517cc1b7,e===Math.floor(e)?(t.a=e/0x100000000|0,t.b=0|e):r+=e;for(var n=0;n<r.length+20;n++)t.b^=r.charCodeAt(n),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function i(e,t){var r=new a(e),n=t&&t.state,i=function(){return(r.next()>>>0)/0x100000000};return i.double=function(){do var e=((r.next()>>>11)+(r.next()>>>0)/0x100000000)/2097152;while(0===e)return e},i.int32=r.next,i.quick=i,n&&("object"==typeof n&&s(n,r),i.state=function(){return s(r,{})}),i}if(r&&r.exports)r.exports=i;else if(n&&n.amd)e.r,void 0!==i&&e.v(i);else this.tychei=i}(e.e,t,"function"==typeof define&&define)},32034,(e,t,r)=>{!function(r,n,a){var s,i="random",o=a.pow(256,6),l=a.pow(2,52),u=2*l;function h(e,t,h){var m=[],g=c(function e(t,r){var n,a=[],s=typeof t;if(r&&"object"==s)for(n in t)try{a.push(e(t[n],r-1))}catch(e){}return a.length?a:"string"==s?t:t+"\0"}((t=!0==t?{entropy:!0}:t||{}).entropy?[e,f(n)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(256):(e=new Uint8Array(256),(r.crypto||r.msCrypto).getRandomValues(e)),f(e)}catch(e){var t=r.navigator,a=t&&t.plugins;return[+new Date,r,a,r.screen,f(n)]}}():e,3),m),y=new p(m),b=function(){for(var e=y.g(6),t=o,r=0;e<l;)e=(e+r)*256,t*=256,r=y.g(1);for(;e>=u;)e/=2,t/=2,r>>>=1;return(e+r)/t};return b.int32=function(){return 0|y.g(4)},b.quick=function(){return y.g(4)/0x100000000},b.double=b,c(f(y.S),n),(t.pass||h||function(e,t,r,n){return(n&&(n.S&&d(n,y),e.state=function(){return d(y,{})}),r)?(a[i]=e,t):e})(b,g,"global"in t?t.global:this==a,t.state)}function p(e){var t,r=e.length,n=this,a=0,s=n.i=n.j=0,i=n.S=[];for(r||(e=[r++]);a<256;)i[a]=a++;for(a=0;a<256;a++)i[a]=i[s=255&s+e[a%r]+(t=i[a])],i[s]=t;(n.g=function(e){for(var t,r=0,a=n.i,s=n.j,i=n.S;e--;)t=i[a=255&a+1],r=256*r+i[255&(i[a]=i[s=255&s+t])+(i[s]=t)];return n.i=a,n.j=s,r})(256)}function d(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function c(e,t){for(var r,n=e+"",a=0;a<n.length;)t[255&a]=255&(r^=19*t[255&a])+n.charCodeAt(a++);return f(t)}function f(e){return String.fromCharCode.apply(0,e)}if(c(a.random(),n),t.exports){t.exports=h;try{s={}}catch(e){}}else if("function"==typeof define&&define.amd)e.r,void 0!==h&&e.v(h);else a["seed"+i]=h}("undefined"!=typeof self?self:e.e,[],Math)},89378,(e,t,r)=>{var n=e.r(87741),a=e.r(89057),s=e.r(26605),i=e.r(58753),o=e.r(25600),l=e.r(14038),u=e.r(32034);u.alea=n,u.xor128=a,u.xorwow=s,u.xorshift7=i,u.xor4096=o,u.tychei=l,t.exports=u},70306,90422,86879,29064,75660,71070,97969,91587,86962,8308,41175,24452,62893,59551,33977,98976,17372,7926,61133,62836,39705,19344,99359,11857,83333,39048,96724,17616,56425,83654,86862,18985,40922,27553,6587,16181,76413,54463,8252,42242,11787,73824,52850,91995,84652,59966,61898,34338,48012,74647,3116,49506,22012,85280,2182,5247,2173,92700,19813,97529,31837,35032,21704,14545,90506,60752,17016,38015,27e3,33192,77744,53849,41589,96996,91555,85474,40855,38363,44587,82522,67768,41423,466,85522,60164,53175,61376,10493,47710,67781,84812,87626,36467,95528,42130,33236,15401,94829,40296,99269,3975,15466,90049,99963,41807,18355,99451,98317,70804,7970,91075,11585,31445,89684,74060,29451,22108,195,36502,91013,97662,91288,20961,74984,15683,90881,61197,75067,40453,90632,12785,34414,29903,36889,42088,52064,28489,10423,18293,87286,73271,22525,98378,84296,33292,66506,60949,37262,80201,87338,69578,83218,32537,95772,30448,54160,56691,64960,80507,73560,95596,98657,81008,76428,75869,92477,97612,66213,67289,64733,19318,46554,12965,90889,46768,56877,22947,94125,95558,39316,79362,80781,56367,82669,81982,4509,49729,41001,70402,58063,13741,23582,41721,25273,84580,18181,87271,40939,2510,20691,73934,80765,92135,16738,9670,e=>{"use strict";let t,r,n;class a{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class s{refCount(e){return i("refCount")}incRef(e){return i("incRef")}timerAvailable(){return!0}time(e){return i("time")}read(e){return i("read")}readSync(e){return i("readSync")}readToGPU(e,t){return i("readToGPU")}numDataIds(){return i("numDataIds")}disposeData(e,t){return i("disposeData")}write(e,t,r){return i("write")}move(e,t,r,n,a){return i("move")}createTensorFromGPUData(e,t,r){return i("createTensorFromGPUData")}memory(){return i("memory")}floatPrecision(){return i("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return i("dispose")}}function i(e){throw Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function o(e){let t=e.length,r=0;for(;t>0;)r=Math.random()*t|0,p(e,--t,r)}function l(e,t){if(e.length!==t.length)throw Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let r=e.length,n=0;for(;r>0;)n=Math.random()*r|0,p(e,--r,n),p(t,r,n)}function u(e,t,r){return Math.max(e,Math.min(t,r))}function h(e){return e%2==0?e:e+1}function p(e,t,r){let n=e[t];e[t]=e[r],e[r]=n}function d(e){let t=0;for(let r=0;r<e.length;r++)t+=e[r];return t}function c(e,t){let r=Math.random();return t*r+(1-r)*e}function f(e,t){let r=0;for(let n=0;n<e.length;n++){let a=Number(e[n])-Number(t[n]);r+=a*a}return r}function m(e,t){if(!e)throw Error("string"==typeof t?t:t())}function g(e,t,r=""){m(w(e,t),()=>r+` Shapes ${e} and ${t} must match`)}function y(e){m(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function b(e){if(0===e.length)return 1;let t=e[0];for(let r=1;r<e.length;r++)t*=e[r];return t}function x(e){return 0===e.length}function v(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(null!==e[r]&&null!==t[r]&&e[r]!==t[r])return!1;return!0}function w(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}function S(e){return e%1==0}function N(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;{if(e===-1/0)return -1;let t=Math.exp(2*e);return(t-1)/(t+1)}}function k(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function I(e){let t=new Uint32Array(e);for(let r=0;r<e;++r)t[r]=r;return o(t),t}function T(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function C(e,t=e=>0,r,n){return new Promise((a,s)=>{let i=0,o=()=>{if(e())return void a();let l=t(++i);null!=r&&i>=r?s():null!=n?n(o,l):setTimeout(o,l)};o()})}function E(e,t){let r=1,n=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)r*=e[t];else if(-1===e[t]){if(-1!==n)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${t}`);n=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===n){if(t>0&&t!==r)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===r)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%r!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${r}`);let a=e.slice();return a[n]=t/r,a}function $(e,t){let r=t.length;return m((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-r&&e<r),()=>`All values in axis param must be in range [-${r}, ${r}) but got axis ${e}`),m(e.every(e=>S(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?r+e:e)}function A(e,t){let r=[],n=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:$(t,e).sort(),i=0;for(let t=0;t<e.length;++t){if(null!=s){if(s[i]===t&&1!==e[t])throw Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==s[i]||s[i]>t)&&1===e[t]&&(r.push(e[t]),n.push(t)),s[i]<=t&&i++}1!==e[t]&&(r.push(e[t]),n.push(t))}return{newShape:r,keptDims:n}}function R(e,t){return D(e,t)}function D(e,t){let r=null;if(null==e||"float32"===e)r=new Float32Array(t);else if("int32"===e)r=new Int32Array(t);else if("bool"===e)r=new Uint8Array(t);else if("string"===e)r=Array(t);else throw Error(`Unknown data type ${e}`);return r}function F(e,t){for(let r=0;r<e.length;r++){let n=e[r];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function O(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function _(e,t){return"complex64"!==t&&("float32"!==t||"complex64"===e)&&("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)}function M(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw Error(`Unknown dtype ${e}`)}function L(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}function z(e){return"string"==typeof e||e instanceof String}function P(e){return"boolean"==typeof e}function B(e){return"number"==typeof e}function V(e){if(Array.isArray(e))return V(e[0]);if(e instanceof Float32Array);else if(e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray)return"int32";else if(B(e));else if(z(e))return"string";else if(P(e))return"bool";return"float32"}function W(e){return!!(e&&e.constructor&&e.call&&e.apply)}function U(e,t){for(let r=t;r<e;++r)if(e%r==0)return r;return e}function G(e){let t=e.length;if(t<2)return[];let r=Array(t-1);r[t-2]=e[t-1];for(let n=t-3;n>=0;--n)r[n]=r[n+1]*e[n+1];return r}function q(e,t,r=!1){if(0===e.length)return t[0];let n=e.reduce((e,t)=>e*t)*(r?2:1);if(0===n)return[];if(n!==t.length)throw Error(`[${e}] does not match the input size ${t.length}${r?" for a complex tensor":""}.`);return function e(t,r,n,a=!1){let s=[];if(1===r.length){let e=r[0]*(a?2:1);for(let r=0;r<e;r++)s[r]=n[t+r]}else{let i=r[0],o=r.slice(1),l=o.reduce((e,t)=>e*t)*(a?2:1);for(let r=0;r<i;r++)s[r]=e(t+r*l,o,n,a)}return s}(0,e,t,r)}function H(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw Error(`Unknown dtype ${t}`)}function j(e,t){let r=K(e,t);for(let e=0;e<r.length;e++)r[e]=1;return r}function K(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw Error(`Unknown data type ${t}`)}function X(e,t){let r=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return q(e,new Float32Array(r));if("int32"===t)return q(e,new Int32Array(r));if("bool"===t)return q(e,new Uint8Array(r));throw Error(`Unknown data type ${t}`)}function Z(e){e.forEach(t=>{m(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function Y(e,t,r){if(0===t)return 0;if(1===t)return e[0];let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=r[t]*e[t];return n}function J(e,t,r){if(0===t)return[];if(1===t)return[e];let n=Array(t);for(let t=0;t<n.length-1;++t)n[t]=Math.floor(e/r[t]),e-=n[t]*r[t];return n[n.length-1]=e,n}function Q(e){return e&&e.then&&"function"==typeof e.then}e.s(["DataStorage",()=>a,"KernelBackend",()=>s],90422),e.s(["arraysEqual",()=>w,"arraysEqualWithNull",()=>v,"assert",()=>m,"assertNonNegativeIntegerDimensions",()=>Z,"assertNonNull",()=>y,"assertShapesMatch",()=>g,"bytesFromStringArray",()=>L,"bytesPerElement",()=>M,"checkConversionForErrors",()=>F,"clamp",()=>u,"computeStrides",()=>G,"convertBackendValuesAndArrayBuffer",()=>H,"createShuffledIndices",()=>I,"distSquared",()=>f,"getArrayFromDType",()=>D,"getTypedArrayFromDType",()=>R,"hasEncodingLoss",()=>_,"indexToLoc",()=>J,"inferDtype",()=>V,"inferFromImplicitShape",()=>E,"isBoolean",()=>P,"isFunction",()=>W,"isInt",()=>S,"isNumber",()=>B,"isPromise",()=>Q,"isScalarShape",()=>x,"isString",()=>z,"isValidDtype",()=>O,"locToIndex",()=>Y,"makeOnesTypedArray",()=>j,"makeZerosNestedTypedArray",()=>X,"makeZerosTypedArray",()=>K,"nearestDivisor",()=>U,"nearestLargerEven",()=>h,"parseAxisParam",()=>$,"randUniform",()=>c,"repeatedTry",()=>C,"rightPad",()=>T,"shuffle",()=>o,"shuffleCombo",()=>l,"sizeFromShape",()=>b,"sizeToSquarishShape",()=>k,"squeezeShape",()=>A,"sum",()=>d,"swap",()=>p,"tanh",()=>N,"toNestedArray",()=>q],86879);let ee="tfjsflags";class et{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=er,this.populateURLFlags()}setPlatform(e,t){null==this.platform||ea.getBool("IS_TEST")||ea.getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},null!=this.urlFlags[e]){let t=this.urlFlags[e];ea.getBool("IS_TEST")||ea.getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Q(t))throw Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);ee in e&&e[ee].split(",").forEach(e=>{var t;let r,[n,a]=e.split(":");this.urlFlags[n]="true"===(r=(t=a).toLowerCase())||"false"===r?"true"===r:`${+r}`===r?+r:t})}}function er(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>{var n,a,s;return n=t,a=r[0],s=r[1],n[decodeURIComponent(a)]=decodeURIComponent(s||""),r.join("=")}),t}function en(){return ea}let ea=null;function es(e){ea=e}function ei(){if(null==t){let r;t=r="undefined"!=typeof window?window:e.g}return t}function eo(e,t){let r,n=(null==(r=ei())._tfGlobals&&(r._tfGlobals=new Map),r._tfGlobals);if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}e.s(["ENV",()=>ea,"Environment",()=>et,"env",()=>en,"setEnvironmentGlobal",()=>es],29064);let el="Acos",eu="Acosh",eh="AddN",ep="ArgMax",ed="ArgMin",ec="Asin",ef="Asinh",em="Atan",eg="Atanh",ey="Atan2",eb="AvgPool",ex="AvgPool3D",ev="BatchMatMul",ew="BatchToSpaceND",eS="Bincount",eN="BitwiseAnd",ek="BroadcastArgs",eI="Cast",eT="Ceil",eC="ClipByValue",eE="Complex",e$="ComplexAbs",eA="Concat",eR="Conv2D",eD="Conv2DBackpropFilter",eF="Conv2DBackpropInput",eO="Conv3D",e_="Conv3DBackpropInputV2",eM="Cosh",eL="Cumprod",ez="Cumsum",eP="CropAndResize",eB="DenseBincount",eV="DepthToSpace",eW="DepthwiseConv2dNative",eU="DepthwiseConv2dNativeBackpropFilter",eG="DepthwiseConv2dNativeBackpropInput",eq="Diag",eH="Dilation2D",ej="RealDiv",eK="Einsum",eX="Equal",eZ="ExpandDims",eY="Expm1",eJ="Fill",eQ="FlipLeftRight",e0="Floor",e1="FloorDiv",e2="FusedBatchNorm",e3="GatherV2",e4="GatherNd",e6="Greater",e5="GreaterEqual",e8="Identity",e9="IFFT",e7="Imag",te="IsFinite",tt="IsInf",tr="IsNan",tn="LeakyRelu",ta="Less",ts="LessEqual",ti="LinSpace",to="Log1p",tl="LogicalAnd",tu="LogicalNot",th="LogicalOr",tp="Maximum",td="MaxPool",tc="MaxPool3D",tf="MaxPoolWithArgmax",tm="Mean",tg="Minimum",ty="MirrorPad",tb="Multinomial",tx="Multiply",tv="NotEqual",tw="NonMaxSuppressionV3",tS="NonMaxSuppressionV4",tN="NonMaxSuppressionV5",tk="OnesLike",tI="OneHot",tT="Pack",tC="PadV2",tE="Prelu",t$="Prod",tA="RaggedGather",tR="RaggedRange",tD="RaggedTensorToTensor",tF="Range",tO="Real",t_="Reciprocal",tM="Relu",tL="Reshape",tz="ResizeNearestNeighbor",tP="ResizeBilinear",tB="Relu6",tV="Reverse",tW="Round",tU="Rsqrt",tG="ScatterNd",tq="TensorScatterUpdate",tH="SearchSorted",tj="Select",tK="Selu",tX="Slice",tZ="Sinh",tY="Sign",tJ="Sigmoid",tQ="Softplus",t0="Sqrt",t1="SpaceToBatchND",t2="SplitV",t3="Softmax",t4="SparseFillEmptyRows",t6="SparseReshape",t5="SparseSegmentMean",t8="SparseSegmentSum",t9="SparseToDense",t7="SquaredDifference",re="StaticRegexReplace",rt="StridedSlice",rr="StringNGrams",rn="StringSplit",ra="StringToHashBucketFast",rs="Tanh",ri="Tile",ro="TopK",rl="Transform",ru="Transpose",rh="Unique",rp="Unpack",rd="UnsortedSegmentSum",rc="ZerosLike",rf="Step",rm="RotateWithOffset",rg="_FusedMatMul",ry="FusedConv2D",rb="FusedDepthwiseConv2D";function rx(...e){ea.getBool("IS_TEST")||ea.getBool("PROD")||console.warn(...e)}function rv(...e){ea.getBool("IS_TEST")||ea.getBool("PROD")||console.log(...e)}e.s(["Abs",0,"Abs","Acos",0,el,"Acosh",0,eu,"Add",0,"Add","AddN",0,eh,"All",0,"All","Any",0,"Any","ArgMax",0,ep,"ArgMin",0,ed,"Asin",0,ec,"Asinh",0,ef,"Atan",0,em,"Atan2",0,ey,"Atanh",0,eg,"AvgPool",0,eb,"AvgPool3D",0,ex,"AvgPool3DGrad",0,"AvgPool3DGrad","AvgPoolGrad",0,"AvgPoolGrad","BatchMatMul",0,ev,"BatchToSpaceND",0,ew,"Bincount",0,eS,"BitwiseAnd",0,eN,"BroadcastArgs",0,ek,"BroadcastTo",0,"BroadcastTo","Cast",0,eI,"Ceil",0,eT,"ClipByValue",0,eC,"Complex",0,eE,"ComplexAbs",0,e$,"Concat",0,eA,"Conv2D",0,eR,"Conv2DBackpropFilter",0,eD,"Conv2DBackpropInput",0,eF,"Conv3D",0,eO,"Conv3DBackpropFilterV2",0,"Conv3DBackpropFilterV2","Conv3DBackpropInputV2",0,e_,"Cos",0,"Cos","Cosh",0,eM,"CropAndResize",0,eP,"Cumprod",0,eL,"Cumsum",0,ez,"DenseBincount",0,eB,"DepthToSpace",0,eV,"DepthwiseConv2dNative",0,eW,"DepthwiseConv2dNativeBackpropFilter",0,eU,"DepthwiseConv2dNativeBackpropInput",0,eG,"Diag",0,eq,"Dilation2D",0,eH,"Dilation2DBackpropFilter",0,"Dilation2DBackpropFilter","Dilation2DBackpropInput",0,"Dilation2DBackpropInput","Draw",0,"Draw","Einsum",0,eK,"Elu",0,"Elu","EluGrad",0,"EluGrad","Equal",0,eX,"Erf",0,"Erf","Exp",0,"Exp","ExpandDims",0,eZ,"Expm1",0,eY,"FFT",0,"FFT","Fill",0,eJ,"FlipLeftRight",0,eQ,"Floor",0,e0,"FloorDiv",0,e1,"FromPixels",0,"FromPixels","FusedBatchNorm",0,e2,"FusedConv2D",0,ry,"FusedDepthwiseConv2D",0,rb,"GatherNd",0,e4,"GatherV2",0,e3,"Greater",0,e6,"GreaterEqual",0,e5,"IFFT",0,e9,"Identity",0,e8,"Imag",0,e7,"IsFinite",0,te,"IsInf",0,tt,"IsNan",0,tr,"LRN",0,"LRN","LRNGrad",0,"LRNGrad","LeakyRelu",0,tn,"Less",0,ta,"LessEqual",0,ts,"LinSpace",0,ti,"Log",0,"Log","Log1p",0,to,"LogSoftmax",0,"LogSoftmax","LogicalAnd",0,tl,"LogicalNot",0,tu,"LogicalOr",0,th,"LogicalXor",0,"LogicalXor","LowerBound",0,"LowerBound","MatrixBandPart",0,"MatrixBandPart","Max",0,"Max","MaxPool",0,td,"MaxPool3D",0,tc,"MaxPool3DGrad",0,"MaxPool3DGrad","MaxPoolGrad",0,"MaxPoolGrad","MaxPoolWithArgmax",0,tf,"Maximum",0,tp,"Mean",0,tm,"Min",0,"Min","Minimum",0,tg,"MirrorPad",0,ty,"Mod",0,"Mod","Multinomial",0,tb,"Multiply",0,tx,"Neg",0,"Neg","NonMaxSuppressionV3",0,tw,"NonMaxSuppressionV4",0,tS,"NonMaxSuppressionV5",0,tN,"NotEqual",0,tv,"OneHot",0,tI,"OnesLike",0,tk,"Pack",0,tT,"PadV2",0,tC,"Pool",0,"Pool","Pow",0,"Pow","Prelu",0,tE,"Prod",0,t$,"RaggedGather",0,tA,"RaggedRange",0,tR,"RaggedTensorToTensor",0,tD,"Range",0,tF,"Real",0,tO,"RealDiv",0,ej,"Reciprocal",0,t_,"Relu",0,tM,"Relu6",0,tB,"Reshape",0,tL,"ResizeBilinear",0,tP,"ResizeBilinearGrad",0,"ResizeBilinearGrad","ResizeNearestNeighbor",0,tz,"ResizeNearestNeighborGrad",0,"ResizeNearestNeighborGrad","Reverse",0,tV,"RotateWithOffset",0,rm,"Round",0,tW,"Rsqrt",0,tU,"ScatterNd",0,tG,"SearchSorted",0,tH,"Select",0,tj,"Selu",0,tK,"Sigmoid",0,tJ,"Sign",0,tY,"Sin",0,"Sin","Sinh",0,tZ,"Slice",0,tX,"Softmax",0,t3,"Softplus",0,tQ,"SpaceToBatchND",0,t1,"SparseFillEmptyRows",0,t4,"SparseReshape",0,t6,"SparseSegmentMean",0,t5,"SparseSegmentSum",0,t8,"SparseToDense",0,t9,"SplitV",0,t2,"Sqrt",0,t0,"Square",0,"Square","SquaredDifference",0,t7,"StaticRegexReplace",0,re,"Step",0,rf,"StridedSlice",0,rt,"StringNGrams",0,rr,"StringSplit",0,rn,"StringToHashBucketFast",0,ra,"Sub",0,"Sub","Sum",0,"Sum","Tan",0,"Tan","Tanh",0,rs,"TensorScatterUpdate",0,tq,"Tile",0,ri,"TopK",0,ro,"Transform",0,rl,"Transpose",0,ru,"Unique",0,rh,"Unpack",0,rp,"UnsortedSegmentSum",0,rd,"UpperBound",0,"UpperBound","ZerosLike",0,rc,"_FusedMatMul",0,rg],75660),e.s(["log",()=>rv,"warn",()=>rx],71070);let rw=eo("kernelRegistry",()=>new Map),rS=eo("gradRegistry",()=>new Map);function rN(e,t){let r=rR(e,t);return rw.get(r)}function rk(e){return rS.get(e)}function rI(e){let t=rw.entries(),r=[];for(;;){let{done:n,value:a}=t.next();if(n)break;let[s,i]=a,[o]=s.split("_");o===e&&r.push(i)}return r}function rT(e){let{kernelName:t,backendName:r}=e,n=rR(t,r);rw.has(n)&&rx(`The kernel '${t}' for backend '${r}' is already registered`),rw.set(n,e)}function rC(e){let{kernelName:t}=e;rS.has(t)&&ea.getBool("DEBUG")&&rx(`Overriding the gradient for '${t}'`),rS.set(t,e)}function rE(e,t){let r=rR(e,t);if(!rw.has(r))throw Error(`The kernel '${e}' for backend '${t}' is not registered`);rw.delete(r)}function r$(e){if(!rS.has(e))throw Error(`The gradient '${e}' for backend is not registered`);rS.delete(e)}function rA(e,t){rI(e).forEach(e=>{rT(Object.assign({},e,{backendName:t}))})}function rR(e,t){return`${t}_${e}`}function rD(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function rF(e,t){return"string"===t?rL(e):rO([e],t)}function rO(e,t){var r;if("string"===t)throw Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=rB(e)),ea.getBool("DEBUG")&&F(e,t),(r=e)instanceof Float32Array&&"float32"===t||r instanceof Int32Array&&"int32"===t||r instanceof Uint8Array&&"bool"===t)return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let r=0;r<t.length;++r)0!==Math.round(e[r])&&(t[r]=1);return t}throw Error(`Unknown data type ${t}`)}function r_(){return ea.platform.now()}function rM(e,t){return ea.platform.fetch(e,t)}function rL(e,t="utf-8"){return t=t||"utf-8",ea.platform.encode(e,t)}function rz(e,t="utf-8"){return t=t||"utf-8",ea.platform.decode(e,t)}function rP(e){return null!=ea.platform.isTypedArray?ea.platform.isTypedArray(e):rD(e)}function rB(e,t=[],r=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||Q(e)||null==e||rP(e)&&r)t.push(e);else if(Array.isArray(e)||rP(e))for(let n=0;n<e.length;++n)rB(e[n],t,r);else{let n=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(n=Math.max(n,Number(t)));for(let a=0;a<=n;a++)rB(e[a],t,r)}return t}e.s(["copyRegisteredKernels",()=>rA,"getGradient",()=>rk,"getKernel",()=>rN,"getKernelsForBackend",()=>rI,"registerGradient",()=>rC,"registerKernel",()=>rT,"unregisterGradient",()=>r$,"unregisterKernel",()=>rE],97969),e.s(["createScalarValue",()=>rF,"decodeString",()=>rz,"encodeString",()=>rL,"fetch",()=>rM,"flatten",()=>rB,"isTypedArray",()=>rP,"now",()=>r_,"toTypedArray",()=>rO],91587);class rV{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new rW)}profileKernel(e,t,r){let n,a,s=()=>{n=r()},i=r_();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{for(let e of(s(),n))e.dataSync();a=Promise.resolve({kernelMs:r_()-i})}if(ea.getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<n.length;t++){let r=n[t];r.data().then(t=>{!function(e,t,r){if("float32"===t)for(let t=0;t<e.length;t++){let n=e[t];if(isNaN(n)||!isFinite(n))return console.warn(`Found ${n} in the result of '${r}'`),!0}}(t,r.dtype,e)})}return{kernelName:e,outputs:n,inputs:t,timeMs:a.then(e=>e.kernelMs),extraInfo:a.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:r,timeMs:n,inputs:a,extraInfo:s}=e;r.forEach(e=>{Promise.all([e.data(),n,s]).then(r=>{this.logger.logKernelProfile(t,e,r[0],r[1],a,r[2])})})}}class rW{logKernelProfile(e,t,r,n,a,s){let i="number"==typeof n?T(`${n}ms`,9):n.error,o=T(e,25),l=t.rank,u=t.size,h=T(t.shape.toString(),14),p="";for(let e in a){let r=a[e];if(null!=r){let n=r.shape||t.shape,a=n.length;p+=`${e}: ${a}D ${a>0?n:""} `}}console.log(`%c${o}	%c${i}	%c${l}D ${h}	%c${u}	%c${p}	%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function rU(e,t,r){return T(Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:z(e)?`'${e}'`:"bool"===r?rG(e):parseFloat(e.toFixed(7)).toString(),t)}function rG(e){return 0===e?"false":"true"}function rq(e){let t=[];for(let r=0;r<e.length;r+=2)t.push([e[r],e[r+1]]);return t}class rH{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=b(e),null!=r){const e=r.length;m(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||D(t,this.size),this.strides=G(e)}set(e,...t){0===t.length&&(t=[0]),m(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let r=this.locToIndex(t);this.values[r]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t])throw Error(`Requested out of range element at ${e}.   Buffer shape=${this.shape}`);t++}let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=this.strides[t]*e[t];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return rj().makeTensor(this.values,this.shape,this.dtype)}}let rj=null,rK=null;function rX(e){rj=e}function rZ(e){rK=e}function rY(e){}class rJ{constructor(e,t,r,n){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=b(e),this.strides=G(e),this.dataId=r,this.id=n,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return rK.buffer(this.shape,this.dtype,e)}bufferSync(){return rK.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return q(this.shape,e,"complex64"===this.dtype)}arraySync(){return q(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=rj().read(this.dataId);if("string"===this.dtype){let t=await e;try{return t.map(e=>rz(e))}catch(e){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),rj().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=rj().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>rz(e))}catch(e){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await rj().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),rj().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw Error("Tensor is disposed.")}print(e=!1){return rK.print(this,e)}clone(){return this.throwIfDisposed(),rK.clone(this)}toString(e=!1){var t,r,n;let a,s,i,o,l;return t=this.dataSync(),r=this.shape,n=this.dtype,a=G(r),s=function(e,t,r,n){let a=b(t),s=n[n.length-1],i=Array(s).fill(0),o=t.length,l="complex64"===r?rq(e):e;if(o>1)for(let e=0;e<a/s;e++){let t=e*s;for(let e=0;e<s;e++)i[e]=Math.max(i[e],rU(l[t+e],0,r).length)}return i}(t,r,n,a),i=r.length,o=function e(t,r,n,a,s,i=!0){let o="complex64"===n?2:1,l=r[0],u=r.length;if(0===u)return"complex64"===n?[rU(rq(t)[0],0,n)]:"bool"===n?[rG(t[0])]:[t[0].toString()];if(1===u){if(l>20){let e=Array.from(t.slice(0,3*o)),r=Array.from(t.slice((l-3)*o,l*o));return"complex64"===n&&(e=rq(e),r=rq(r)),["["+e.map((e,t)=>rU(e,s[t],n)).join(", ")+", ..., "+r.map((e,t)=>rU(e,s[l-3+t],n)).join(", ")+"]"]}return["["+("complex64"===n?rq(t):Array.from(t)).map((e,t)=>rU(e,s[t],n)).join(", ")+"]"]}let h=r.slice(1),p=a.slice(1),d=a[0]*o,c=[];if(l>20){for(let r=0;r<3;r++){let a=r*d,i=a+d;c.push(...e(t.slice(a,i),h,n,p,s,!1))}c.push("...");for(let r=l-3;r<l;r++){let a=r*d,i=a+d;c.push(...e(t.slice(a,i),h,n,p,s,r===l-1))}}else for(let r=0;r<l;r++){let a=r*d,i=a+d;c.push(...e(t.slice(a,i),h,n,p,s,r===l-1))}let f=2===u?",":"";c[0]="["+(l>0?c[0]+f:"");for(let e=1;e<c.length-1;e++)c[e]=" "+c[e]+f;let m=",\n";for(let e=2;e<u;e++)m+="\n";return c[c.length-1]=" "+c[c.length-1]+"]"+(i?"":m),c}(t,r,n,a,s),l=["Tensor"],e&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${r}]`),l.push("  values:")),l.push(o.map(e=>"    "+e).join("\n")),l.join("\n")}cast(e){return this.throwIfDisposed(),rK.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),rj().makeVariable(this,e,t,r)}}function rQ(){return eo("Tensor",()=>rJ)}Object.defineProperty(rJ,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),rQ();class r0 extends rJ{constructor(e,t,r,n){super(e.shape,e.dtype,e.dataId,n),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!w(e.shape,this.shape))throw Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);rj().disposeTensor(this),this.dataId=e.dataId,rj().incRef(this,null)}dispose(){rj().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(r0,Symbol.hasInstance,{value:e=>e instanceof rJ&&null!=e.assign&&e.assign instanceof Function}),e.s(["Tensor",()=>rJ,"TensorBuffer",()=>rH,"Variable",()=>r0,"getGlobalTensorClass",()=>rQ,"setDeprecationWarningFn",()=>rY,"setOpHandler",()=>rZ,"setTensorTracker",()=>rX],86962),(no=nd||(nd={})).R0="R0",no.R1="R1",no.R2="R2",no.R3="R3",no.R4="R4",no.R5="R5",no.R6="R6",(nl=nc||(nc={})).float32="float32",nl.int32="int32",nl.bool="int32",nl.complex64="complex64",(nu=nf||(nf={})).float32="float32",nu.int32="int32",nu.bool="bool",nu.complex64="complex64",(nh=nm||(nm={})).float32="float32",nh.int32="float32",nh.bool="float32",nh.complex64="complex64",(np=ng||(ng={})).float32="complex64",np.int32="complex64",np.bool="complex64",np.complex64="complex64";let r1={float32:nm,int32:nc,bool:nf,complex64:ng};function r2(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw Error(`Can not upcast ${e} with ${t}`)}return r1[e][t]}function r3(e){return r2(e,"int32")}function r4(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function r6(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function r5(e,t){if(e.dtype===t.dtype)return[e,t];let r=r2(e.dtype,t.dtype);return[e.cast(r),t.cast(r)]}function r8(e,t){m(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function r9(e,t){return t.some(t=>t.id===e.id)}function r7(e){let t=[];return function e(t,r,n){var a;if(null!=t){if(t instanceof rJ)return void r.push(t);if(Array.isArray(a=t)||"object"==typeof a)for(let a in t){let s=t[a];n.has(s)||(n.add(s),e(s,r,n))}}}(e,t,new Set),t}function ne(e){return null!=e.kernelName}e.s(["Rank",()=>nd,"isWebGLData",()=>r4,"isWebGPUData",()=>r6,"sumOutType",()=>r3,"upcastType",()=>r2],8308),e.s(["assertTypesMatch",()=>r8,"getTensorsInContainer",()=>r7,"isTensorInList",()=>r9,"makeTypesMatch",()=>r5],41175);class nt{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}}class nr{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new nt}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let r=e[t];if(await this.initializeBackend(r).success)return void await this.setBackend(r)}throw Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(!(e in this.registryFactory))return null;else{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(rx(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(null==this.registryFactory[e])throw Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new rV(this.backendInstance),!0}setupRegisteredKernels(){rI(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){rI(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw Error(`Cannot initialize backend ${e}, no registration found.`);try{let r=t.factory();if(!r||r instanceof s||"function"!=typeof r.then)return this.registry[e]=r,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,n=r.then(r=>!(t<this.pendingBackendInitId)&&(this.registry[e]=r,this.pendingBackendInit=null,!0)).catch(r=>!(t<this.pendingBackendInitId)&&(this.pendingBackendInit=null,rx(`Initialization of backend ${e} failed`),rx(r.stack||r.message),!1));return this.pendingBackendInit=n,{success:n,asyncInit:!0}}}catch(t){return rx(`Initialization of backend ${e} failed`),rx(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let r=e[t],{success:n,asyncInit:a}=this.initializeBackend(r);if(a||n)return{name:r,asyncInit:a}}throw Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let r=this.state.tensorInfo.get(t),n=r.backend,a=this.readSync(t),s=n.refCount(t);n.disposeData(t,!0),r.backend=e,e.move(t,a,r.shape,r.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r,n=null;if(null==t){if("function"!=typeof e)throw Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}return this.scopedRun(()=>this.startScope(n),()=>this.endScope(r),()=>((r=t())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,r){e();try{let e=r();return t(),e}catch(e){throw t(),e}}nextTensorId(){return nr.nextTensorId++}nextVariableId(){return nr.nextVariableId++}clone(e){let t=na.runKernel(e8,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[t],e=>({x:()=>na.runKernel(eI,{x:e},{dtype:"float32"})}),[],{}),t}runKernel(e,t,r){if(null==this.backendName&&this.backend,null==rN(e,this.backendName))throw Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){let n=this.backend.numDataIds(),a=0;r.forEach(e=>{a+="complex64"===e.dtype?3:1});let s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=n-t-a-s;if(i>0)throw Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,r,n,a,s=[],i=this.isTapeOn(),o=this.state.numBytes,l=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let u=ne(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(ne(e)){let{kernelName:t,inputs:a,attrs:o}=e;null==this.backendName&&this.backend;let l=rN(t,this.backendName);m(null!=l,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),r=()=>{let e=this.backend.numDataIds(),r=Array.isArray(n=l.kernelFunc({inputs:a,attrs:o,backend:this.backend}))?n:[n];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,r);let u=r.map(e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e));if(i){let e=this.getTensorsForGradient(t,a,u);s=this.saveTensorsForBackwardMode(e)}return u}}else{let{forwardFunc:t}=e,a=e=>{i&&(s=e.map(e=>this.keep(this.clone(e))))};r=()=>{let e=this.backend.numDataIds(),r=Array.isArray(n=this.tidy(()=>t(this.backend,a)))?n:[n];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,r),r}}let{inputs:h,attrs:p}=e,d=ne(e)?null:e.backwardsFunc;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(a=this.profiler.profileKernel(u,h,()=>r()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(a),t=a.outputs):t=r()}),i&&this.addTapeNode(u,h,t,d,s,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-l,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(e=>null!=h[e]?h[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:a.timeMs,extraInfo:a.extraInfo}),Array.isArray(n)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,r){let n=rk(e);if(null!=n){let e,a=n.inputsToSave||[],s=n.outputsToSave||[];n.saveAllInputs?(m(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),e=Object.keys(t).map(e=>t[e])):e=a.map(e=>t[e]);let i=r.filter((e,t)=>s[t]);return e.concat(i)}return[]}makeTensor(e,t,r,n){if(null==e)throw Error("Values passed to engine.makeTensor() are null");r=r||"float32",n=n||this.backend;let a=e;"string"===r&&z(e[0])&&(a=e.map(e=>rL(e)));let s=n.write(a,t,r),i=new rJ(t,r,s,this.nextTensorId());if(this.trackTensor(i,n),"string"===r){let e=this.state.tensorInfo.get(s),t=L(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,r,n){let a={dataId:e,shape:t,dtype:r=r||"float32"};return this.makeTensorFromTensorInfo(a,n)}makeTensorFromTensorInfo(e,t){let{dataId:r,shape:n,dtype:a}=e,s=new rJ(n,a,r,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e,t=!0,r,n){r=r||this.nextVariableId().toString(),null!=n&&n!==e.dtype&&(e=e.cast(n));let a=new r0(e,t,r,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let r=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(r=e.size*M(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof r0||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*M(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,r=this.state.numTensors;for(let n of(this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r,this.state.activeProfile.kernels))n.kernelTimeMs=await n.kernelTimeMs,n.extraInfo=await n.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,r,n,a,s){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:a},o=rk(e);null!=o&&(n=o.gradFunc),null!=n&&(i.gradient=e=>(e=e.map((e,t)=>{if(null==e){let e=r[t],n=K(e.size,e.dtype);return this.makeTensor(n,e.shape,e.dtype)}return e}),n(e.length>1?e:e[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=r7(e),r=new Set(t.map(e=>e.id));for(let e=0;e<this.state.activeScope.track.length;e++){let t=this.state.activeScope.track[e];t.kept||r.has(t.id)||t.dispose()}let n=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==n.id||this.track(e)})}gradients(e,t,r,n=!1){if(m(t.length>0,()=>"gradients() received an empty list of xs."),null!=r&&"float32"!==r.dtype)throw Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));m(a instanceof rJ,()=>"The result y returned by f() must be a tensor.");let s=function(e,t,r){let n={},a={};for(let e=0;e<t.length;e++)n[t[e].id]=!0;for(let r=0;r<e.length;r++){let s=e[r],i=s.inputs;for(let e in i){let r=i[e],o=!1;for(let e=0;e<t.length;e++)if(n[r.id]){s.outputs.forEach(e=>n[e.id]=!0),o=!0,a[s.id]=!0;break}if(o)break}}let s={};s[r.id]=!0;let i={};for(let t=e.length-1;t>=0;t--){let r=e[t],n=r.inputs;for(let e=0;e<r.outputs.length;e++)if(s[r.outputs[e].id]){for(let e in n)s[n[e].id]=!0,i[r.id]=!0;break}}let o=[];for(let t=0;t<e.length;t++){let r=e[t];if(a[r.id]&&i[r.id]){let e={};for(let t in r.inputs){let a=r.inputs[t];n[a.id]&&(e[t]=a)}let t=Object.assign({},r);t.inputs=e,t.outputs=r.outputs,o.push(t)}}return o}(this.state.activeTape,t,a);if(!n&&0===s.length&&t.length>0)throw Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{var e;let n,i={};i[a.id]=null==r?(n=j(b(e=a.shape),"float32"),na.makeTensor(n,e,"float32")):r,function(e,t,r,n){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach(t=>{let r=e[t.id];null!=r?i.push(r):i.push(null)}),null==s.gradient)throw Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let t in s.inputs){if(!(t in o))throw Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);let a=r(()=>o[t]());if("float32"!==a.dtype)throw Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);let i=s.inputs[t];if(!w(a.shape,i.shape))throw Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=a;else{let t=e[i.id];e[i.id]=n(t,a),t.dispose()}}}}(i,s,e=>this.tidy(e),ns);let o=t.map(e=>i[e.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(let t of e.saved)t.dispose()}),this.state.activeTape=null),{value:a,grads:o}})}customGrad(e){return m(W(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let r;m(t.every(e=>e instanceof rJ),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n={};return t.forEach((e,t)=>{n[t]=e}),this.runKernelFunc({forwardFunc:(n,a)=>(m((r=e(...t,a)).value instanceof rJ,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),m(W(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),backwardsFunc:(e,n)=>{let a=r.gradFunc(e,n),s=Array.isArray(a)?a:[a];m(s.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),m(s.every(e=>e instanceof rJ),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let i={};return s.forEach((e,t)=>{i[t]=()=>e}),i},inputs:n})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=r_(),r=await this.backend.time(e);return r.wallMs=r_()-t,r}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){for(let e in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new nt,this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function nn(){let e=ei();if(null==e._tfengine){let t=new et(e);e._tfengine=new nr(t)}return ea=e._tfengine.ENV,rj=()=>e._tfengine,e._tfengine}nr.nextTensorId=0,nr.nextVariableId=0;let na=nn();function ns(e,t){return na.runKernel("Add",{a:e,b:t})}e.s(["ENGINE",0,na,"getOrMakeEngine",()=>nn],24452);var ni,no,nl,nu,nh,np,nd,nc,nf,nm,ng,ny,nb=e.i(47167);function nx(e){r=e}function nv(e){if(void 0!==r)return r;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function nw(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}e.s(["isBrowser",()=>nw,"isMobile",()=>nv,"mockIsMobile",()=>nx],62893);let nS=ea;nS.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),nS.registerFlag("IS_BROWSER",()=>nw()),nS.registerFlag("IS_NODE",()=>void 0!==nb.default&&void 0!==nb.default.versions&&void 0!==nb.default.versions.node),nS.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),nS.registerFlag("IS_SAFARI",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),nS.registerFlag("PROD",()=>!1),nS.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>nS.getBool("DEBUG")),nS.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),nS.registerFlag("IS_TEST",()=>!1),nS.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>nS.getBool("DEBUG")),nS.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),nS.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),nS.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var nN=e.i(67034);function nk(e,t){let r=e;if(rP(e))return"string"===t?[]:[e.length];if(r4(e)){let t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(r6(e))return[e.buffer.size/(null==t?4:M(t))];if(!Array.isArray(e))return[];let n=[];for(;Array.isArray(r)||rP(r)&&"string"!==t;)n.push(r.length),r=r[0];return Array.isArray(e)&&ea.getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function e(t,r,n){if(n=n||[],!Array.isArray(t)&&!rP(t))return void m(0===r.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${r[0]} elements`);m(r.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),m(t.length===r[0],()=>`Element arr[${n.join("][")}] should have ${r[0]} elements, but has ${t.length} elements`);let a=r.slice(1);for(let r=0;r<t.length;++r)e(t[r],a,n.concat(r))}(e,n,[]),n}function nI(e,t,r,n){if("string_or_numeric"!==e){if(null==e)throw Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw Error(`Argument '${r}' passed to '${n}' must be ${e} tensor, but got ${t} tensor`)}}function nT(e,t,r,n="numeric"){if(e instanceof rQ())return nI(n,e.dtype,t,r),e;let a=V(e);if("string"!==a&&["bool","int32","float32"].indexOf(n)>=0&&(a=n),nI(n,a,t,r),null==e||!rP(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let n=null==e?"null":e.constructor.name;throw Error(`Argument '${t}' passed to '${r}' must be a Tensor or TensorLike, but got '${n}'`)}let s=nk(e,a);rP(e)||Array.isArray(e)||(e=[e]);let i="string"!==a?rO(e,a):rB(e,[],!0);return na.makeTensor(i,s,a)}function nC(e,t,r,n="numeric"){if(!Array.isArray(e))throw Error(`Argument ${t} passed to ${r} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,a)=>nT(e,`${t}[${a}]`,r,n))}e.s(["convertToTensor",()=>nT,"convertToTensorArray",()=>nC,"inferShape",()=>nk],59551);let nE="__op";function n$(e){let t=Object.keys(e);if(1!==t.length)throw Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let r=t[0],n=e[r];r.endsWith("_")&&(r=r.substring(0,r.length-1));let a=(...e)=>{na.startScope(r);try{let t=n(...e);return Q(t)&&console.error("Cannot return a Promise inside of tidy."),na.endScope(t),t}catch(e){throw na.endScope(null),e}};return Object.defineProperty(a,"name",{value:r+=nE,configurable:!0}),a}e.s(["OP_SCOPE_SUFFIX",0,nE,"op",()=>n$],33977);let nA=n$({complex_:function(e,t){let r=nT(e,"real","complex"),n=nT(t,"imag","complex");return g(r.shape,n.shape,`real and imag shapes, ${r.shape} and ${n.shape}, must match in call to tf.complex().`),na.runKernel(eE,{real:r,imag:n})}});function nR(e,t,r,n){if(null==n)n=V(e);else if("complex64"===n)throw Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(r6(e)||r4(e)){if("float32"!==n&&"int32"!==n)throw Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return na.backend.createTensorFromGPUData(e,t||r,n)}if(!rP(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Z(t);let e=b(t),n=b(r);m(e===n,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${n}`);for(let e=0;e<r.length;++e){let n=r[e],a=e!==r.length-1||n!==b(t.slice(e));m(r[e]===t[e]||!a,()=>`Error creating a new Tensor. Inferred shape (${r}) does not match the provided shape (${t}). `)}}return rP(e)||Array.isArray(e)||(e=[e]),t=t||r,e="string"!==n?rO(e,n):rB(e,[],!0),na.makeTensor(e,t,n)}function nD(e,t,r){let n=nk(e,r);return nR(e,t,n,r)}e.s(["tensor",()=>nD],98976);let nF={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class nO{static join(e){return new nO(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e||(e instanceof Array||(e=[e]),0===(e=e.map(e=>rP(e)?e.buffer:e)).length))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){const n=e[r];r!==e.length-1&&n.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=t+n.byteLength;this.shards.push({buffer:n,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length||(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e))return new ArrayBuffer(0);let r=this.findShardForByte(e);if(-1===r)throw Error(`Could not find start shard for byte ${e}`);let n=new ArrayBuffer(t-e),a=new Uint8Array(n),s=0;for(let n=r;n<this.shards.length;n++){let r=this.shards[n],i=e+s-r.start,o=s,l=Math.min(t,r.end)-r.start,u=new Uint8Array(r.buffer,i,l-i);if(a.set(u,o),s+=u.length,t<r.end)break}return n}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return -1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:+(e>=t.end)}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;let r=function(e,t){let r=0,n=e.length;for(;r<=n;){let a=Math.floor((n-r)/2)+r,s=t(e[a]);if(0===s)return a;s<0?n=a:r=a+1}return -1}(this.shards,t);return -1===r?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function n_(){ea.set("PROD",!0)}function nM(){ea.set("DEBUG",!0)}function nL(){ea.set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function nz(e){ea.getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function nP(){na.disposeVariables()}function nB(){return na}function nV(){return na.memory()}function nW(e){return na.profile(e)}function nU(e,t){return na.tidy(e,t)}function nG(e){r7(e).forEach(e=>e.dispose())}function nq(e){return na.keep(e)}function nH(e){return na.time(e)}function nj(e){return na.setBackend(e)}function nK(){return na.ready()}function nX(){return na.backendName}function nZ(e){na.removeBackend(e)}function nY(e){return na.findBackend(e)}function nJ(e){return na.findBackendFactory(e)}function nQ(e,t,r=1){return na.registerBackend(e,t,r)}function n0(){return na.backend}function n1(e,t){ea.setPlatform(e,t)}async function n2(e,t){let r=[],n=[],a=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let s=0;s<a.length;++s){let i=a[s],o=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);let l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){let e=new Promise(async e=>{let t=await o.bytes(),r=new Uint8Array(t.reduce((e,t)=>e+t.length,0)+4*t.length),n=0;for(let e=0;e<t.length;e++){let a=t[e],s=new Uint8Array(new Uint32Array([a.length]).buffer);r.set(s,n),n+=4,r.set(a,n),n+=a.length}e(r)});n.push(e)}else n.push(o.data());null!=t&&(l.group=t),r.push(l)}return{data:function(e){if(null===e)throw Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,r=[];e.forEach(e=>{if(t+=e.byteLength,r.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)});let n=new Uint8Array(t),a=0;return r.forEach(e=>{n.set(new Uint8Array(e.buffer),a),a+=e.byteLength}),n.buffer}(await Promise.all(n)),specs:r}}function n3(e,t){let r=new nO(e),n={},a=0;for(let e of t){let t=function(e,t){let r,n=b(e.shape);if("quantization"in e)r=nF[e.quantization.dtype];else if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=4+new Uint32Array(t(e,e+4))[0];return e}else r=nF[e.dtype];return n*r}(e,(e,t)=>r.slice(a+e,a+t));n[e.name]=n6(e,r.slice(a,a+t)),a+=t}return n}async function n4(e,t){let r,n=b(e.shape);if("quantization"in e)r=nF[e.quantization.dtype];else if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=4+new Uint32Array(await t(e,e+4))[0];return e}else r=nF[e.dtype];return n*r}function n6(e,t){let r,n=e.name,a=e.dtype,s=e.shape,i=b(s),o=0;if("quantization"in e){let s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s&&"scale"in s))throw Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else if("float16"===s.dtype){if("float32"!==a)throw Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${a}.`)}else throw Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let l=nF[s.dtype],u="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===a)if("uint8"===s.dtype||"uint16"===s.dtype){r=new Float32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];r[e]=t*s.scale+s.min}}else if("float16"===s.dtype){let e,t,n;r=(e=function(){let e=e=>{let t=e<<13,r=0;for(;(8388608&t)==0;)r-=8388608,t<<=1;return(t&=-8388609)|(r+=0x38800000)},t=new Uint32Array(2048);t[0]=0;for(let r=1;r<1024;r++)t[r]=e(r);for(let e=1024;e<2048;e++)t[e]=0x38000000+(e-1024<<13);return t}(),t=function(){let e=new Uint32Array(64);e[0]=0,e[31]=0x47800000,e[32]=0x80000000,e[63]=0xc7800000;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=0x80000000+(t-32<<23);return e}(),n=function(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}(),r=>{let a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let a=0;a<r.length;a++){let i=r[a],o=e[n[i>>10]+(1023&i)]+t[i>>10];s[a]=o}return new Float32Array(a)})(u)}else throw Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);else if("int32"===a){if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);r=new Int32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];r[e]=Math.round(t*s.scale+s.min)}}else throw Error(`Unsupported dtype in weight '${n}': ${a}`);o+=i*l}else if("string"===a){let n=b(e.shape);r=[];for(let e=0;e<n;e++){let e=new Uint32Array(t.slice(o,o+4))[0];o+=4;let n=new Uint8Array(t.slice(o,o+e));r.push(n),o+=e}}else{let e=nF[a];if("float32"===a)r=new Float32Array(t);else if("int32"===a)r=new Int32Array(t);else if("bool"===a)r=new Uint8Array(t);else if("complex64"===a){r=new Float32Array(t);let e=new Float32Array(r.length/2),n=new Float32Array(r.length/2);for(let t=0;t<e.length;t++)e[t]=r[2*t],n[t]=r[2*t+1];let a=nD(e,s,"float32"),i=nD(n,s,"float32"),o=nA(a,i);return a.dispose(),i.dispose(),o}else throw Error(`Unsupported dtype in weight '${n}': ${a}`);o+=i*e}return nD(r,s,a)}async function n5(e,t,r){let n=new Uint8Array(t);for(;n.byteLength<r;){let{done:t,value:a}=await e.read();if(t&&null==a){let e=r-n.byteLength;throw Error(`Reader is done but ${e} bytes are still expected`)}let s=new Uint8Array(n.length+a.byteLength);s.set(n,0),s.set(new Uint8Array(a),n.length),n=s}return n.buffer}async function n8(e,t){let r={},n=e.getReader(),a=new ArrayBuffer(0);for(let e of t){let t=await n4(e,async(e,t)=>(a=await n5(n,a,t)).slice(e,t)),s=(a=await n5(n,a,t)).slice(0,t);a=a.slice(t);let i=n6(e,s);if(r[e.name]=i,"webgpu"===nX()){let e=n0();"uploadToGPU"in e&&b(i.shape)>=ea.get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return r}rY(nz),e.s(["backend",()=>n0,"deprecationWarn",()=>nz,"disableDeprecationWarnings",()=>nL,"dispose",()=>nG,"disposeVariables",()=>nP,"enableDebugMode",()=>nM,"enableProdMode",()=>n_,"engine",()=>nB,"findBackend",()=>nY,"findBackendFactory",()=>nJ,"getBackend",()=>nX,"keep",()=>nq,"memory",()=>nV,"profile",()=>nW,"ready",()=>nK,"registerBackend",()=>nQ,"removeBackend",()=>nZ,"setBackend",()=>nj,"setPlatform",()=>n1,"tidy",()=>nU,"time",()=>nH],17372);let n9=void 0!==nN.Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function n7(e){return n9?nN.Buffer.byteLength(e,"utf8"):new Blob([e]).size}function ae(e){if(n9)return nN.Buffer.from(e).toString("base64");let t=new Uint8Array(e),r="";for(let e=0,n=t.length;e<n;e++)r+=String.fromCharCode(t[e]);return btoa(r)}function at(e){if(n9){let t=nN.Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;++e)r.set([t.charCodeAt(e)],e);return r.buffer}function ar(e){return nO.join(e)}function an(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);let t=e.split("/");return t[t.length-1]}function aa(e,t){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),r}function as(e,t,r){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw Error("modelJSON has weightsManifest but weightSpecs is null");if(!r)throw Error("modelJSON has weightsManifest but weightData is null");n.weightSpecs=t,n.weightData=r}return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),n}async function ai(e,t){let r,n;return null!=e.weightsManifest&&([r,n]=await t(e.weightsManifest)),as(e,r,n)}function ao(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:n7(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:n7(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new nO(e.weightData).byteLength}}function al(e){let t=[];for(let r of e)t.push(...r.weights);return t}e.s(["arrayBufferToBase64String",()=>ae,"base64StringToArrayBuffer",()=>at,"basename",()=>an,"concatenateArrayBuffers",()=>ar,"decodeWeights",()=>n3,"decodeWeightsStream",()=>n8,"encodeWeights",()=>n2,"getModelArtifactsForJSON",()=>ai,"getModelArtifactsForJSONSync",()=>as,"getModelArtifactsInfoForJSON",()=>ao,"getModelJSONForModelArtifacts",()=>aa,"getWeightSpecs",()=>al],7926);class au{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==au.instance&&(au.instance=new au),au.instance}static registerSaveRouter(e){au.getInstance().saveRouters.push(e)}static registerLoadRouter(e){au.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return au.getHandlers(e,"save")}static getLoadHandlers(e,t){return au.getHandlers(e,"load",t)}static getHandlers(e,t,r){let n=[];return("load"===t?au.getInstance().loadRouters:au.getInstance().saveRouters).forEach(t=>{let a=t(e,r);null!==a&&n.push(a)}),n}}let ah="tensorflowjs",ap="models_store",ad="model_info_store";function ac(){if(!ea.getBool("IS_BROWSER"))throw Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw Error("The current browser does not appear to support IndexedDB.");return t}function af(e){let t=e.result;t.createObjectStore(ap,{keyPath:"modelPath"}),t.createObjectStore(ad,{keyPath:"modelPath"})}class am{constructor(e){if(this.indexedDB=ac(),null==e||!e)throw Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((e,r)=>{let n=this.indexedDB.open(ah,1);n.onupgradeneeded=()=>af(n),n.onsuccess=()=>{let a=n.result;if(null==t){let t=a.transaction(ap,"readonly"),n=t.objectStore(ap).get(this.modelPath);n.onsuccess=()=>{if(null==n.result)return a.close(),r(Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(n.result.modelArtifacts)},n.onerror=e=>(a.close(),r(n.error)),t.oncomplete=()=>a.close()}else{let n,s;t.weightData=nO.join(t.weightData);let i=ao(t),o=a.transaction(ad,"readwrite"),l=o.objectStore(ad);try{n=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(e){return r(e)}n.onsuccess=()=>{let n,u=(s=a.transaction(ap,"readwrite")).objectStore(ap);try{n=u.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(e){return r(e)}n.onsuccess=()=>e({modelArtifactsInfo:i}),n.onerror=e=>{let t=(l=o.objectStore(ad)).delete(this.modelPath);t.onsuccess=()=>(a.close(),r(n.error)),t.onerror=e=>(a.close(),r(n.error))}},n.onerror=e=>(a.close(),r(n.error)),o.oncomplete=()=>{null==s?a.close():s.oncomplete=()=>a.close()}}},n.onerror=e=>r(n.error)})}}am.URL_SCHEME="indexeddb://";let ag=e=>{var t;return ea.getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(am.URL_SCHEME)?(t=e.slice(am.URL_SCHEME.length),new am(t)):null};au.registerSaveRouter(ag),au.registerLoadRouter(ag);let ay="tensorflowjs_models",ab="info";function ax(e){return{info:[ay,e,ab].join("/"),topology:[ay,e,"model_topology"].join("/"),weightSpecs:[ay,e,"weight_specs"].join("/"),weightData:[ay,e,"weight_data"].join("/"),modelMetadata:[ay,e,"model_metadata"].join("/")}}function av(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}class aw{constructor(e){if(!ea.getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=ax(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),n=ao(e),a=nO.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(n)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,ae(a));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:n}}catch(e){throw av(this.keys),Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${n.modelTopologyBytes}, weightSpecsBytes=${n.weightSpecsBytes}, weightDataBytes=${n.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(null==r)throw Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;let n=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==n)throw Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=n;let a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){let e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(null==s)throw Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=at(s),t}}aw.URL_SCHEME="localstorage://";let aS=e=>{var t;return ea.getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(aw.URL_SCHEME)?(t=e.slice(aw.URL_SCHEME.length),new aw(t)):null};au.registerSaveRouter(aS),au.registerLoadRouter(aS);class aN{constructor(){this.managers={}}static getInstance(){return null==aN.instance&&(aN.instance=new aN),aN.instance}static registerManager(e,t){m(null!=e,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),m(e.length>0,()=>"scheme must not be an empty string.");let r=aN.getInstance();m(null==r.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){let t=aN.getInstance().managers[e];if(null==t)throw Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(aN.getInstance().managers)}}function ak(e){if(-1===e.indexOf("://"))throw Error(`The url string provided does not contain a scheme. Supported schemes are: ${aN.getSchemes().join(",")}`);return{scheme:e.split("://")[0],path:e.split("://")[1]}}async function aI(e,t,r=!1){m(e!==t,()=>`Old path and new path are the same: '${e}'`);let n=au.getLoadHandlers(e);m(n.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),m(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${e}.`);let a=n[0],s=au.getSaveHandlers(t);m(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),m(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${t}.`);let i=s[0],o=ak(e).scheme,l=ak(e).path,u=o===ak(e).scheme,h=await a.load();r&&u&&await aN.getManager(o).removeModel(l);let p=await i.save(h);return r&&!u&&await aN.getManager(o).removeModel(l),p.modelArtifactsInfo}async function aT(){let e=aN.getSchemes(),t={};for(let r of e){let e=await aN.getManager(r).listModels();for(let n in e)t[r+"://"+n]=e[n]}return t}async function aC(e){let t=ak(e);return aN.getManager(t.scheme).removeModel(t.path)}async function aE(e,t){return aI(e,t,!1)}async function a$(e,t){return aI(e,t,!0)}if(ea.get("IS_BROWSER")){ea.setPlatform("browser",new class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&ea.getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))):setTimeout(e,t)}isTypedArray(e){return rD(e)}});try{aN.registerManager(aw.URL_SCHEME,new class{constructor(){m(ea.getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),m("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=ay+"/",r="/"+ab;for(let n=0;n<this.LS.length;++n){let a=this.LS.key(n);a.startsWith(t)&&a.endsWith(r)&&(e[function(e){let t=e.split("/");if(t.length<3)throw Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join("/")}(a)]=JSON.parse(this.LS.getItem(a)))}return e}async removeModel(e){var t;let r=ax(e=(t=e).startsWith(aw.URL_SCHEME)?t.slice(aw.URL_SCHEME.length):t);if(null==this.LS.getItem(r.info))throw Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(r.info));return av(r),n}})}catch(e){}try{aN.registerManager(am.URL_SCHEME,new class{constructor(){this.indexedDB=ac()}async listModels(){return new Promise((e,t)=>{let r=this.indexedDB.open(ah,1);r.onupgradeneeded=()=>af(r),r.onsuccess=()=>{let n=r.result,a=n.transaction(ad,"readonly"),s=a.objectStore(ad).getAll();s.onsuccess=()=>{let t={};for(let e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(n.close(),t(s.error)),a.oncomplete=()=>n.close()},r.onerror=e=>t(r.error)})}async removeModel(e){var t;return e=(t=e).startsWith(am.URL_SCHEME)?t.slice(am.URL_SCHEME.length):t,new Promise((t,r)=>{let n=this.indexedDB.open(ah,1);n.onupgradeneeded=()=>af(n),n.onsuccess=()=>{let a,s=n.result,i=s.transaction(ad,"readwrite"),o=i.objectStore(ad),l=o.get(e);l.onsuccess=()=>{if(null==l.result)return s.close(),r(Error(`Cannot find model with path '${e}' in IndexedDB.`));{let n=o.delete(e),i=()=>{let n=(a=s.transaction(ap,"readwrite")).objectStore(ap).delete(e);n.onsuccess=()=>t(l.result.modelArtifactsInfo),n.onerror=e=>r(l.error)};n.onsuccess=i,n.onerror=e=>(i(),s.close(),r(l.error))}},l.onerror=e=>(s.close(),r(l.error)),i.oncomplete=()=>{null==a?s.close():a.oncomplete=()=>s.close()}},n.onerror=e=>r(n.error)})}})}catch(e){}}function aA(e,t="float32",r){return t=t||"float32",Z(e),new rH(e,t,r)}ea.get("IS_NODE")&&!ea.get("IS_BROWSER")&&ea.setPlatform("node",new class{constructor(){this.util={},this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=ea.global.fetch?ea.global.fetch(e,t):(null==n&&(n={}),n(e,t))}now(){let e=nb.default.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}),e.s(["buffer",()=>aA],61133);let aR=n$({cast_:function(e,t){let r=nT(e,"x","cast");if(!O(t))throw Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==r.dtype||"string"!==t&&"string"===r.dtype)throw Error("Only strings can be casted to strings");return na.runKernel(eI,{x:r},{dtype:t})}});e.s(["cast",0,aR],62836);let aD=n$({clone_:function(e){let t=nT(e,"x","clone","string_or_numeric");return na.runKernel(e8,{x:t})}});function aF(e,t=!1){console.log(e.toString(t))}e.s(["clone",0,aD],39705),nn(),rK={buffer:aA,cast:aR,clone:aD,print:aF};let aO=n$({add_:function(e,t){let r=nT(e,"a","add"),n=nT(t,"b","add");[r,n]=r5(r,n);let a={a:r,b:n};return na.runKernel("Add",a)}});e.s(["add",0,aO],19344);let a_=n$({floorDiv_:function(e,t){let r=nT(e,"a","floorDiv"),n=nT(t,"b","floorDiv");[r,n]=r5(r,n);let a={a:r,b:n};return na.runKernel(e1,a)}});e.s(["floorDiv",0,a_],99359);let aM=n$({div_:function(e,t){let r=nT(e,"a","div"),n=nT(t,"b","div");if([r,n]=r5(r,n),"int32"===r.dtype&&"int32"===n.dtype)return a_(r,n);let a={a:r,b:n};return na.runKernel(ej,a,{})}});e.s(["div",0,aM],11857);let aL=n$({mul_:function(e,t){let r=nT(e,"a","mul"),n=nT(t,"b","mul");[r,n]=r5(r,n);let a={a:r,b:n};return na.runKernel(tx,a)}});e.s(["mul",0,aL],83333);let az=n$({sqrt_:function(e){let t=nT(e,"x","sqrt","float32");return na.runKernel(t0,{x:t})}});e.s(["sqrt",0,az],39048);let aP=n$({square_:function(e){let t=nT(e,"x","square");return na.runKernel("Square",{x:t},{})}});e.s(["square",0,aP],96724);let aB=n$({zerosLike_:function(e){let t=nT(e,"x","zerosLike");return na.runKernel(rc,{x:t})}});function aV(e){return m(W(e),()=>"The f passed in grad(f) must be a function"),(t,r)=>{let n=nT(t,"x","tf.grad","string_or_numeric"),a=null!=r?nT(r,"dy","tf.grad"):null;return na.tidy(()=>{let{value:t,grads:r}=na.gradients(()=>e(n),[n],a);return null!=a&&g(t.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),aj(r),r[0]})}}function aW(e){return m(W(e),()=>"The f passed in grads(f) must be a function"),(t,r)=>{m(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let n=nC(t,"args","tf.grads","string_or_numeric"),a=null!=r?nT(r,"dy","tf.grads"):null;return na.tidy(()=>{let{value:t,grads:r}=na.gradients(()=>e(...n),n,a);return null!=a&&g(t.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),aj(r),r})}}function aU(e){return m(W(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,r)=>{m(t instanceof rJ,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),m(null==r||r instanceof rJ,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:n,value:a}=na.gradients(()=>e(t),[t],r);return aj(n),{grad:n[0],value:a}}}function aG(e){return m(W(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,r)=>{m(Array.isArray(t)&&t.every(e=>e instanceof rJ),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),m(null==r||r instanceof rJ,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let n=na.gradients(()=>e(...t),t,r);return null!=r&&g(n.value.shape,r.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),aj(n.grads),n}}function aq(e,t){m(W(e),()=>"The f passed in variableGrads(f) must be a function"),m(null==t||Array.isArray(t)&&t.every(e=>e instanceof r0),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let r=null!=t;if(!r)for(let e in t=[],na.registeredVariables)t.push(na.registeredVariables[e]);let n=r?t.filter(e=>!e.trainable):null,a=t.length;m((t=t.filter(e=>e.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`);let{value:s,grads:i}=na.gradients(e,t,null,!0);m(i.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),m(0===s.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`);let o={};return t.forEach((e,t)=>{null!=i[t]&&(o[e.name]=i[t])}),null!=n&&n.forEach(e=>o[e.name]=null),{value:s,grads:o}}function aH(e){return na.customGrad(e)}function aj(e){if(e.filter(e=>null==e).length>0)throw Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function aK(e,t){if((rP(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&rP(e)&&!(e instanceof Uint8Array))throw Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return nR(e,[],[],t)}e.s(["zerosLike",0,aB],17616),e.s(["customGrad",()=>aH,"grad",()=>aV,"grads",()=>aW,"valueAndGrad",()=>aU,"valueAndGrads",()=>aG,"variableGrads",()=>aq],56425),e.s(["scalar",()=>aK],83654);let aX=new Map,aZ=new Map;class aY{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class aJ{constructor(){this.classNameMap={}}static getMap(){return null==aJ.instance&&(aJ.instance=new aJ),aJ.instance}static register(e){aJ.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function aQ(e,t,r){m(null!=e.className,()=>"Class being registered does not have the static className property defined."),m("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),m(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),void 0===t&&(t="Custom"),void 0===r&&(r=e.className);let n=t+">"+r;return aJ.register(e),aX.set(n,e),aZ.set(e,n),e}function a0(e){return aZ.has(e)?aZ.get(e):e.className}e.s(["Serializable",()=>aY,"SerializationMap",()=>aJ,"getRegisteredName",()=>a0,"registerClass",()=>aQ],86862);class a1 extends aY{minimize(e,t=!1,r){let{value:n,grads:a}=this.computeGradients(e,r);if(null!=r){let e=r.map(e=>({name:e.name,tensor:a[e.name]}));this.applyGradients(e)}else this.applyGradients(a);return(nG(a),t)?n:(n.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return aq(e,t)}dispose(){null!=this.iterations_&&nG(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:aK(this.iterations_,"int32")}}async getWeights(){throw Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(a1,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients}),e.s(["Optimizer",()=>a1],18985);class a2 extends a1{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==r&&(this.epsilon=na.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,r)=>{let n=na.registeredVariables[t];null==this.accumulatedGrads[r]&&(this.accumulatedGrads[r]={originalName:`${t}/accum_grad`,variable:nU(()=>aB(n).variable(!1))}),null==this.accumulatedUpdates[r]&&(this.accumulatedUpdates[r]={originalName:`${t}/accum_var`,variable:nU(()=>aB(n).variable(!1))});let a=Array.isArray(e)?e[r].tensor:e[t];if(null==a)return;let s=this.accumulatedGrads[r].variable,i=this.accumulatedUpdates[r].variable;nU(()=>{let e=aO(aL(s,this.rho),aL(aP(a),1-this.rho)),t=aL(aM(az(aO(i,this.epsilon)),az(aO(s,this.epsilon))),a),r=aO(aL(i,this.rho),aL(aP(t),1-this.rho));s.assign(e),i.assign(r);let o=aO(aL(t,-this.learningRate),n);n.assign(o)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(nG(this.accumulatedGrads.map(e=>e.variable)),nG(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){let t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedUpdates=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function a3(e,t,r){Z(e),r=r||V(t);let n={shape:e,value:t,dtype:r};return na.runKernel(eJ,{},n)}e.s(["AdadeltaOptimizer",()=>a2],40922),e.s(["fill",()=>a3],27553);class a4 extends a1{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,r)=>{let n=na.registeredVariables[t];null==this.accumulatedGrads[r]&&(this.accumulatedGrads[r]={originalName:`${t}/accumulator`,variable:nU(()=>a3(n.shape,this.initialAccumulatorValue).variable(!1))});let a=Array.isArray(e)?e[r].tensor:e[t];if(null==a)return;let s=this.accumulatedGrads[r].variable;nU(()=>{let e=aO(s,aP(a));s.assign(e);let t=aO(aL(aM(a,az(aO(e,na.backend.epsilon()))),-this.learningRate),n);n.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&nG(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}e.s(["AdagradOptimizer",()=>a4],6587);let a6=n$({pow_:function(e,t){let r=nT(e,"base","pow"),n=nT(t,"exp","pow");[r,n]=r5(r,n);let a={a:r,b:n};return na.runKernel("Pow",a)}});e.s(["pow",0,a6],16181);let a5=n$({sub_:function(e,t){let r=nT(e,"a","sub"),n=nT(t,"b","sub");[r,n]=r5(r,n);let a={a:r,b:n};return na.runKernel("Sub",a)}});e.s(["sub",0,a5],76413);class a8 extends a1{static get className(){return"Adam"}constructor(e,t,r,n=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=n,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],nU(()=>{this.accBeta1=aK(t).variable(),this.accBeta2=aK(r).variable()}),null==n&&(this.epsilon=na.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);nU(()=>{let r=a5(1,this.accBeta1),n=a5(1,this.accBeta2);t.forEach((t,a)=>{let s=na.registeredVariables[t];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:nU(()=>aB(s).variable(!1))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:nU(()=>aB(s).variable(!1))});let i=Array.isArray(e)?e[a].tensor:e[t];if(null==i)return;let o=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,u=aO(aL(o,this.beta1),aL(i,1-this.beta1)),h=aO(aL(l,this.beta2),aL(aP(i),1-this.beta2)),p=aM(u,r),d=aM(h,n);o.assign(u),l.assign(h);let c=aO(aL(aM(p,aO(az(d),this.epsilon)),-this.learningRate),s);s.assign(c)}),this.accBeta1.assign(aL(this.accBeta1,this.beta1)),this.accBeta2.assign(aL(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&nG(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&nG(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),nU(()=>{this.accBeta1.assign(a6(this.beta1,this.iterations_+1)),this.accBeta2.assign(a6(this.beta2,this.iterations_+1))});let t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedSecondMoment=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}e.s(["AdamOptimizer",()=>a8],54463);let a9=n$({abs_:function(e){let t=nT(e,"x","abs");return"complex64"===t.dtype?na.runKernel(e$,{x:t}):na.runKernel("Abs",{x:t})}});function a7(e,t){let r=e.length,n=[];for(let a=0;a<r;a++){let s=r-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&1===i&&n.unshift(s)}return n}function se(e,t){let r=[];for(let n=0;n<t.length;n++){let a=e[e.length-n-1],s=t.length-n-1,i=t[s];(null==a||1===a&&i>1)&&r.unshift(s)}return r}function st(e,t){let r=Math.max(e.length,t.length),n=Array(r);for(let a=0;a<r;a++){let s=e[e.length-a-1];null==s&&(s=1);let i=t[t.length-a-1];if(null==i&&(i=1),1===s)n[r-a-1]=i;else if(1===i)n[r-a-1]=s;else if(s!==i)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);else n[r-a-1]=s}return n}e.s(["abs",0,a9],8252),e.s(["assertAndGetBroadcastShape",()=>st,"getBroadcastDims",()=>a7,"getReductionAxes",()=>se],42242);let sr=n$({maximum_:function(e,t){let r=nT(e,"a","maximum"),n=nT(t,"b","maximum");[r,n]=r5(r,n),"bool"===r.dtype&&(r=aR(r,"int32"),n=aR(n,"int32")),st(r.shape,n.shape);let a={a:r,b:n};return na.runKernel(tp,a)}});e.s(["maximum",0,sr],11787);class sn extends a1{static get className(){return"Adamax"}constructor(e,t,r,n=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=n,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],nU(()=>{this.iteration=aK(0).variable(),this.accBeta1=aK(t).variable()}),null==n&&(this.epsilon=na.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);nU(()=>{let r=a5(1,this.accBeta1),n=aM(-this.learningRate,aO(aL(this.iteration,this.decay),1));t.forEach((t,a)=>{let s=na.registeredVariables[t];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:aB(s).variable(!1)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:aB(s).variable(!1)});let i=Array.isArray(e)?e[a].tensor:e[t];if(null==i)return;let o=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,u=aO(aL(o,this.beta1),aL(i,1-this.beta1)),h=sr(aL(l,this.beta2),a9(i));o.assign(u),l.assign(h);let p=aO(aL(aM(n,r),aM(u,aO(h,this.epsilon))),s);s.assign(p)}),this.iteration.assign(aO(this.iteration,1)),this.accBeta1.assign(aL(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&nG(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&nG(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}e.s(["AdamaxOptimizer",()=>sn],73824);class sa extends a1{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,r)=>{let n=Array.isArray(e)?e[r].tensor:e[t];if(null==n)return;let a=na.registeredVariables[t];nU(()=>{let e=aO(aL(this.c,n),a);a.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=nq(aK(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}e.s(["SGDOptimizer",()=>sa],52850);class ss extends sa{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=aK(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,r)=>{let n=na.registeredVariables[t];null==this.accumulations[r]&&(this.accumulations[r]={originalName:`${t}/momentum`,variable:nU(()=>aB(n).variable(!1))});let a=this.accumulations[r].variable,s=Array.isArray(e)?e[r].tensor:e[t];null!=s&&nU(()=>{let e,t=aO(aL(this.m,a),s);e=this.useNesterov?aO(aL(this.c,aO(s,aL(t,this.m))),n):aO(aL(this.c,t),n),a.assign(t),n.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&nG(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}e.s(["MomentumOptimizer",()=>ss],91995);class si extends a1{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,n=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=n,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==n&&(this.epsilon=na.backend.epsilon()),null==e)throw Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,r)=>{let n=na.registeredVariables[t];null==this.accumulatedMeanSquares[r]&&(this.accumulatedMeanSquares[r]={originalName:`${t}/rms`,variable:nU(()=>aB(n).variable(!1))}),null==this.accumulatedMoments[r]&&(this.accumulatedMoments[r]={originalName:`${t}/momentum`,variable:nU(()=>aB(n).variable(!1))}),null==this.accumulatedMeanGrads[r]&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${t}/mg`,variable:nU(()=>aB(n).variable(!1))});let a=Array.isArray(e)?e[r].tensor:e[t];if(null==a)return;let s=this.accumulatedMeanSquares[r].variable,i=this.accumulatedMoments[r].variable;nU(()=>{let e=aO(aL(s,this.decay),aL(aP(a),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[r].variable,o=aO(aL(t,this.decay),aL(a,1-this.decay)),l=aM(aL(a,this.learningRate),az(a5(e,aO(aP(o),this.epsilon)))),u=aO(aL(i,this.momentum),l);s.assign(e),t.assign(o),i.assign(u);let h=a5(n,u);n.assign(h)}else{let e=aO(aL(s,this.decay),aL(aP(a),1-this.decay)),t=aO(aL(i,this.momentum),aM(aL(a,this.learningRate),az(aO(e,this.epsilon))));s.assign(e),i.assign(t);let r=a5(n,t);n.assign(r)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&nG(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&nG(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&nG(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2;this.accumulatedMeanSquares=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedMoments=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}e.s(["RMSPropOptimizer",()=>si],84652);for(let e of[a2,a4,a8,sn,ss,si,sa])aQ(e);function so(e){return new Promise(e=>setTimeout(e)).then(e)}e.s([],70306);class sl{constructor(e){if(!ea.getBool("IS_BROWSER"))throw Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(sl.URL_SCHEME)&&(e=e.slice(sl.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw Error("Browser downloads are not supported in this environment since `document` is not present");let t=nO.join(e.weightData),r=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let t=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],n=aa(e,t),a=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=a,await so(()=>s.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=r,await so(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ao(e)}}}}sl.URL_SCHEME="downloads://";class su{constructor(e){if(null==e||e.length<1)throw Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let r=new FileReader;r.onload=r=>{let n=JSON.parse(r.target.result),a=n.modelTopology;null==a?t(Error(`modelTopology field is missing from file ${this.jsonFile.name}`)):null==n.weightsManifest?t(Error(`weightManifest field is missing from file ${this.jsonFile.name}`)):0===this.weightsFiles.length?e({modelTopology:a}):e(ai(n,e=>this.loadWeights(e)))},r.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){let t=[],r=[];for(let n of e)t.push(...n.weights),r.push(...n.paths);let n=this.checkManifestAndWeightFiles(e);return Promise.all(r.map(e=>this.loadWeightsFile(e,n[e]))).then(e=>[t,e])}loadWeightsFile(e,t){return new Promise((r,n)=>{let a=new FileReader;a.onload=e=>{r(e.target.result)},a.onerror=t=>n(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],r=this.weightsFiles.map(e=>an(e.name)),n={};for(let a of e)a.paths.forEach(e=>{let a=an(e);if(-1!==t.indexOf(a))throw Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===r.indexOf(a))throw Error(`Weight file with basename '${a}' is not provided.`);n[e]=this.weightsFiles[r.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return n}}function sh(e){return new su(e)}function sp(e,t,r,n){var a,s,i;m(null!=(a=e)&&Array.isArray(a)&&a.length>0,()=>"promises must be a none empty array"),s=r=null==r?0:r,i=n=null==n?1:n,m(s>=0&&s<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${s}`),m(i>=0&&i<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${i}`),m(i>=s,()=>`startFraction must be no more than endFraction, but got startFraction ${s} and endFraction ${i}`);let o=0;return Promise.all(e.map(a=>(a.then(a=>(t(r+ ++o/e.length*(n-r)),a)),a)))}async function sd(e,t){null==t&&(t={});let r=null==t.fetchFunc?ea.platform.fetch:t.fetchFunc,n=e.map(e=>r(e,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?await Promise.all(n):await sp(n,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?await Promise.all(a):await sp(a,t.onProgress,.5,1)}async function sc(e,t="",r,n){return sf(e=>sd(e,{requestInit:n}))(e,t,r)}function sf(e){return async(t,r="",n)=>{let a=t.map(()=>!1),s={},i=null!=n?n.map(()=>!1):[],o=[];if(t.forEach((e,t)=>{let r=0;e.weights.forEach(e=>{let l=nF["quantization"in e?e.quantization.dtype:e.dtype]*b(e.shape),u=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:r,sizeBytes:l})};null!=n?n.forEach((t,r)=>{t===e.name&&(u(),i[r]=!0)}):u(),o.push(e.name),r+=l})}),!i.every(e=>e)){let e=n.filter((e,t)=>!i[t]);throw Error(`Could not find weights in manifest with names: ${e.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce((e,t,r)=>(t&&e.push(r),e),[]),u=[];l.forEach(e=>{t[e].paths.forEach(e=>{let t=r+(r.endsWith("/")?"":"/")+e;u.push(t)})});let h=await e(u),p={},d=0;return l.forEach(e=>{let r=t[e].paths.length,n=new nO(h.slice(d,d+r));s[e].forEach(e=>{let t=n3(n.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(let e in t)p[e]=t[e]}),d+=r}),p}}au.registerSaveRouter(e=>ea.getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(sl.URL_SCHEME)?function(e="model"){return new sl(e)}(e.slice(sl.URL_SCHEME.length)):null);class sm{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(m("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ea.platform.fetch,m(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&m(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],n=aa(e,r);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){let r=nO.join(e.weightData);t.body.append("model.weights.bin",new Blob([r],{type:"application/octet-stream"}),"model.weights.bin")}let a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:ao(e),responses:[a]};throw Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){let e,t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",Error(e)}let r=e.modelTopology,n=e.weightsManifest;if(null==r&&null==n)throw Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){return this.loadOptions.streamWeights?this.loadStream():ai(await this.loadModelJSON(),e=>this.loadWeights(e))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),r=al(e.weightsManifest),n=()=>{var e,r;let n,a,s;return a=null==(e=this.loadOptions).fetchFunc?ea.platform.fetch:e.fetchFunc,s=0,null==(r=e.onProgress)||r.call(e,0),new ReadableStream({pull:async r=>{for(var i;s<t.length;){n||(n=(await a(t[s],e.requestInit,{isBinary:!0})).body.getReader());let{done:o,value:l}=await n.read();if(o){s++,n=void 0,null==(i=e.onProgress)||i.call(e,s/t.length);continue}r.enqueue(l);return}r.close()}})};return Object.assign(Object.assign({},e),{weightSpecs:r,getWeightStream:n})}async getWeightUrls(e){var t;let r,n,[a,s]=(r=(t=Array.isArray(this.path)?this.path[1]:this.path).lastIndexOf("/"),n=t.lastIndexOf("?"),[t.substring(0,r)+"/",n>r?t.substring(n):""]),i=this.weightPathPrefix||a,o=[],l=[];for(let t of e)for(let e of t.paths)null!=this.weightUrlConverter?l.push(this.weightUrlConverter(e)):o.push(i+e+s);return this.weightUrlConverter&&o.push(...await Promise.all(l)),o}async loadWeights(e){let t=await this.getWeightUrls(e);return[al(e),await sd(t,this.loadOptions)]}}function sg(e){return null!=e.match(sm.URL_SCHEME_REGEX)}sm.URL_SCHEME_REGEX=/^https?:\/\//;let sy=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc));else if(Array.isArray(e)?e.every(e=>sg(e)):sg(e))return sb(e,t);return null};function sb(e,t){return new sm(e,t)}function sx(e,t){return sb(e,t)}au.registerSaveRouter(sy),au.registerLoadRouter(sy);class sv{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class sw{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class sS{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function sN(e,t,r,n){let a=arguments;return new sS(sk(...a))}function sk(e,t,r,n){return 1!=arguments.length?(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new sv({modelTopology:e,weightSpecs:t,weightData:r,trainingConfig:n})):null!=e.modelTopology||null!=e.weightSpecs?new sv(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new sv({modelTopology:e}))}function sI(e){return new sw(e)}function sT(e){return new sw(e)}e.s([],59966),e.i(59966),e.s(["CompositeArrayBuffer",()=>nO,"browserFiles",()=>sh,"browserHTTPRequest",()=>sx,"concatenateArrayBuffers",()=>ar,"copyModel",()=>aE,"decodeWeights",()=>n3,"decodeWeightsStream",()=>n8,"encodeWeights",()=>n2,"fromMemory",()=>sN,"fromMemorySync",()=>sk,"getLoadHandlers",0,(e,t)=>au.getLoadHandlers(e,t),"getModelArtifactsForJSON",()=>ai,"getModelArtifactsForJSONSync",()=>as,"getModelArtifactsInfoForJSON",()=>ao,"getSaveHandlers",0,e=>au.getSaveHandlers(e),"getWeightSpecs",()=>al,"http",()=>sb,"isHTTPScheme",()=>sg,"listModels",()=>aT,"loadWeights",()=>sc,"moveModel",()=>a$,"registerLoadRouter",0,e=>au.registerLoadRouter(e),"registerSaveRouter",0,e=>au.registerSaveRouter(e),"removeModel",()=>aC,"weightsLoaderFactory",()=>sf,"withSaveHandler",()=>sI,"withSaveHandlerSync",()=>sT],61898),e.i(91587),e.i(86879);var sC=e.i(1392);let sE=sC.default||sC;function s$(e){return sE.fromString(e,!0,16)}let sA=s$("c3a5c85c97cb3127"),sR=s$("b492b66fbe98f273"),sD=s$("9ae16a3b2f90404f");function sF(e){return e.xor(e.shru(47))}function sO(e,t,r){let n=e.slice(t,t+r);return sE.fromBytes(Array.from(n),!0,!0)}function s_(e,t){return sO(e,t,8)}function sM(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function sL(e,t,r=s$("9ddfea08eb382d69")){let n=e.xor(t).mul(r);n=n.xor(n.shru(47));let a=t.xor(n).mul(r);return(a=a.xor(a.shru(47))).mul(r)}function sz(e,t,r,n){var a,s,i,o,l,u;let h;return a=s_(e,t),s=s_(e,t+8),i=s_(e,t+16),o=s_(e,t+24),l=r,u=n,l=l.add(a),u=sM(u.add(l).add(o),21),h=l,l=(l=l.add(s)).add(i),u=u.add(sM(l,44)),[l.add(o),u.add(h)]}function sP(e,t=e.length){let r=sE.fromNumber(81,!0);if(t<=32)if(t<=16)return function(e,t=e.length){if(t>=8){let r=sD.add(2*t),n=s_(e,0).add(sD),a=s_(e,t-8);return sL(sM(a,37).mul(r).add(n),sM(n,25).add(a).mul(r),r)}if(t>=4){let r=sD.add(2*t);return sL(sO(e,0,4).shl(3).add(t),sO(e,t-4,4),r)}if(t>0){let r=e[0],n=e[t>>1],a=e[t-1];return sF(sD.mul(r+(n<<8)).xor(sA.mul(t+(a<<2)))).mul(sD)}return sD}(e,t);else return function(e,t=e.length){let r=sD.add(2*t),n=s_(e,0).mul(sR),a=s_(e,8),s=s_(e,t-8).mul(r),i=s_(e,t-16).mul(sD);return sL(sM(n.add(a),43).add(sM(s,30)).add(i),n.add(sM(a.add(sD),18)).add(s),r)}(e,t);if(t<=64)return function(e,t=e.length){let r=sD.add(2*t),n=s_(e,0).mul(sD),a=s_(e,8),s=s_(e,t-8).mul(r),i=s_(e,t-16).mul(sD),o=sM(n.add(a),43).add(sM(s,30)).add(i),l=sL(o,n.add(sM(a.add(sD),18)).add(s),r),u=s_(e,16).mul(r),h=s_(e,24),p=o.add(s_(e,t-32)).mul(r),d=l.add(s_(e,t-24)).mul(r);return sL(sM(u.add(h),43).add(sM(p,30)).add(d),u.add(sM(h.add(n),18)).add(p),r)}(e,t);let n=r,a=r.mul(sR).add(113),s=sF(a.mul(sD).add(113)).mul(sD),i=[sE.UZERO,sE.UZERO],o=[sE.UZERO,sE.UZERO];n=n.mul(sD).add(s_(e,0));let l=0,u=(t-1>>6)*64,h=u+(t-1&63)-63;do n=sM(n.add(a).add(i[0]).add(s_(e,l+8)),37).mul(sR),a=sM(a.add(i[1]).add(s_(e,l+48)),42).mul(sR),n=n.xor(o[1]),a=a.add(i[0]).add(s_(e,l+40)),s=sM(s.add(o[0]),33).mul(sR),i=sz(e,l,i[1].mul(sR),n.add(o[0])),o=sz(e,l+32,s.add(o[1]),a.add(s_(e,l+16))),[s,n]=[n,s],l+=64;while(l!==u)let p=sR.add(s.and(255).shl(1));return l=h,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),n=sM(n.add(a).add(i[0]).add(s_(e,l+8)),37).mul(p),a=sM(a.add(i[1]).add(s_(e,l+48)),42).mul(p),n=n.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(s_(e,l+40))),s=sM(s.add(o[0]),33).mul(p),i=sz(e,l,i[1].mul(p),n.add(o[0])),o=sz(e,l+32,s.add(o[1]),a.add(s_(e,l+16))),[s,n]=[n,s],sL(sL(i[0],o[0],p).add(sF(a).mul(sA)).add(s),sL(i[1],o[1],p).add(n),p)}e.s(["fingerPrint64",()=>sP,"hexToLong",()=>s$],57757),e.i(57757),e.s(["arraysEqual",()=>w,"arraysEqualWithNull",()=>v,"assert",()=>m,"assertNonNegativeIntegerDimensions",()=>Z,"assertNonNull",()=>y,"assertShapesMatch",()=>g,"bytesFromStringArray",()=>L,"bytesPerElement",()=>M,"checkConversionForErrors",()=>F,"clamp",()=>u,"computeStrides",()=>G,"convertBackendValuesAndArrayBuffer",()=>H,"createScalarValue",()=>rF,"createShuffledIndices",()=>I,"decodeString",()=>rz,"distSquared",()=>f,"encodeString",()=>rL,"fetch",()=>rM,"fingerPrint64",()=>sP,"flatten",()=>rB,"getArrayFromDType",()=>D,"getTypedArrayFromDType",()=>R,"hasEncodingLoss",()=>_,"hexToLong",()=>s$,"indexToLoc",()=>J,"inferDtype",()=>V,"inferFromImplicitShape",()=>E,"isBoolean",()=>P,"isFunction",()=>W,"isInt",()=>S,"isNumber",()=>B,"isPromise",()=>Q,"isScalarShape",()=>x,"isString",()=>z,"isTypedArray",()=>rP,"isValidDtype",()=>O,"locToIndex",()=>Y,"makeOnesTypedArray",()=>j,"makeZerosNestedTypedArray",()=>X,"makeZerosTypedArray",()=>K,"nearestDivisor",()=>U,"nearestLargerEven",()=>h,"now",()=>r_,"parseAxisParam",()=>$,"randUniform",()=>c,"repeatedTry",()=>C,"rightPad",()=>T,"shuffle",()=>o,"shuffleCombo",()=>l,"sizeFromShape",()=>b,"sizeToSquarishShape",()=>k,"squeezeShape",()=>A,"sum",()=>d,"swap",()=>p,"tanh",()=>N,"toNestedArray",()=>q,"toTypedArray",()=>rO],34338);let sB=n$({concat_:function(e,t=0){m(e.length>=1,()=>"Pass at least one tensor to concat");let r=nC(e,"tensors","concat","string_or_numeric");return("complex64"===r[0].dtype&&r.forEach(e=>{if("complex64"!==e.dtype)throw Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${e.dtype}. `)}),1===r.length)?aD(r[0]):na.runKernel(eA,r,{axis:t})}});e.s(["concat",0,sB],48012);let sV=n$({imag_:function(e){let t=nT(e,"input","imag");return na.runKernel(e7,{input:t})}}),sW=n$({real_:function(e){let t=nT(e,"input","real");return na.runKernel(tO,{input:t})}}),sU=n$({reshape_:function(e,t){let r=nT(e,"x","reshape","string_or_numeric");return na.runKernel(tL,{x:r},{shape:t})}});e.s(["reshape",0,sU],74647);let sG=n$({slice_:function(e,t,r){let n=nT(e,"x","slice","string_or_numeric");if(0===n.rank)throw Error("Slicing scalar is not possible");return na.runKernel(tX,{x:n},{begin:t,size:r})}});e.s(["slice",0,sG],3116);let sq=n$({split_:function(e,t,r=0){let n=nT(e,"x","split");return na.runKernel(t2,{x:n},{numOrSizeSplits:t,axis:r})}});function sH(e,t="float32"){if(Z(e),"complex64"===t)return nA(sH(e,"float32"),sH(e,"float32"));let r=K(b(e),t);return na.makeTensor(r,e,t)}e.s(["split",0,sq],49506),e.s(["zeros",()=>sH],22012);let sj=n$({fft_:function(e){return m("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`),na.runKernel("FFT",{input:e})}});e.s(["fft",0,sj],85280);let sK=n$({rfft_:function(e,t){let r;m("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],a=e.size/n;if(null!=t&&t<n){let a=e.shape.map(e=>0),s=e.shape.map(e=>e);s[e.shape.length-1]=t,r=sG(e,a,s),n=t}else if(null!=t&&t>n){let a=e.shape.map(e=>e);a[e.shape.length-1]=t-n,r=sB([e,sH(a)],e.shape.length-1),n=t}else r=e;let s=aB(r),i=sj(sU(nA(r,s),[a,n])),o=Math.floor(n/2)+1,l=sW(i),u=sV(i),h=sq(l,[o,n-o],l.shape.length-1),p=sq(u,[o,n-o],u.shape.length-1),d=r.shape.slice();return d[r.shape.length-1]=o,sU(nA(h[0],p[0]),d)}});e.s(["rfft",0,sK],2182);let sX=n$({ifft_:function(e){return m("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`),na.runKernel(e9,{input:e})}});e.s(["ifft",0,sX],5247);let sZ=n$({reverse_:function(e,t){let r=nT(e,"x","reverse");return na.runKernel(tV,{x:r},{dims:t})}});e.s(["reverse",0,sZ],2173);let sY=n$({irfft_:function(e){let t,r=e.shape[e.shape.length-1],n=e.size/r;if(r<=2)t=sX(sU(e,[n,r]));else{let a=[n,2*(r-1)],s=sU(sW(e),[n,r]),i=sU(sV(e),[n,r]),o=sZ(sG(s,[0,1],[n,r-2]),1),l=aL(sZ(sG(i,[0,1],[n,r-2]),1),aK(-1));t=sX(sU(nA(sB([s,o],1),sB([i,l],1)),[a[0],a[1]]))}if(t=sW(t),3===e.rank&&0!==e.shape[0]){let r=t,n=e.shape[0];t=sU(t,[n,t.shape[0]/n,t.shape[1]]),r.dispose()}return t}});function sJ(e,t,r,n,a="NHWC",s){let i=[...t,e[3]];return s1(e,i,r,s,n,null,null,it(a))}function sQ(e,t,r,n,a,s,i="channelsLast"){let o,[l,u]=s4(t);if("channelsLast"===i)o=[l,u,e[3],e[3]];else if("channelsFirst"===i)o=[l,u,e[1],e[1]];else throw Error(`Unknown dataFormat ${i}`);return s1(e,o,r,n,a,s,!1,i)}function s0(e,t,r,n,a,s,i="NDHWC"){let o,l,[u,h,p]=s6(t);if("NDHWC"===i)l="channelsLast",o=[u,h,p,e[4],e[4]];else if("NCDHW"===i)l="channelsFirst",o=[u,h,p,e[1],e[1]];else throw Error(`Unknown dataFormat ${i}`);return s2(e,o,r,n,a,!1,l,s)}function s1(e,t,r,n,a,s,i=!1,o="channelsLast"){let l,[u,h,p,d]=[-1,-1,-1,-1];if("channelsLast"===o)[u,h,p,d]=e;else if("channelsFirst"===o)[u,d,h,p]=e;else throw Error(`Unknown dataFormat ${o}`);let[c,f,,m]=t,[g,y]=s4(r),[b,x]=s4(n),v=s5(c,b),w=s5(f,x),{padInfo:S,outHeight:N,outWidth:k}=function(e,t,r,n,a,s,i,o,l){let u,h,p;if("number"==typeof e){var d,c;let a,i,l=0===e?"VALID":"NUMBER";u={top:e,bottom:e,left:e,right:e,type:l};let f=(d=[t,r],null==(c=e)&&(c=s3(d,s,n)),a=d[0],i=d[1],[s8((a-s+2*c)/n+1,o),s8((i-s+2*c)/n+1,o)]);h=f[0],p=f[1]}else if("same"===e){let e=Math.max(0,((h=Math.ceil(t/n))-1)*n+s-t),o=Math.max(0,((p=Math.ceil(r/a))-1)*a+i-r),l=Math.floor(e/2),d=Math.floor(o/2);u={top:l,bottom:e-l,left:d,right:o-d,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((t-s+1)/n),p=Math.ceil((r-i+1)/a);else if("object"==typeof e){let d="channelsLast"===l?e[1][0]:e[2][0],c="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:d,bottom:c,left:f,right:m,type:0===d&&0===c&&0===f&&0===m?"VALID":"EXPLICIT"},h=s8((t-s+d+c)/n+1,o),p=s8((r-i+f+m)/a+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:h,outWidth:p}}(a,h,p,g,y,v,w,s,o),I=i?m*d:m;return"channelsFirst"===o?l=[u,I,N,k]:"channelsLast"===o&&(l=[u,N,k,I]),{batchSize:u,dataFormat:o,inHeight:h,inWidth:p,inChannels:d,outHeight:N,outWidth:k,outChannels:I,padInfo:S,strideHeight:g,strideWidth:y,filterHeight:c,filterWidth:f,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:x,inShape:e,outShape:l,filterShape:t}}function s2(e,t,r,n,a,s=!1,i="channelsLast",o){let l,[u,h,p,d,c]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[u,h,p,d,c]=e;else if("channelsFirst"===i)[u,c,h,p,d]=e;else throw Error(`Unknown dataFormat ${i}`);let[f,m,g,,y]=t,[b,x,v]=s6(r),[w,S,N]=s6(n),k=s5(f,w),I=s5(m,S),T=s5(g,N),{padInfo:C,outDepth:E,outHeight:$,outWidth:A}=function(e,t,r,n,a,s,i,o,l,u,h){let p,d,c,f;if("valid"===e&&(e=0),"number"==typeof e){let m=0===e?"VALID":"NUMBER";p={top:e,bottom:e,left:e,right:e,front:e,back:e,type:m};let g=function(e,t,r,n,a,s){null==a&&(a=s3(e,t[0],n[0]));let i=[0,0,0,1];for(let r=0;r<3;r++)e[r]+2*a>=t[r]&&(i[r]=s8((e[r]-t[r]+2*a)/n[r]+1,s));return i}([t,r,n,1],[o,l,u],0,[a,s,i],e,h);d=g[0],c=g[1],f=g[2]}else if("same"===e){let e=((d=Math.ceil(t/a))-1)*a+o-t,h=((c=Math.ceil(r/s))-1)*s+l-r,m=((f=Math.ceil(n/i))-1)*i+u-n,g=Math.floor(e/2),y=Math.floor(h/2),b=Math.floor(m/2);p={top:y,bottom:h-y,left:b,right:m-b,front:g,back:e-g,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:p,outDepth:d,outHeight:c,outWidth:f}}(a,h,p,d,b,x,v,k,I,T,o),R=s?y*c:y;return"channelsFirst"===i?l=[u,R,E,$,A]:"channelsLast"===i&&(l=[u,E,$,A,R]),{batchSize:u,dataFormat:i,inDepth:h,inHeight:p,inWidth:d,inChannels:c,outDepth:E,outHeight:$,outWidth:A,outChannels:R,padInfo:C,strideDepth:b,strideHeight:x,strideWidth:v,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:k,effectiveFilterHeight:I,effectiveFilterWidth:T,dilationDepth:w,dilationHeight:S,dilationWidth:N,inShape:e,outShape:l,filterShape:t}}function s3(e,t,r,n=1){let a=s5(t,n);return Math.floor((e[0]*(r-1)-r+a)/2)}function s4(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function s6(e){return"number"==typeof e?[e,e,e]:e}function s5(e,t){return t<=1?e:e+(e-1)*(t-1)}function s8(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw Error(`Unknown roundingMode ${t}`)}}function s9(e){let[t,r,n]=s4(e);return 1===t&&1===r&&1===n}function s7(e,t){return s9(e)||s9(t)}function ie(e){return s4(e).every(e=>e>0)}function it(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw Error(`Unknown dataFormat ${e}`)}function ir(e,t,r){if(null!=r)if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${r} but got pad ${t}.`);else if("number"==typeof t)m(S(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${r} but got pad ${t}.`);else if("object"==typeof t)t.forEach(t=>{t.forEach(t=>{m(S(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${r} but got pad ${t}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}e.s(["irfft",0,sY],92700),e.s(["checkPadOnDimRoundingMode",()=>ir,"computeConv2DInfo",()=>s1,"computeConv3DInfo",()=>s2,"computeDefaultPad",()=>s3,"computeDilation2DInfo",()=>sJ,"computePool2DInfo",()=>sQ,"computePool3DInfo",()=>s0,"convertConv2DDataFormat",()=>it,"eitherStridesOrDilationsAreOne",()=>s7,"stridesOrDilationsArePositive",()=>ie,"tupleValuesAreOne",()=>s9],19813);let ia=n$({conv2d_:function(e,t,r,n,a="NHWC",s=[1,1],i){let o=nT(e,"x","conv2d","float32"),l=nT(t,"filter","conv2d","float32"),u=o,h=!1;3===o.rank&&(h=!0,u=sU(o,[1,o.shape[0],o.shape[1],o.shape[2]])),m(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),m(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),ir("conv2d",n,i);let p="NHWC"===a?u.shape[3]:u.shape[1];m(p===l.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`),m(s7(r,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${s}'`),m(ie(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),m(ie(r),()=>"Error in conv2D: Strides should be larger than 0.");let d={x:u,filter:l},c=na.runKernel(eR,d,{strides:r,pad:n,dataFormat:a,dilations:s,dimRoundingMode:i});return h?sU(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});e.s(["conv2d",0,ia],97529);let is=n$({conv2DBackpropFilter_:function(e,t,r,n,a,s="NHWC",i){let o=e;3===e.rank&&(o=sU(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=sU(t,[1,t.shape[0],t.shape[1],t.shape[2]])),m(4===o.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),m(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),m(4===r.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${r}.`);let u="NHWC"===s?o.shape[3]:o.shape[1],h="NHWC"===s?l.shape[3]:l.shape[1];m(u===r[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${r[2]}.`),m(h===r[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${r[3]}).`),ir("conv2dDerFilter",a,i);let p={x:o,dy:l};return na.runKernel(eD,p,{strides:n,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:r})}});e.s(["conv2DBackpropFilter",0,is],31837);let ii=n$({conv2DBackpropInput_:function(e,t,r,n,a,s="NHWC",i){m(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=sU(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),m(4===o.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),m(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),m(4===r.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${r.rank}`);let h="NHWC"===s?o[3]:o[1],p="NHWC"===s?l.shape[3]:l.shape[1];m(h===r.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${r.shape[2]}.`),m(p===r.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${r.shape[3]}.`),ir("conv2dDerInput",a,i);let d={dy:l,filter:r},c={strides:n,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=na.runKernel(eF,d,c);return u?sU(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});e.s(["conv2DBackpropInput",0,ii],35032);let io=n$({elu_:function(e){let t=nT(e,"x","elu","float32");return na.runKernel("Elu",{x:t})}});e.s(["elu",0,io],21704);let il=n$({leakyRelu_:function(e,t=.2){let r=nT(e,"x","leakyRelu");return na.runKernel(tn,{x:r},{alpha:t})}});e.s(["leakyRelu",0,il],14545);let iu=n$({prelu_:function(e,t){let r=nT(e,"x","prelu"),n=nT(t,"alpha","prelu");return na.runKernel(tE,{x:r,alpha:n})}});e.s(["prelu",0,iu],90506);let ih=n$({relu_:function(e){let t=nT(e,"x","relu");return na.runKernel(tM,{x:t})}});e.s(["relu",0,ih],60752);let ip=n$({relu6_:function(e){let t=nT(e,"x","relu6");return na.runKernel(tB,{x:t})}});e.s(["relu6",0,ip],17016);let id=n$({sigmoid_:function(e){let t=nT(e,"x","sigmoid","float32");return na.runKernel(tJ,{x:t})}});e.s(["sigmoid",0,id],38015);let ic=n$({step_:function(e,t=0){let r=nT(e,"x","step");return na.runKernel(rf,{x:r},{alpha:t})}});e.s(["step",0,ic],27e3);let im=n$({sum_:function(e,t=null,r=!1){let n=nT(e,"x","sum");"bool"===n.dtype&&(n=aR(n,"int32"));let a={x:n};return na.runKernel("Sum",a,{axis:t,keepDims:r})}});function ig(e,t,r){if(null==r||"linear"===r)return e;if("relu"===r)return aL(e,ic(t));throw Error(`Cannot compute gradient for fused activation ${r}.`)}function iy(e,t){let r=t,n=se(e.shape,t.shape);return n.length>0&&(r=im(r,n)),sU(r,e.shape)}function ib(e,t,r,n){if("linear"===t)return e;if("relu"===t)return ih(e);if("elu"===t)return io(e);if("relu6"===t)return ip(e);if("prelu"===t)return iu(e,r);else if("leakyrelu"===t)return il(e,n);else if("sigmoid"===t)return id(e);throw Error(`Unknown fused activation ${t}.`)}e.s(["sum",0,im],33192);let ix=(e,t)=>!(e>0)||"linear"===t;e.s(["applyActivation",()=>ib,"getFusedBiasGradient",()=>iy,"getFusedDyActivation",()=>ig,"shouldFuse",0,ix],77744);let iv=n$({fusedConv2d_:function({x:e,filter:t,strides:r,pad:n,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}){let p,d;if(l=l||"linear",!1===ix(na.state.gradientDepth,l)){m("NHWC"===a,()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let p=ia(e,t,r,n,a,s,i);return null!=o&&(p=aO(p,o)),ib(p,l,u,h)}let c=nT(e,"x","conv2d","float32"),f=nT(t,"filter","conv2d","float32"),g=c,y=!1;3===c.rank&&(y=!0,g=sU(c,[1,c.shape[0],c.shape[1],c.shape[2]])),m(4===g.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),m(4===f.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),ir("fused conv2d",n,i);let b="NHWC"===a?g.shape[3]:g.shape[1];m(f.shape[2]===b,()=>`Error in conv2d: depth of input (${b}) must match input depth for filter ${f.shape[2]}.`),m(s7(r,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${s}'`);let x=s1(g.shape,f.shape,r,s,n,i);if(null!=o&&(p=nT(o,"bias","fused conv2d"),[p]=r5(p,c),"NHWC"===a?st(x.outShape,p.shape):(m(p.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${p.shape.length}.`),m(0===p.shape.length||p.shape[0]===x.outChannels||1===p.shape[0],()=>`Error in fused conv2d: bias shape (${p.shape}) is not compatible with the number of output channels (${x.outChannels})`))),null!=u){let e=u.shape;if(m(e.length<=1||3===e.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`),1===e.length)m(1===e[0]||e[0]===x.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${x.outChannels}).`);else if(3===e.length)try{st(e,x.outShape)}catch(t){throw Error(`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${x.outShape}).`)}d=nT(u,"prelu weights","fused conv2d")}let v=(e,t)=>{m("NHWC"===a,()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`);let[i,o,u,h]=t,p=ig(e,u,l);m(s9(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let d=[ii(o.shape,p,i,r,n),is(o,p,i.shape,r,n)];if(null!=h){let e=iy(h,p);d.push(e)}return d},w={x:g,filter:f,bias:p,preluActivationWeights:d},S={strides:r,pad:n,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:h};return null==o?aH((e,t,r)=>{let n=na.runKernel(ry,w,S);return r([t,e,n]),y&&(n=sU(n,[n.shape[1],n.shape[2],n.shape[3]])),{value:n,gradFunc:v}})(g,f):aH((e,t,r,n)=>{let a=na.runKernel(ry,w,S);return n([t,e,a,r]),y&&(a=sU(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}})(g,f,p)}}),iw=n$({depthwiseConv2d_:function(e,t,r,n,a="NHWC",s=[1,1],i){let o=nT(e,"x","depthwiseConv2d","float32"),l=nT(t,"filter","depthwiseConv2d","float32"),u=o,h=!1;3===o.rank&&(h=!0,u=sU(o,[1,o.shape[0],o.shape[1],o.shape[2]])),m(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),m(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let p="NHWC"===a?u.shape[3]:u.shape[1];m(p===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${l.shape[2]}.`),ir("depthwiseConv2d",n,i);let d={x:u,filter:l},c=na.runKernel(eW,d,{strides:r,pad:n,dataFormat:a,dilations:s,dimRoundingMode:i});return h?sU(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});e.s(["depthwiseConv2d",0,iw],53849);let iS=n$({depthwiseConv2dNativeBackpropFilter_:function(e,t,r,n,a,s=[1,1],i){let o=e;3===e.rank&&(o=sU(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=sU(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l};return na.runKernel(eU,u,{strides:n,pad:a,dimRoundingMode:i,dilations:s,filterShape:r})}});e.s(["depthwiseConv2dNativeBackpropFilter",0,iS],41589);let iN=n$({depthwiseConv2dNativeBackpropInput_:function(e,t,r,n,a,s=[1,1],i){let o=t,l=!1;3===t.rank&&(l=!0,o=sU(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:r},h=na.runKernel(eG,u,{strides:n,pad:a,dimRoundingMode:i,dilations:s,inputShape:e});return l?sU(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});e.s(["depthwiseConv2dNativeBackpropInput",0,iN],96996);let ik=n$({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:r,pad:n,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}){let p,d;if(!1===ix(na.state.gradientDepth,l)){let p=iw(e,t,r,n,a,s,i);return null!=o&&(p=aO(p,o)),ib(p,l,u,h)}let c=nT(e,"x","depthwiseConv2d","float32"),f=nT(t,"filter","depthwiseConv2d","float32"),g=c,y=!1;3===c.rank&&(y=!0,g=sU(c,[1,c.shape[0],c.shape[1],c.shape[2]])),m(4===g.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),m(4===f.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),m(g.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),null==s&&(s=[1,1]),m(s7(r,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${s}'`),ir("fused depthwiseConv2d",n,i);let b=s1(g.shape,f.shape,r,s,n,i,!0);null!=o&&(p=nT(o,"bias","fused conv2d"),[p]=r5(p,c),st(b.outShape,p.shape)),null!=u&&(d=nT(u,"prelu weights","fused depthwiseConv2d"));let x=(e,t)=>{m(s9(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[a,o,u,h]=t,d=ig(e,u,l),c=iN(o.shape,d,a,r,n,s,i),f=iS(o,d,a.shape,r,n,s,i);return null!=h?[c,f,iy(p,d)]:[c,f]},v={x:g,filter:f,bias:p,preluActivationWeights:d},w={strides:r,pad:n,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:h};return null==o?aH((e,t,r)=>{let n=na.runKernel(rb,v,w);return r([t,e,n]),y&&(n=sU(n,[n.shape[1],n.shape[2],n.shape[3]])),{value:n,gradFunc:x}})(g,f):aH((e,t,r,n)=>{let a=na.runKernel(rb,v,w);return n([t,e,a,r]),y&&(a=sU(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}})(g,f,p)}}),iI=n$({matMul_:function(e,t,r=!1,n=!1){let a=nT(e,"a","matMul"),s=nT(t,"b","matMul");[a,s]=r5(a,s);let i={a:a,b:s};return na.runKernel(ev,i,{transposeA:r,transposeB:n})}});e.s(["matMul",0,iI],91555);let iT=n$({fusedMatMul_:function({a:e,b:t,transposeA:r=!1,transposeB:n=!1,bias:a,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){let l,u;if(!1===ix(na.state.gradientDepth,s)){let l=iI(e,t,r,n);return null!=a&&(l=aO(l,a)),ib(l,s,i,o)}let h=nT(e,"a","fused matMul"),p=nT(t,"b","fused matMul");[h,p]=r5(h,p);let d=r?h.shape[h.rank-2]:h.shape[h.rank-1],c=n?p.shape[p.rank-1]:p.shape[p.rank-2],f=r?h.shape[h.rank-1]:h.shape[h.rank-2],g=n?p.shape[p.rank-2]:p.shape[p.rank-1],y=h.shape.slice(0,-2),x=p.shape.slice(0,-2),v=b(y),w=b(x);m(d===c,()=>`Error in fused matMul: inner shapes (${d}) and (${c}) of Tensors with shapes ${h.shape} and ${p.shape} and transposeA=${r} and transposeB=${n} must match.`);let S=st(h.shape.slice(0,-2),p.shape.slice(0,-2)).concat([f,g]),N=r?sU(h,[v,d,f]):sU(h,[v,f,d]),k=n?sU(p,[w,g,c]):sU(p,[w,c,g]);null!=a&&(l=nT(a,"bias","fused matMul"),[l]=r5(l,h),st(S,l.shape)),null!=i&&(u=nT(i,"prelu weights","fused matMul"));let I=(e,t)=>{let i,o,[l,u,h,p]=t,d=ig(sU(e,h.shape),h,s);return(r||n?!r&&n?(i=iI(d,u,!1,!1),o=iI(d,l,!0,!1)):r&&!n?(i=iI(u,d,!1,!0),o=iI(l,d,!1,!1)):(i=iI(u,d,!0,!0),o=iI(d,l,!0,!0)):(i=iI(d,u,!1,!0),o=iI(l,d,!0,!1)),null!=a)?[i,o,iy(p,d)]:[i,o]},T={a:N,b:k,bias:l,preluActivationWeights:u},C={transposeA:r,transposeB:n,activation:s,leakyreluAlpha:o};return null==a?aH((e,t,r)=>{let n=na.runKernel(rg,T,C);return r([e,t,n]),{value:sU(n,S),gradFunc:I}})(N,k):aH((e,t,r,n)=>{let a=na.runKernel(rg,T,C);return n([e,t,a,r]),{value:sU(a,S),gradFunc:I}})(N,k,l)}});e.s([],29746),e.i(29746),e.s(["conv2d",0,iv,"depthwiseConv2d",0,ik,"matMul",0,iT],85474);var iC=e.i(85474);function iE(e,t){y(e);let r=nk(e,t);if(1!==r.length)throw Error("tensor1d() requires values to be a flat/TypedArray");return nR(e,null,r,t)}function i$(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function iA(e,t,r){let n=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+n-1);a[s]=t-r*Math.cos(i)}return iE(a,"float32")}e.s(["tensor1d",()=>iE],40855),e.s(["cosineWindow",()=>iA,"enclosingPowerOfTwo",()=>i$],96851);let iR=n$({hammingWindow_:function(e){return iA(e,.54,.46)}}),iD=n$({hannWindow_:function(e){return iA(e,.5,.5)}});function iF(e,t,r){if(y(e),null!=t&&2!==t.length)throw Error("tensor2d() requires shape to have two numbers");let n=nk(e,r);if(2!==n.length&&1!==n.length)throw Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===n.length&&null==t)throw Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return nR(e,t,n,r)}e.s(["tensor2d",()=>iF],38363);let iO=n$({frame_:function(e,t,r,n=!1,a=0){let s=0,i=[];for(;s+t<=e.size;)i.push(sG(e,s,t)),s+=r;if(n)for(;s<e.size;){let n=s+t-e.size,o=sB([sG(e,s,t-n),a3([n],a)]);i.push(o),s+=r}return 0===i.length?iF([],[0,t]):sU(sB(i),[i.length,t])}}),i_=n$({stft_:function(e,t,r,n,a=iD){return null==n&&(n=i$(t)),sK(aL(iO(e,t,r),a(t)),n)}}),iM=n$({cropAndResize_:function(e,t,r,n,a="bilinear",s=0){let i=nT(e,"image","cropAndResize"),o=nT(t,"boxes","cropAndResize","float32"),l=nT(r,"boxInd","cropAndResize","int32"),u=o.shape[0];return m(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),m(2===o.rank&&4===o.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),m(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),m(2===n.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),m(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),m("bilinear"===a||"nearest"===a,()=>`method must be bilinear or nearest, but was ${a}`),na.runKernel(eP,{image:i,boxes:o,boxInd:l},{method:a,extrapolationValue:s,cropSize:n})}}),iL=n$({flipLeftRight_:function(e){let t=nT(e,"image","flipLeftRight","float32");return m(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),na.runKernel(eQ,{image:t},{})}}),iz=n$({tile_:function(e,t){let r=nT(e,"x","tile","string_or_numeric");return m(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of reps ${t}.`),na.runKernel(ri,{x:r},{reps:t})}});e.s(["tile",0,iz],44587);let iP=n$({grayscaleToRGB_:function(e){let t=nT(e,"image","grayscaleToRGB"),r=t.rank-1,n=t.shape[r];m(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),m(1===n,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let a=Array(t.rank);return a.fill(1,0,r),a[r]=3,iz(t,a)}}),iB=n$({einsum_:function(e,...t){let r=t.map((e,t)=>nT(e,`tensors${t}`,"einsum"));return na.runKernel(eK,r,{equation:e})}}),iV=n$({expandDims_:function(e,t=0){let r=nT(e,"x","expandDims","string_or_numeric");return m(t<=r.rank,()=>"Axis must be <= rank of the tensor"),na.runKernel(eZ,{input:r},{dim:t})}});e.s(["expandDims",0,iV],82522);let iW=n$({rgbToGrayscale_:function(e){let t,r=nT(e,"image","RGBToGrayscale"),n=r.rank-1,a=r.shape[n];m(r.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${r.rank}.`),m(3===a,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${a}.`);let s=r.dtype,i=aR(r,"float32"),o=iE([.2989,.587,.114]);switch(r.rank){case 2:t=iB("ij,j->i",i,o);break;case 3:t=iB("ijk,k->ij",i,o);break;case 4:t=iB("ijkl,l->ijk",i,o);break;case 5:t=iB("ijklm,m->ijkl",i,o);break;case 6:t=iB("ijklmn,n->ijklm",i,o);break;default:throw Error("Not a valid tensor rank.")}return aR(t=iV(t,-1),s)}}),iU=n$({rotateWithOffset_:function(e,t,r=0,n=.5){let a=nT(e,"image","rotateWithOffset","float32");return m(4===a.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`),na.runKernel(rm,{image:a},{radians:t,fillValue:r,center:n})}});function iG(e,t,r,n,a,s){null==n&&(n=.5),null==a&&(a=-1/0),null==s&&(s=0);let i=e.shape[0];return r=Math.min(r,i),m(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),m(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),m(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),m(1===t.rank,()=>"scores must be a 1D tensor"),m(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),m(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:r,iouThreshold:n,scoreThreshold:a,softNmsSigma:s}}let iq=n$({nonMaxSuppression_:function(e,t,r,n=.5,a=-1/0){let s=nT(e,"boxes","nonMaxSuppression","float32"),i=nT(t,"scores","nonMaxSuppression","float32"),o=iG(s,i,r,n,a);r=o.maxOutputSize;let l={maxOutputSize:r,iouThreshold:n=o.iouThreshold,scoreThreshold:a=o.scoreThreshold};return na.runKernel(tw,{boxes:s,scores:i},l)}});function iH(e,t){return e>t?1:e<t?-1:0}function ij(e,t,r,n,a){return iZ(e,t,r,n,a,0)}function iK(e,t,r,n,a,s){return iZ(e,t,r,n,a,0,!1,s,!0)}function iX(e,t,r,n,a,s){return iZ(e,t,r,n,a,s,!0)}function iZ(e,t,r,n,a,s,i=!1,o=!1,l=!1){let u=[];for(let e=0;e<t.length;e++)t[e]>a&&u.push({score:t[e],boxIndex:e,suppressBeginIndex:0});u.sort(iY);let h=s>0?-.5/s:0,p=[],d=[];for(;p.length<r&&u.length>0;){let t=u.pop(),{score:r,boxIndex:s,suppressBeginIndex:i}=t;if(r<a)break;let o=!1;for(let r=p.length-1;r>=i;--r){let i=function(e,t,r){let n=e.subarray(4*t,4*t+4),a=e.subarray(4*r,4*r+4),s=Math.min(n[0],n[2]),i=Math.min(n[1],n[3]),o=Math.max(n[0],n[2]),l=Math.max(n[1],n[3]),u=Math.min(a[0],a[2]),h=Math.min(a[1],a[3]),p=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),c=(o-s)*(l-i),f=(p-u)*(d-h);if(c<=0||f<=0)return 0;let m=Math.max(Math.min(o,p)-Math.max(s,u),0)*Math.max(Math.min(l,d)-Math.max(i,h),0);return m/(c+f-m)}(e,s,p[r]);if(i>=n){o=!0;break}if(t.score=t.score*function(e,t,r){let n=Math.exp(t*r*r);return r<=e?n:0}(n,h,i),t.score<=a)break}t.suppressBeginIndex=p.length,!o&&(t.score===r?(p.push(s),d.push(t.score)):t.score>a&&function(e,t,r){let n=function(e,t,r){let n=0,a=e.length,s=0,i=!1;for(;n<a;){let o=r(t,e[s=n+(a-n>>>1)]);o>0?n=s+1:(a=s,i=!o)}return i?n:-n-1}(e,t,r||iH);e.splice(n<0?-(n+1):n,0,t)}(u,t,iY))}let c=p.length,f=r-c;o&&f>0&&(p.push(...Array(f).fill(0)),d.push(...Array(f).fill(0)));let m={selectedIndices:p};return i&&(m.selectedScores=d),l&&(m.validOutputs=c),m}function iY(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function iJ(e,t,r,n=.5,a=-1/0){let s=nT(e,"boxes","nonMaxSuppressionAsync"),i=nT(t,"scores","nonMaxSuppressionAsync"),o=iG(s,i,r,n,a);r=o.maxOutputSize,n=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),{selectedIndices:u}=ij(l[0],l[1],r,n,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),iE(u,"int32")}e.s(["nonMaxSuppressionV3Impl",()=>ij,"nonMaxSuppressionV4Impl",()=>iK,"nonMaxSuppressionV5Impl",()=>iX],67768);let iQ=n$({nonMaxSuppressionWithScore_:function(e,t,r,n=.5,a=-1/0,s=0){let i=nT(e,"boxes","nonMaxSuppression"),o=nT(t,"scores","nonMaxSuppression"),l=iG(i,o,r,n,a,s);r=l.maxOutputSize,n=l.iouThreshold,a=l.scoreThreshold;let u={maxOutputSize:r,iouThreshold:n,scoreThreshold:a,softNmsSigma:s=l.softNmsSigma},h=na.runKernel(tN,{boxes:i,scores:o},u);return{selectedIndices:h[0],selectedScores:h[1]}}});async function i0(e,t,r,n=.5,a=-1/0,s=0){let i=nT(e,"boxes","nonMaxSuppressionAsync"),o=nT(t,"scores","nonMaxSuppressionAsync"),l=iG(i,o,r,n,a,s);r=l.maxOutputSize,n=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),{selectedIndices:h,selectedScores:p}=iX(u[0],u[1],r,n,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:iE(h,"int32"),selectedScores:iE(p)}}let i1=n$({nonMaxSuppressionPadded_:function(e,t,r,n=.5,a=-1/0,s=!1){let i=nT(e,"boxes","nonMaxSuppression"),o=nT(t,"scores","nonMaxSuppression"),l=iG(i,o,r,n,a,null),u=l.maxOutputSize,h=l.iouThreshold,p=l.scoreThreshold,d=na.runKernel(tS,{boxes:i,scores:o},{maxOutputSize:u,iouThreshold:h,scoreThreshold:p,padToMaxOutputSize:s});return{selectedIndices:d[0],validOutputs:d[1]}}});async function i2(e,t,r,n=.5,a=-1/0,s=!1){let i=nT(e,"boxes","nonMaxSuppressionAsync"),o=nT(t,"scores","nonMaxSuppressionAsync"),l=iG(i,o,r,n,a,null),u=l.maxOutputSize,h=l.iouThreshold,p=l.scoreThreshold,[d,c]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=iK(d,c,u,h,p,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:iE(f,"int32"),validOutputs:aK(m,"int32")}}let i3=n$({resizeBilinear_:function(e,t,r=!1,n=!1){let a=nT(e,"images","resizeBilinear");m(3===a.rank||4===a.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`),m(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),m(!1===n||!1===r,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;3===a.rank&&(i=!0,s=sU(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l=na.runKernel(tP,o,{alignCorners:r,halfPixelCenters:n,size:t});return i?sU(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});e.s(["resizeBilinear",0,i3],41423);let i4=n$({resizeNearestNeighbor_:function(e,t,r=!1,n=!1){let a=nT(e,"images","resizeNearestNeighbor");m(3===a.rank||4===a.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`),m(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),m("float32"===a.dtype||"int32"===a.dtype,()=>"`images` must have `int32` or `float32` as dtype"),m(!1===n||!1===r,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;3===a.rank&&(i=!0,s=sU(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l=na.runKernel(tz,o,{alignCorners:r,halfPixelCenters:n,size:t});return i?sU(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});e.s(["resizeNearestNeighbor",0,i4],466);let i6=n$({bincount_:function(e,t,r){let n=nT(e,"x","bincount"),a=nT(t,"weights","bincount");return m("int32"===n.dtype,()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),m(r>=0,()=>`size must be non-negative, but got ${r}.`),m(a.size===n.size||0===a.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${a.shape}.`),na.runKernel(eS,{x:n,weights:a},{size:r})}}),i5=n$({lessEqual_:function(e,t){let r=nT(e,"a","lessEqual","string_or_numeric"),n=nT(t,"b","lessEqual","string_or_numeric");[r,n]=r5(r,n),st(r.shape,n.shape);let a={a:r,b:n};return na.runKernel(ts,a)}});e.s(["lessEqual",0,i5],85522);let i8=n$({greater_:function(e,t){let r=nT(e,"a","greater","string_or_numeric"),n=nT(t,"b","greater","string_or_numeric");[r,n]=r5(r,n),st(r.shape,n.shape);let a={a:r,b:n};return na.runKernel(e6,a)}});e.s(["greater",0,i8],60164);let i9=n$({round_:function(e){let t=nT(e,"x","round");return na.runKernel(tW,{x:t})}});e.s(["round",0,i9],53175);let i7=n$({broadcastTo_:function(e,t){let r=nT(e,"broadcastTo","x"),n=r.shape;if(Z(t),t.length<r.rank)throw Error(`broadcastTo(): shape.length=${t.length} < input.rank=${r.rank}.`);if(t.length>r.rank){let e=r.shape.slice();for(;e.length<t.length;)e.unshift(1);r=sU(r,e)}let a=r.shape,s=Array.from(t);for(let e=t.length-1;e>=0;e--)if(a[e]===t[e])s[e]=1;else if(1!==r.shape[e])throw Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);if(0===s.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length)return aD(r);let i={x:r};return na.runKernel(ri,i,{reps:s})}});e.s(["broadcastTo",0,i7],61376);let oe=n$({where_:function(e,t,r){let n=nT(t,"a","where"),a=nT(r,"b","where"),s=nT(e,"condition","where","bool"),i=st(st(s.shape,n.shape),a.shape),o=i7(s,i),l=i7(n,i),u=i7(a,i);return na.runKernel(tj,{condition:o,t:l,e:u})}});function ot(e,t,r=1,n="float32"){if(0===r)throw Error("Cannot have a step of zero");return na.runKernel(tF,{},{start:e,stop:t,step:r,dtype:n})}e.s(["where",0,oe],10493),e.s(["range",()=>ot],47710);let or=n$({threshold_:function(e,t="binary",r=!1,n=.5){let a,s,i,o,l=nT(e,"image","threshold"),u=l.shape[0]*l.shape[1],h=aL(iE([n]),255);if(m(3===l.rank,()=>`Error in threshold: image must be rank 3,but got rank ${l.rank}.`),m(3===l.shape[2]||1===l.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${l.shape[2]}.`),m("int32"===l.dtype||"float32"===l.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${l.dtype}.`),m("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===l.shape[2]){[a,s,i]=sq(l,[1,1,1],-1);let e=aL(a,.2989),t=aL(s,.587),r=aL(i,.114);o=aO(aO(e,t),r)}else o=e;return"otsu"===t&&(h=function(e,t){let r,n,a,s,i,o,l=iE([-1]),u=iE([0]),h=iE([0]);for(let p=0;p<e.size-1;p++){r=sG(e,0,p+1),n=sG(e,p+1),i=aM(im(r),t),o=aM(im(n),t),a=aM(im(aL(r,ot(0,r.size))),im(r));let d=a3(n.shape,r.size),c=aO(ot(0,n.size),d),f=a5(a,s=aM(im(aL(n,c)),im(n))),m=a5(a,s),g=aL(i,o),y=i8(h=aL(aL(g,f),m),u);u=oe(y,h,u),l=oe(y,iE([p]),l)}return l}(i6(aR(i9(o),"int32"),nD([]),256),u)),aR(aL(r?i5(o,h):i8(o,h),255),"int32")}}),on=n$({transform_:function(e,t,r="nearest",n="constant",a=0,s){let i=nT(e,"image","transform","float32"),o=nT(t,"transforms","transform","float32");return m(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),m(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),m(null==s||2===s.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`),na.runKernel(rl,{image:i,transforms:o},{interpolation:r,fillMode:n,fillValue:a,outputShape:s})}}),oa=n$({greaterEqual_:function(e,t){let r=nT(e,"a","greaterEqual","string_or_numeric"),n=nT(t,"b","greaterEqual","string_or_numeric");[r,n]=r5(r,n),st(r.shape,n.shape);let a={a:r,b:n};return na.runKernel(e5,a)}});e.s(["greaterEqual",0,oa],67781);let os=n$({less_:function(e,t){let r=nT(e,"a","less","string_or_numeric"),n=nT(t,"b","less","string_or_numeric");[r,n]=r5(r,n),st(r.shape,n.shape);let a={a:r,b:n};return na.runKernel(ta,a)}});e.s(["less",0,os],84812);let oi=n$({logicalAnd_:function(e,t){let r=nT(e,"a","logicalAnd","bool"),n=nT(t,"b","logicalAnd","bool");return st(r.shape,n.shape),na.runKernel(tl,{a:r,b:n})}});e.s(["logicalAnd",0,oi],87626);let oo=n$({minimum_:function(e,t){let r=nT(e,"a","minimum"),n=nT(t,"b","minimum");[r,n]=r5(r,n),"bool"===r.dtype&&(r=aR(r,"int32"),n=aR(n,"int32")),st(r.shape,n.shape);let a={a:r,b:n};return na.runKernel(tg,a)}});e.s(["minimum",0,oo],36467);let ol=n$({neg_:function(e){let t=nT(e,"x","neg");return na.runKernel("Neg",{x:t})}});e.s(["neg",0,ol],95528);let ou=n$({stack_:function(e,t=0){let r=nC(e,"tensors","stack","string_or_numeric");return m(r.length>=1,()=>"Pass at least one tensor to tf.stack"),r.length>0&&m(t<=r[0].rank,()=>"Axis must be <= rank of the tensor"),na.runKernel(tT,r,{axis:t})}});e.s(["stack",0,ou],42130);let oh=n$({unstack_:function(e,t=0){let r=nT(e,"x","unstack","string_or_numeric");return m(t>=-r.shape.length&&t<r.shape.length,()=>`Axis = ${t} is not in [-${r.shape.length}, ${r.shape.length})`),na.runKernel(rp,{value:r},{axis:t})}});e.s(["unstack",0,oh],33236);let op=n$({bandPart_:function(e,t,r){let n,a,s=nT(e,"a","bandPart");m(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);let i=s.shape,[o,l]=s.shape.slice(-2);"number"==typeof t?(m(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),m(t<=o,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`),n=nT(t<0?o:t,"numLower","bandPart")):(m("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),n=oe(os(t,0),o,oo(t,o))),"number"==typeof r?(m(r%1==0,()=>`bandPart(): numUpper must be an integer, got ${r}.`),m(r<=l,()=>`bandPart(): numUpper (${r}) must not be greater than the number of columns (${l}).`),a=nT(r<0?l:r,"numUpper","bandPart")):(m("int32"===r.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),a=oe(os(r,0),l,oo(r,l)));let u=a5(sU(ot(0,o,1,"int32"),[-1,1]),ot(0,l,1,"int32")),h=oi(i5(u,n),oa(u,ol(a))),p=sH([o,l],s.dtype);return sU(ou(oh(sU(s,[-1,o,l])).map(e=>oe(h,e,p))),i)}});function od(e,t){for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0}function oc(e,t,r){let n=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<n;o++)-1===r.indexOf(o)?a.push(e[s++]):a.push(t[i++]);return a}function of(e,t){let r=[],n=e.length;for(let a=0;a<n;a++)-1===t.indexOf(a)&&r.push(e[a]);return[r,t.map(t=>e[t])]}function om(e,t){return oc(e,t.map(e=>1),t)}function og(e,t,r){m(od(t,r),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${r} input.`)}function oy(e,t){if(od(e,t))return null;let r=[];for(let n=0;n<t;++n)-1===e.indexOf(n)&&r.push(n);return e.forEach(e=>r.push(e)),r}function ob(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function ox(e,t){let r=[];for(let n=t-e;n<t;++n)r.push(n);return r}e.s(["assertAxesAreInnerMostDims",()=>og,"axesAreInnerMostDims",()=>od,"combineLocations",()=>oc,"computeOutAndReduceShapes",()=>of,"expandShapeToKeepDim",()=>om,"getAxesPermutation",()=>oy,"getInnerMostAxes",()=>ox,"getUndoAxesPermutation",()=>ob],15401);let ov=n$({max_:function(e,t=null,r=!1){let n=nT(e,"x","max");return na.runKernel("Max",{x:n},{reductionIndices:t,keepDims:r})}});e.s(["max",0,ov],94829);let ow=n$({min_:function(e,t=null,r=!1){let n=nT(e,"x","min");return na.runKernel("Min",{x:n},{axis:t,keepDims:r})}});e.s(["min",0,ow],40296);let oS=n$({norm_:function(e,t="euclidean",r=null,n=!1){let a=function e(t,r,n=null){if(0===t.rank)return a9(t);if(1!==t.rank&&null===n)return e(sU(t,[-1]),r,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===r)return im(a9(t),n);if(r===1/0)return ov(a9(t),n);if(r===-1/0)return ow(a9(t),n);if("euclidean"===r||2===r)return az(im(a6(a9(t),aK(2,"int32")),n));throw Error(`Error in norm: invalid ord value: ${r}`)}if(Array.isArray(n)&&2===n.length){if(1===r)return ov(im(a9(t),n[0]),n[1]-1);if(r===1/0)return ov(im(a9(t),n[1]),n[0]);if(r===-1/0)return ow(im(a9(t),n[1]),n[0]);if("fro"===r||"euclidean"===r)return az(im(aP(t),n));throw Error(`Error in norm: invalid ord value: ${r}`)}throw Error(`Error in norm: invalid axis: ${n}`)}(e=nT(e,"x","norm"),t,r),s=a.shape;if(n){let t=$(r,e.shape);s=om(a.shape,t)}return sU(a,s)}});e.s(["norm",0,oS],99269);let oN=n$({squeeze_:function(e,t){let r=nT(e,"x","squeeze","string_or_numeric");return sU(r,A(r.shape,t).newShape)}});e.s(["squeeze",0,oN],3975);let ok=n$({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,m(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let r=e[0].shape[0];for(let t=1;t<e.length;++t)m(e[t].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${r})`)}else t=!0,e=sq(e,e.shape[0],0).map(e=>oN(e,[0]));m(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let r=[],n=e;for(let t=0;t<e.length;++t)r.push(na.tidy(()=>{let e=n[t];if(t>0)for(let n=0;n<t;++n){let t=aL(im(aL(r[n],e)),r[n]);e=a5(e,t)}return aM(e,oS(e,"euclidean"))}));return t?ou(r,0):r}}),oI=n$({eye_:function(e,t,r,n="float32"){null==t&&(t=e);let a=aA([e,t],n),s=e<=t?e:t;for(let e=0;e<s;++e)a.set(1,e,e);let i=sU(a.toTensor(),[e,t]);if(null==r)return i;if(1===r.length)return iz(iV(i,0),[r[0],1,1]);if(2===r.length)return iz(iV(iV(i,0),0),[r[0],r[1],1,1]);if(3===r.length)return iz(iV(iV(iV(i,0),0),0),[r[0],r[1],r[2],1,1]);throw Error(`eye() currently supports only 1D and 2D batchShapes, but received ${r.length}D.`)}});e.s(["eye",0,oI],15466);let oT=n$({transpose_:function(e,t,r){let n=nT(e,"x","transpose");if(null==t&&(t=n.shape.map((e,t)=>t).reverse()),m(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(e=>{m(e>=0&&e<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${t}`)}),n.rank<=1)return n.clone();let a={perm:t};return"complex64"===n.dtype?nU(()=>{let e=sW(n),t=sV(n);return e=na.runKernel(ru,{x:e},a),t=na.runKernel(ru,{x:t},a),r&&(t=ol(t)),nA(e,t)}):na.runKernel(ru,{x:n},a)}});function oC(e,t=!1){return na.tidy(()=>{m(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let r=e.shape[0],n=e.shape[1],a=oI(r),s=aD(e),i=iF([[1]],[1,1]),o=aD(i),l=r>=n?n:r;for(let e=0;e<l;++e){let t=s,l=o,u=a;[o,s,a]=na.tidy(()=>{let t=sG(s,[e,e],[r-e,1]),l=oS(t),u=sG(s,[e,e],[1,1]),h=oe(i8(u,0),iF([[-1]]),iF([[1]])),p=a5(u,aL(h,l)),d=aM(t,p);o=1===d.shape[0]?aD(i):sB([i,sG(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);let c=ol(aM(iI(h,p),l)),f=sG(s,[e,0],[r-e,n]),m=aL(c,o),g=oT(o);if(0===e)s=a5(f,iI(m,iI(g,f)));else{let t=a5(f,iI(m,iI(g,f)));s=sB([sG(s,[0,0],[e,n]),t],0)}let y=oT(m),b=sG(a,[0,e],[r,a.shape[1]-e]);if(0===e)a=a5(b,iI(iI(b,o),y));else{let t=a5(b,iI(iI(b,o),y));a=sB([sG(a,[0,0],[r,e]),t],1)}return[o,s,a]}),nG([t,l,u])}return!t&&r>n&&(a=sG(a,[0,0],[r,n]),s=sG(s,[0,0],[n,n])),[a,s]})}e.s(["transpose",0,oT],90049);let oE=n$({qr_:function(e,t=!1){if(m(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return oC(e,t);{let r=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),n=oh(sU(e,[r,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];return n.forEach(e=>{let[r,n]=oC(e,t);a.push(r),s.push(n)}),[sU(ou(a,0),e.shape),sU(ou(s,0),e.shape)]}}});(ni=ny||(ny={}))[ni.NONE=0]="NONE",ni[ni.MEAN=1]="MEAN",ni[ni.SUM=2]="SUM",ni[ni.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",e.s(["Reduction",()=>ny],99963);let o$=n$({mean_:function(e,t=null,r=!1){let n=nT(e,"x","mean");return na.runKernel(tm,{x:n},{axis:t,keepDims:r})}});e.s(["mean",0,o$],41807);let oA=n$({notEqual_:function(e,t){let r=nT(e,"a","notEqual","string_or_numeric"),n=nT(t,"b","notEqual","string_or_numeric");[r,n]=r5(r,n),st(r.shape,n.shape);let a={a:r,b:n};return na.runKernel(tv,a)}});function oR(e,t="float32"){if(Z(e),"complex64"===t)return nA(oR(e,"float32"),sH(e,"float32"));let r=j(b(e),t);return na.makeTensor(r,e,t)}e.s(["notEqual",0,oA],18355),e.s(["ones",()=>oR],99451);let oD=n$({computeWeightedLoss_:function(e,t,r=ny.SUM_BY_NONZERO_WEIGHTS){let n=nT(e,"losses","computeWeightedLoss"),a=null;null!=t&&(a=nT(t,"weights","computeWeightedLoss"));let s=null==a?n:aL(n,a);if(r===ny.NONE)return s;if(r===ny.SUM)return im(s);if(r===ny.MEAN)if(null==a)return o$(s);else{let e=n.size/a.size,t=aM(im(s),im(a));return e>1?aM(t,aK(e)):t}if(r===ny.SUM_BY_NONZERO_WEIGHTS)if(null==a)return aM(im(s),aK(n.size));else{let e=aR(im(oA(aL(a,oR(n.shape)),aK(0))),"float32");return aM(im(s),e)}throw Error(`Unknown reduction: ${r}`)}}),oF=n$({absoluteDifference_:function(e,t,r,n=ny.SUM_BY_NONZERO_WEIGHTS){let a=nT(e,"labels","absoluteDifference"),s=nT(t,"predictions","absoluteDifference"),i=null;return null!=r&&(i=nT(r,"weights","absoluteDifference")),g(a.shape,s.shape,"Error in absoluteDifference: "),oD(a9(a5(a,s)),i,n)}}),oO=n$({cosineDistance_:function(e,t,r,n,a=ny.SUM_BY_NONZERO_WEIGHTS){let s=nT(e,"labels","cosineDistance"),i=nT(t,"predictions","cosineDistance"),o=null;return null!=n&&(o=nT(n,"weights","cosineDistance")),g(s.shape,i.shape,"Error in cosineDistance: "),oD(a5(aK(1),im(aL(s,i),r,!0)),o,a)}}),o_=n$({hingeLoss_:function(e,t,r,n=ny.SUM_BY_NONZERO_WEIGHTS){let a=nT(e,"labels","hingeLoss"),s=nT(t,"predictions","hingeLoss"),i=null;null!=r&&(i=nT(r,"weights","hingeLoss")),g(a.shape,s.shape,"Error in hingeLoss: ");let o=aK(1);return a=a5(aL(aK(2),a),o),oD(ih(a5(o,aL(a,s))),i,n)}}),oM=n$({huberLoss_:function(e,t,r,n=1,a=ny.SUM_BY_NONZERO_WEIGHTS){let s=nT(e,"labels","huberLoss"),i=nT(t,"predictions","huberLoss"),o=null;null!=r&&(o=nT(r,"weights","huberLoss")),g(s.shape,i.shape,"Error in huberLoss: ");let l=aK(n),u=a9(a5(i,s)),h=oo(u,l),p=a5(u,h);return oD(aO(aL(aK(.5),aP(h)),aL(l,p)),o,a)}}),oL=n$({log_:function(e){let t=nT(e,"x","log","float32");return na.runKernel("Log",{x:t})}});e.s(["log",0,oL],98317);let oz=n$({logLoss_:function(e,t,r,n=1e-7,a=ny.SUM_BY_NONZERO_WEIGHTS){let s=nT(e,"labels","logLoss"),i=nT(t,"predictions","logLoss"),o=null;null!=r&&(o=nT(r,"weights","logLoss")),g(s.shape,i.shape,"Error in logLoss: ");let l=aK(1),u=aK(n),h=ol(aL(s,oL(aO(i,u)))),p=aL(a5(l,s),oL(aO(a5(l,i),u)));return oD(a5(h,p),o,a)}}),oP=n$({squaredDifference_:function(e,t){let r=nT(e,"a","squaredDifference"),n=nT(t,"b","squaredDifference");[r,n]=r5(r,n),st(r.shape,n.shape);let a={a:r,b:n};return na.runKernel(t7,a,{})}});e.s(["squaredDifference",0,oP],70804);let oB=n$({meanSquaredError_:function(e,t,r,n=ny.SUM_BY_NONZERO_WEIGHTS){let a=nT(e,"labels","meanSquaredError"),s=nT(t,"predictions","meanSquaredError"),i=null;return null!=r&&(i=nT(r,"weights","meanSquaredError")),g(a.shape,s.shape,"Error in meanSquaredError: "),oD(oP(a,s),i,n)}}),oV=n$({exp_:function(e){let t=nT(e,"x","exp");return na.runKernel("Exp",{x:t})}});e.s(["exp",0,oV],7970);let oW=n$({log1p_:function(e){let t=nT(e,"x","log1p");return na.runKernel(to,{x:t})}});e.s(["log1p",0,oW],91075);let oU=n$({sigmoidCrossEntropy_:function(e,t,r,n=0,a=ny.SUM_BY_NONZERO_WEIGHTS){let s,i,o,l,u,h=nT(e,"multiClassLabels","sigmoidCrossEntropy"),p=nT(t,"logits","sigmoidCrossEntropy"),d=null;if(null!=r&&(d=nT(r,"weights","sigmoidCrossEntropy")),g(h.shape,p.shape,"Error in sigmoidCrossEntropy: "),n>0){let e=aK(n),t=aK(1),r=aK(.5);h=aO(aL(h,a5(t,e)),aL(r,e))}return oD((s=nT(h,"labels","sigmoidCrossEntropyWithLogits"),i=nT(p,"logits","sigmoidCrossEntropyWithLogits"),g(s.shape,i.shape,"Error in sigmoidCrossEntropyWithLogits: "),o=ih(i),l=aL(i,s),u=oW(oV(ol(a9(i)))),aO(a5(o,l),u)),d,a)}}),oG=n$({logSumExp_:function(e,t=null,r=!1){let n=nT(e,"x","logSumExp"),a=$(t,n.shape),s=ov(n,a,!0),i=oL(im(oV(a5(n,s)),a)),o=aO(sU(s,i.shape),i);if(r){let e=om(o.shape,a);return sU(o,e)}return o}});e.s(["logSumExp",0,oG],11585);let oq=n$({softmaxCrossEntropy_:function(e,t,r,n=0,a=ny.SUM_BY_NONZERO_WEIGHTS){let s=nT(e,"onehotLabels","softmaxCrossEntropy"),i=nT(t,"logits","softmaxCrossEntropy"),o=null;if(null!=r&&(o=nT(r,"weights","softmaxCrossEntropy")),g(s.shape,i.shape,"Error in softmaxCrossEntropy: "),n>0){let e=aK(n),t=aK(1),r=aK(s.shape[1]);s=aO(aL(s,a5(t,e)),aM(e,r))}return oD(function(e,t,r=-1){if(-1===r&&(r=t.rank-1),r!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${r}`);return aH((e,t,n)=>{let a=oG(t,[r],!0),s=a5(aR(t,"float32"),a);return n([e,s]),{value:im(ol(aL(s,e)),[r]),gradFunc:(e,t)=>{let[n,a]=t,s=om(e.shape,[r]);return[aL(sU(e,s),a5(aR(n,"float32"),oV(a))),aL(sU(e,s),a5(oV(a),aR(n,"float32")))]}}})(e,t)}(s,i),o,a)}}),oH=n$({sparseFillEmptyRows_:function(e,t,r,n){let a=nT(e,"indices","sparseFillEmptyRows","int32"),s=nT(t,"values","sparseFillEmptyRows"),i=nT(r,"denseShape","sparseFillEmptyRows","int32"),o=nT(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw Error(`Indices should be Tensor2D but received shape
        ${a.shape}`);if(1!==s.rank)throw Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw Error(`Default value should be a scalar but received shape ${o.shape}`);let l=na.runKernel(t4,{indices:a,values:s,denseShape:i,defaultValue:o});return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}}),oj=n$({sparseReshape_:function(e,t,r){let n=nT(e,"inputIndices","sparseReshape","int32"),a=nT(t,"inputShape","sparseReshape","int32"),s=nT(r,"newShape","sparseReshape","int32");if(2!==n.rank)throw Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(1!==a.rank)throw Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i=na.runKernel(t6,{inputIndices:n,inputShape:a,newShape:s});return{outputIndices:i[0],outputShape:i[1]}}}),oK=n$({sparseSegmentMean_:function(e,t,r){let n=nT(e,"data","sparseSegmentMean"),a=nT(t,"indices","sparseSegmentMean","int32"),s=nT(r,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw Error(`Indices should be Tensor1D but received shape
          ${a.shape}`);if(1!==s.rank)throw Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);return na.runKernel(t5,{data:n,indices:a,segmentIds:s})}}),oX=n$({sparseSegmentSum_:function(e,t,r){let n=nT(e,"data","sparseSegmentSum"),a=nT(t,"indices","sparseSegmentSum","int32"),s=nT(r,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw Error(`Indices should be Tensor1D but received shape
         ${a.shape}`);if(1!==s.rank)throw Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);return na.runKernel(t8,{data:n,indices:a,segmentIds:s})}}),oZ=n$({stringNGrams_:function(e,t,r,n,a,s,i,o){let l=nT(e,"data","stringNGrams","string");if("string"!==l.dtype)throw Error("Data must be of datatype string");if(1!==l.shape.length)throw Error(`Data must be a vector, saw: ${l.shape}`);let u=nT(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw Error("Data splits must be of datatype int32");let h=na.runKernel(rr,{data:l,dataSplits:u},{separator:r,nGramWidths:n,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o});return{nGrams:h[0],nGramsSplits:h[1]}}}),oY=n$({stringSplit_:function(e,t,r=!0){let n=nT(e,"input","stringSplit","string"),a=nT(t,"delimiter","stringSplit","string");if(1!==n.rank)throw Error(`Input should be Tensor1D but received shape ${n.shape}`);if(0!==a.rank)throw Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s=na.runKernel(rn,{input:n,delimiter:a},{skipEmpty:r});return{indices:s[0],values:s[1],shape:s[2]}}}),oJ=n$({stringToHashBucketFast_:function(e,t){let r=nT(e,"input","stringToHashBucketFast","string");if(t<=0)throw Error("Number of buckets must be at least 1");return na.runKernel(ra,{input:r},{numBuckets:t})}}),oQ=n$({staticRegexReplace_:function(e,t,r,n=!0){let a=nT(e,"input","staticRegexReplace","string");return na.runKernel(re,{x:a},{pattern:t,rewrite:r,replaceGlobal:n})}}),o0={fft:sj,ifft:sX,rfft:sK,irfft:sY},o1={hammingWindow:iR,hannWindow:iD,frame:iO,stft:i_},o2={flipLeftRight:iL,grayscaleToRGB:iP,resizeNearestNeighbor:i4,resizeBilinear:i3,rgbToGrayscale:iW,rotateWithOffset:iU,cropAndResize:iM,nonMaxSuppression:iq,nonMaxSuppressionAsync:iJ,nonMaxSuppressionWithScore:iQ,nonMaxSuppressionWithScoreAsync:i0,nonMaxSuppressionPadded:i1,nonMaxSuppressionPaddedAsync:i2,threshold:or,transform:on},o3={bandPart:op,gramSchmidt:ok,qr:oE},o4={absoluteDifference:oF,computeWeightedLoss:oD,cosineDistance:oO,hingeLoss:o_,huberLoss:oM,logLoss:oz,meanSquaredError:oB,sigmoidCrossEntropy:oU,softmaxCrossEntropy:oq},o6={sparseFillEmptyRows:oH,sparseReshape:oj,sparseSegmentMean:oK,sparseSegmentSum:oX},o5={stringNGrams:oZ,stringSplit:oY,stringToHashBucketFast:oJ,staticRegexReplace:oQ};e.s(["image",()=>o2,"linalg",()=>o3,"losses",()=>o4,"signal",()=>o1,"sparse",()=>o6,"spectral",()=>o0,"string",()=>o5],31445),e.i(31445);let o8=n$({acos_:function(e){let t=nT(e,"x","acos");return na.runKernel(el,{x:t})}});e.s(["acos",0,o8],89684);let o9=n$({acosh_:function(e){let t=nT(e,"x","acosh");return na.runKernel(eu,{x:t})}});e.s(["acosh",0,o9],74060);let o7=n$({addN_:function(e){m(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),m(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((e,t)=>nT(e,`tensors${t}`,"addN")),r=t[0];return t.forEach(e=>{if(e.dtype!==r.dtype)throw Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(e=>{if(!w(e.shape,r.shape))throw Error("All tensors passed to tf.addN() must have the same shape")}),na.runKernel(eh,t)}}),le=n$({all_:function(e,t=null,r=!1){let n=nT(e,"x","all","bool");return na.runKernel("All",{x:n},{axis:t,keepDims:r})}});e.s(["all",0,le],29451);let lt=n$({any_:function(e,t=null,r=!1){let n=nT(e,"x","any","bool");return na.runKernel("Any",{x:n},{axis:t,keepDims:r})}});e.s(["any",0,lt],22108);let lr=n$({argMax_:function(e,t=0){let r=nT(e,"x","argMax");return na.runKernel(ep,{x:r},{axis:t})}});e.s(["argMax",0,lr],195);let ln=n$({argMin_:function(e,t=0){let r=nT(e,"x","argMin");return na.runKernel(ed,{x:r},{axis:t})}});e.s(["argMin",0,ln],36502);let la=n$({asin_:function(e){let t=nT(e,"x","asin");return na.runKernel(ec,{x:t})}});e.s(["asin",0,la],91013);let ls=n$({asinh_:function(e){let t=nT(e,"x","asinh");return na.runKernel(ef,{x:t})}});e.s(["asinh",0,ls],97662);let li=n$({atan_:function(e){let t=nT(e,"x","atan");return na.runKernel(em,{x:t})}});e.s(["atan",0,li],91288);let lo=n$({atan2_:function(e,t){let r=nT(e,"a","atan2"),n=nT(t,"b","atan2");[r,n]=r5(r,n);let a={a:r,b:n};return na.runKernel(ey,a)}});e.s(["atan2",0,lo],20961);let ll=n$({atanh_:function(e){let t=nT(e,"x","atanh");return na.runKernel(eg,{x:t})}});e.s(["atanh",0,ll],74984);let lu=n$({avgPool_:function(e,t,r,n,a){let s=nT(e,"x","avgPool","float32");m(s7(r,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${r} and dilations '1'`);let i=s,o=!1;3===s.rank&&(o=!0,i=sU(s,[1,s.shape[0],s.shape[1],s.shape[2]])),m(4===i.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),ir("avgPool",n,a);let l={x:i},u=na.runKernel(eb,l,{filterSize:t,strides:r,pad:n,dimRoundingMode:a});return(u=aR(u,s.dtype),o)?sU(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});e.s(["avgPool",0,lu],15683);let lh=n$({avgPool3d_:function(e,t,r,n,a,s="NDHWC"){let i=nT(e,"x","avgPool3d","float32"),o=i,l=!1;4===i.rank&&(l=!0,o=sU(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),m(5===o.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),m("NDHWC"===s,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),m("number"==typeof r&&r>0||Array.isArray(r)&&r[0]>0&&r[1]>0&&r[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${r}'`),ir("avgPool3d",n,a);let u={x:o},h=na.runKernel(ex,u,{filterSize:t,strides:r,pad:n,dimRoundingMode:a,dataFormat:s});return(h=aR(h,o.dtype),l)?sU(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});e.s(["avgPool3d",0,lh],90881);let lp=n$({tanh_:function(e){let t=nT(e,"x","tanh","float32");return na.runKernel(rs,{x:t})}});e.s(["tanh",0,lp],61197);let ld=n$({basicLSTMCell_:function(e,t,r,n,a,s){let i=nT(e,"forgetBias","basicLSTMCell"),o=nT(t,"lstmKernel","basicLSTMCell"),l=nT(r,"lstmBias","basicLSTMCell"),u=nT(n,"data","basicLSTMCell"),h=nT(a,"c","basicLSTMCell"),p=aO(iI(sB([u,nT(s,"h","basicLSTMCell")],1),o),l),d=p.shape[0],c=p.shape[1]/4,f=[d,c],m=sG(p,[0,0],f),g=sG(p,[0,c],f),y=sG(p,[0,2*c],f),b=sG(p,[0,3*c],f),x=aO(aL(id(m),lp(g)),aL(h,id(aO(i,y)))),v=aL(lp(x),id(b));return[x,v]}}),lc=n$({batchToSpaceND_:function(e,t,r){let n=nT(e,"x","batchToSpaceND"),a=t.reduce((e,t)=>e*t);return m(n.rank>=1+t.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${t.length}`),m(r.length===t.length,()=>`crops.length is ${r.length} but should be equal to blockShape.length  ${t.length}`),m(n.shape[0]%a==0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`),na.runKernel(ew,{x:n},{blockShape:t,crops:r})}});e.s(["batchToSpaceND",0,lc],75067);let lf=n$({batchNorm_:function(e,t,r,n,a,s){let i,o;null==s&&(s=.001);let l=nT(e,"x","batchNorm"),u=nT(t,"mean","batchNorm"),h=nT(r,"variance","batchNorm");null!=a&&(i=nT(a,"scale","batchNorm")),null!=n&&(o=nT(n,"offset","batchNorm")),m(u.rank===h.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),m(null==o||u.rank===o.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),m(null==i||u.rank===i.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let p={x:0===l.rank||1===l.rank?sU(l,[1,1,1,l.size]):2===l.rank?sU(l,[1,1,l.shape[0],l.shape[1]]):3===l.rank?sU(l,[1,l.shape[0],l.shape[1],l.shape[2]]):l,scale:i,offset:o,mean:u,variance:h},d={varianceEpsilon:s};return sU(na.runKernel(e2,p,d),l.shape)}});e.s(["batchNorm",0,lf],40453);let lm=n$({batchNorm2d_:function(e,t,r,n,a,s){let i,o,l=nT(e,"x","batchNorm"),u=nT(t,"mean","batchNorm"),h=nT(r,"variance","batchNorm");return null!=a&&(i=nT(a,"scale","batchNorm")),null!=n&&(o=nT(n,"offset","batchNorm")),m(2===l.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`),m(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`),m(2===h.rank||1===h.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${h.rank}.`),null!=i&&m(2===i.rank||1===i.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${i.rank}.`),null!=o&&m(2===o.rank||1===o.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${o.rank}.`),lf(l,u,h,o,i,s)}});e.s(["batchNorm2d",0,lm],90632);let lg=n$({batchNorm3d_:function(e,t,r,n,a,s){let i,o,l=nT(e,"x","batchNorm"),u=nT(t,"mean","batchNorm"),h=nT(r,"variance","batchNorm");return null!=a&&(i=nT(a,"scale","batchNorm")),null!=n&&(o=nT(n,"offset","batchNorm")),m(3===l.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`),m(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`),m(3===h.rank||1===h.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${h.rank}.`),null!=i&&m(3===i.rank||1===i.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${i.rank}.`),null!=o&&m(3===o.rank||1===o.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${o.rank}.`),lf(l,u,h,o,i,s)}});e.s(["batchNorm3d",0,lg],12785);let ly=n$({batchNorm4d_:function(e,t,r,n,a,s){let i,o,l=nT(e,"x","batchNorm"),u=nT(t,"mean","batchNorm"),h=nT(r,"variance","batchNorm");return null!=a&&(i=nT(a,"scale","batchNorm")),null!=n&&(o=nT(n,"offset","batchNorm")),m(4===l.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`),m(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`),m(4===h.rank||1===h.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${h.rank}.`),null!=i&&m(4===i.rank||1===i.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${i.rank}.`),null!=o&&m(4===o.rank||1===o.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${o.rank}.`),lf(l,u,h,o,i,s)}});e.s(["batchNorm4d",0,ly],34414);let lb=n$({bitwiseAnd_:function(e,t){let r=nT(e,"x","bitwiseAnd"),n=nT(t,"y","bitwiseAnd");if(!w(r.shape,n.shape))throw Error(`BitwiseAnd: Tensors must have the same shape. x: ${r.shape}, y: ${n.shape}`);if("int32"!==r.dtype||"int32"!==n.dtype)throw Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${r.dtype} and type of y: ${n.dtype}`);return na.runKernel(eN,{a:r,b:n})}}),lx=n$({broadcastArgs_:function(e,t){let r=nT(e,"s0","broadcastArgs","int32"),n=nT(t,"s1","broadcastArgs","int32");if(1!==r.rank)throw Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${r.rank}`);if(1!==n.rank)throw Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);return na.runKernel(ek,{s0:r,s1:n})}}),lv=n$({ceil_:function(e){let t=nT(e,"x","ceil","float32");return na.runKernel(eT,{x:t})}});e.s(["ceil",0,lv],29903);let lw=n$({clipByValue_:function(e,t,r){let n=nT(e,"x","clipByValue");return(m(t<=r,()=>`Error in clip: min (${t}) must be less than or equal to max (${r}).`),t===r)?a3(n.shape,t,n.dtype):na.runKernel(eC,{x:n},{clipValueMin:t,clipValueMax:r})}});e.s(["clipByValue",0,lw],36889);let lS=n$({concat1d_:function(e){return sB(e,0)}});e.s(["concat1d",0,lS],42088);let lN=n$({concat2d_:function(e,t){return sB(e,t)}});e.s(["concat2d",0,lN],52064);let lk=n$({concat3d_:function(e,t){return sB(e,t)}});e.s(["concat3d",0,lk],28489);let lI=n$({concat4d_:function(e,t){return sB(e,t)}});e.s(["concat4d",0,lI],10423);let lT=n$({conv1d_:function(e,t,r,n,a="NWC",s=1,i){let o=nT(e,"x","conv1d"),l=nT(t,"filter","conv1d"),u=o,h=!1;2===o.rank&&(h=!0,u=sU(o,[1,o.shape[0],o.shape[1]])),m(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),m(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),ir("conv1d",n,i),m(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),m(s7(r,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${r} and dilation '${s}'`),m(ie(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),m(ie(r),()=>"Error in conv1D: Stride should be larger than 0."),m("NWC"===a,()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`);let p=sU(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=ia(sU(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p,[1,r],n,"NHWC",[1,s],i);return h?sU(d,[d.shape[2],d.shape[3]]):sU(d,[d.shape[0],d.shape[2],d.shape[3]])}});e.s(["conv1d",0,lT],18293);let lC=n$({conv2dTranspose_:function(e,t,r,n,a,s){return ii(r,nT(e,"x","conv2dTranspose"),nT(t,"filter","conv2dTranspose"),n,a,"NHWC",s)}});e.s(["conv2dTranspose",0,lC],87286);let lE=n$({conv3d_:function(e,t,r,n,a="NDHWC",s=[1,1,1]){let i=nT(e,"x","conv3d"),o=nT(t,"filter","conv3d"),l=i,u=!1;4===i.rank&&(u=!0,l=sU(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),m(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),m(5===o.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),m(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),m(s7(r,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${r} and dilations '${s}'`),m("NDHWC"===a,()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`),m(ie(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),m(ie(r),()=>"Error in conv3D: Strides should be larger than 0.");let h={x:l,filter:o},p=na.runKernel(eO,h,{strides:r,pad:n,dataFormat:a,dilations:s});return u?sU(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}});e.s(["conv3d",0,lE],73271);let l$=n$({conv3DBackpropInput_:function(e,t,r,n,a){m(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;4===t.rank&&(o=!0,i=sU(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];m(5===s.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),m(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),m(5===r.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${r.rank}`),m(l===r.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${r.shape[3]}.`),m(u===r.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${r.shape[4]}.`);let h={dy:i,filter:r},p={pad:a,strides:n,inputShape:s},d=na.runKernel(e_,h,p);return o?sU(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});e.s(["conv3DBackpropInput",0,l$],22525);let lA=n$({conv3dTranspose_:function(e,t,r,n,a){return l$(r,nT(e,"x","conv3dTranspose"),nT(t,"filter","conv3dTranspose"),n,a)}});e.s(["conv3dTranspose",0,lA],98378);let lR=n$({cos_:function(e){let t=nT(e,"x","cos","float32");return na.runKernel("Cos",{x:t})}});e.s(["cos",0,lR],84296);let lD=n$({cosh_:function(e){let t=nT(e,"x","cosh","float32");return na.runKernel(eM,{x:t})}});e.s(["cosh",0,lD],33292);let lF=n$({cumprod_:function(e,t=0,r=!1,n=!1){let a=nT(e,"x","cumprod");return na.runKernel(eL,{x:a},{axis:t,exclusive:r,reverse:n})}});e.s(["cumprod",0,lF],66506);let lO=n$({cumsum_:function(e,t=0,r=!1,n=!1){let a=nT(e,"x","cumsum");return na.runKernel(ez,{x:a},{axis:t,exclusive:r,reverse:n})}});e.s(["cumsum",0,lO],60949);let l_=n$({denseBincount_:function(e,t,r,n=!1){let a=nT(e,"x","denseBincount"),s=nT(t,"weights","denseBincount");return m("int32"===a.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`),m(a.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`),m(r>=0,()=>`size must be non-negative, but got ${r}.`),m(s.size===a.size||0===s.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`),na.runKernel(eB,{x:a,weights:s},{size:r,binaryOutput:n})}});e.s(["denseBincount",0,l_],37262);let lM=n$({depthToSpace_:function(e,t,r="NHWC"){let n=nT(e,"x","depthToSpace","float32"),a="NHWC"===r?n.shape[1]:n.shape[2],s="NHWC"===r?n.shape[2]:n.shape[3],i="NHWC"===r?n.shape[3]:n.shape[1];return m(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),m(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t}  for depthToSpace with input shape
    ${n.shape}`),m(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${n.shape}`),m(i%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${n.shape}`),na.runKernel(eV,{x:n},{blockSize:t,dataFormat:r})}});e.s(["depthToSpace",0,lM],80201);let lL=n$({diag_:function(e){let t=nT(e,"x","diag");return na.runKernel(eq,{x:t})}}),lz=n$({dilation2d_:function(e,t,r,n,a=[1,1],s="NHWC"){let i=nT(e,"x","dilation2d"),o=nT(t,"filter","dilation2d");m(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),m(3===o.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),m("NHWC"===s,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,u=!1;3===i.rank&&(l=sU(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),m(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let h={x:l,filter:o},p=na.runKernel(eH,h,{strides:r,pad:n,dilations:a});return u?sU(p,[p.shape[1],p.shape[2],p.shape[3]]):p}});e.s(["dilation2d",0,lz],87338);let lP=n$({equal_:function(e,t){let r=nT(e,"a","equal","string_or_numeric"),n=nT(t,"b","equal","string_or_numeric");[r,n]=r5(r,n),st(r.shape,n.shape);let a={a:r,b:n};return na.runKernel(eX,a)}});e.s(["equal",0,lP],69578);let lB=n$({divNoNan_:function(e,t){let r=nT(e,"a","div"),n=nT(t,"b","div");[r,n]=r5(r,n);let a=aM(r,n),s=aB(a);return oe(lP(n,s),s,a)}});e.s(["divNoNan",0,lB],83218);let lV=n$({dot_:function(e,t){let r=nT(e,"t1","dot"),n=nT(t,"t2","dot");m((1===r.rank||2===r.rank)&&(1===n.rank||2===n.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${r.rank} and ${n.rank}.`);let a=1===r.rank?r.size:r.shape[1],s=1===n.rank?n.size:n.shape[0];if(m(a===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`),1===r.rank&&1===n.rank){let e=iI(sU(r,[1,-1]),sU(n,[-1,1]));return sU(e,[])}if(1===r.rank&&2===n.rank){let e=iI(sU(r,[1,-1]),sU(n,[n.shape[0],n.shape[1]]));return sU(e,[e.size])}if(2!==r.rank||1!==n.rank)return iI(r,sU(n,[n.shape[0],n.shape[1]]));{let e=iI(r,sU(n,[-1,1]));return sU(e,[e.size])}}});e.s(["dot",0,lV],32537);let lW=n$({ensureShape_:function(e,t){let r=nT(e,"x","ensureShape","string_or_numeric");if(!v(r.shape,t))throw Error(`EnsureShape: Shape of tensor ${r.shape} is not compatible with expected shape ${t}`);return e}}),lU=n$({erf_:function(e){let t=nT(e,"x","erf");m("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=aR(t,"float32"));let r={x:t};return na.runKernel("Erf",r)}});e.s(["erf",0,lU],95772);let lG=n$({euclideanNorm_:function(e,t=null,r=!1){return oS(e,"euclidean",t,r)}});e.s(["euclideanNorm",0,lG],30448);let lq=n$({expm1_:function(e){let t=nT(e,"x","expm1");return na.runKernel(eY,{x:t})}});e.s(["expm1",0,lq],54160);let lH=n$({floor_:function(e){let t=nT(e,"x","floor","float32");return na.runKernel(e0,{x:t})}});e.s(["floor",0,lH],56691);let lj=n$({gather_:function(e,t,r=0,n=0){let a=nT(e,"x","gather"),s=nT(t,"indices","gather","int32");return na.runKernel(e3,{x:a,indices:s},{axis:r,batchDims:n})}});e.s(["gather",0,lj],64960);let lK=n$({isFinite_:function(e){let t=nT(e,"x","isFinite");return na.runKernel(te,{x:t})}});e.s(["isFinite",0,lK],80507);let lX=n$({isInf_:function(e){let t=nT(e,"x","isInf");return na.runKernel(tt,{x:t})}});e.s(["isInf",0,lX],73560);let lZ=n$({isNaN_:function(e){let t=nT(e,"x","isNaN");return na.runKernel(tr,{x:t})}});function lY(e,t,r){if(r<=0)throw Error("The number of values should be positive.");return na.runKernel(ti,{},{start:e,stop:t,num:r})}e.s(["isNaN",0,lZ],95596);let lJ=n$({localResponseNormalization_:function(e,t=5,r=1,n=1,a=.5){let s=nT(e,"x","localResponseNormalization");m(4===s.rank||3===s.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),m(S(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;3===s.rank&&(o=!0,i=sU(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u=na.runKernel("LRN",l,{depthRadius:t,bias:r,alpha:n,beta:a});return o?sU(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});e.s(["localResponseNormalization",0,lJ],98657);let lQ=n$({softplus_:function(e){let t=nT(e,"x","softplus");return na.runKernel(tQ,{x:t})}});e.s(["softplus",0,lQ],81008);let l0=n$({logSigmoid_:function(e){let t=nT(e,"x","logSigmoid");return aH(e=>({value:ol(lQ(ol(e))),gradFunc:t=>aL(t,id(ol(e)))}))(t)}});e.s(["logSigmoid",0,l0],76428);let l1=n$({logSoftmax_:function(e,t=-1){let r=nT(e,"logits","logSoftmax");if(-1===t&&(t=r.rank-1),t!==r.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${r.rank} and axis was ${t}`);return aH((e,r)=>{let n=ov(e,t,!0),a=a5(e,n),s=a5(aR(a,"float32"),oL(im(oV(a),t,!0)));return r([s]),{value:s,gradFunc:(e,r)=>{let[n]=r,a=oV(n);return a5(e,aL(im(e,t,!0),a))}}})(r)}});e.s(["logSoftmax",0,l1],75869);let l2=n$({logicalNot_:function(e){let t=nT(e,"x","logicalNot","bool");return na.runKernel(tu,{x:t})}});e.s(["logicalNot",0,l2],92477);let l3=n$({logicalOr_:function(e,t){let r=nT(e,"a","logicalOr","bool"),n=nT(t,"b","logicalOr","bool");return st(r.shape,n.shape),na.runKernel(th,{a:r,b:n})}});e.s(["logicalOr",0,l3],97612);let l4=n$({logicalXor_:function(e,t){let r=nT(e,"a","logicalXor","bool"),n=nT(t,"b","logicalXor","bool");return st(r.shape,n.shape),oi(l3(e,t),l2(oi(e,t)))}});e.s(["logicalXor",0,l4],66213);let l6=n$({searchSorted_:function(e,t,r="left"){let n=nT(e,"sortedSequence","searchSorted"),a=nT(t,"values","searchSorted"),s=n.shape[n.shape.length-1],i=a.shape[a.shape.length-1],o=sU(n,[-1,s]),l=sU(a,[-1,i]);if(o.rank<2)throw Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(b(l.shape)>=0x80000000)throw Error("values tensor size must less than 2147483648");if(o.shape[1]>=0x80000000)throw Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);return na.runKernel(tH,{sortedSequence:o,values:l},{side:r})}});function l5(e,t){return l6(e,t,"left")}e.s(["searchSorted",0,l6],36975);let l8=n$({maxPool_:function(e,t,r,n,a){let s=nT(e,"x","maxPool"),i=s,o=!1;3===s.rank&&(o=!0,i=sU(s,[1,s.shape[0],s.shape[1],s.shape[2]])),m(4===i.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),m(s7(r,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '1'`),ir("maxPool",n,a);let l={x:i},u=na.runKernel(td,l,{filterSize:t,strides:r,pad:n,dimRoundingMode:a});return o?sU(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});e.s(["maxPool",0,l8],67289);let l9=n$({maxPool3d_:function(e,t=[1,1,1],r,n,a,s="NDHWC"){let i=nT(e,"x","maxPool3d"),o=i,l=!1;4===i.rank&&(l=!0,o=sU(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),m(5===o.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),m("NDHWC"===s,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),ir("maxPool3d",n,a);let u={x:o},h=na.runKernel(tc,u,{filterSize:t,strides:r,pad:n,dimRoundingMode:a,dataFormat:s});return l?sU(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});e.s(["maxPool3d",0,l9],64733);let l7=n$({maxPoolWithArgmax_:function(e,t,r,n,a=!1){let s=nT(e,"x","maxPoolWithArgmax"),i=na.runKernel(tf,{x:s},{filterSize:t,strides:r,pad:n,includeBatchInIndex:a});return{result:i[0],indexes:i[1]}}});function ue(e,t,{indexing:r="xy"}={}){if("xy"!==r&&"ij"!==r)throw TypeError(`${r} is not a valid third argument to meshgrid`);if(void 0===e)return[];let n=nT(e,"x","meshgrid",e instanceof rJ?e.dtype:"float32");if(void 0===t)return[n];let a=nT(t,"y","meshgrid",t instanceof rJ?t.dtype:"float32"),s=b(n.shape),i=b(a.shape);return"xy"===r?(n=sU(n,[1,-1]),a=sU(a,[-1,1]),[iI(oR([i,1],n.dtype),n),iI(a,oR([1,s],a.dtype))]):(n=sU(n,[-1,1]),a=sU(a,[1,-1]),[iI(n,oR([1,i],n.dtype)),iI(oR([s,1],a.dtype),a)])}let ut=n$({mirrorPad_:function(e,t,r){m("reflect"===r||"symmetric"===r,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${r}.`);let n=nT(e,"x","mirrorPad");if(0===n.rank)throw Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");m(t.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${t.length}.`);let a=+("reflect"===r);for(let e=0;e<n.rank;e++)m(2===t[e].length,()=>"Invalid number of paddings. Must be length of 2 each."),m(t[e][0]>=0&&t[e][0]<=n.shape[e]-a&&t[e][1]>=0&&t[e][1]<=n.shape[e]-a,()=>`Padding in dimension ${e} cannot be greater than or equal to ${n.shape[e]-a} or less than 0 for input of shape ${n.shape}`);return na.runKernel(ty,{x:n},{paddings:t,mode:r})}});e.s(["mirrorPad",0,ut],19318);let ur=n$({mod_:function(e,t){let r=nT(e,"a","mod"),n=nT(t,"b","mod");[r,n]=r5(r,n);let a={a:r,b:n};return na.runKernel("Mod",a)}});e.s(["mod",0,ur],46554);let un=n$({moments_:function(e,t=null,r=!1){let n=$(t,(e=nT(e,"x","moments")).shape),a=o$(e,n,r),s=a.shape;r||(s=om(a.shape,n));let i=o$(aP(a5(aR(e,"float32"),sU(a,s))),n,r);return{mean:a,variance:i}}});e.s(["moments",0,un],12965);let ua=n$({multiRNNCell_:function(e,t,r,n){let a=nT(t,"data","multiRNNCell"),s=nC(r,"c","multiRNNCell"),i=nC(n,"h","multiRNNCell"),o=a,l=[];for(let t=0;t<e.length;t++){let r=e[t](o,s[t],i[t]);l.push(r[0]),l.push(r[1]),o=r[1]}let u=[],h=[];for(let e=0;e<l.length;e+=2)u.push(l[e]),h.push(l[e+1]);return[u,h]}}),us=n$({multinomial_:function(e,t,r,n=!1){let a=nT(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw Error(`Rank of probabilities must be 1 or 2, but is ${i}`);r=r||Math.random();let o=1===i?sU(a,[1,-1]):a,l={numSamples:t,seed:r,normalized:n},u=na.runKernel(tb,{logits:o},l);return 1===i?sU(u,[u.size]):u}}),ui=n$({oneHot_:function(e,t,r=1,n=0,a="int32"){if(t<2)throw Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s=nT(e,"indices","oneHot","int32");return na.runKernel(tI,{indices:s},{dtype:a,depth:t,onValue:r,offValue:n})}});e.s(["oneHot",0,ui],90889);let uo=n$({onesLike_:function(e){let t=nT(e,"x","onesLike");return na.runKernel(tk,{x:t})}});e.s(["onesLike",0,uo],46768);let ul=n$({outerProduct_:function(e,t){let r=nT(e,"v1","outerProduct"),n=nT(t,"v2","outerProduct");return m(1===r.rank&&1===n.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${r.rank} and ${n.rank}.`),iI(sU(r,[-1,1]),sU(n,[1,-1]))}}),uu=n$({pad_:function(e,t,r=0){let n=nT(e,"x","pad");if(0===n.rank)throw Error("pad(scalar) is not defined. Pass non-scalar to pad");return na.runKernel(tC,{x:n},{paddings:t,constantValue:r})}});e.s(["pad",0,uu],56877);let uh=n$({pad1d_:function(e,t,r=0){return m(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),uu(e,[t],r)}}),up=n$({pad2d_:function(e,t,r=0){return m(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),uu(e,t,r)}}),ud=n$({pad3d_:function(e,t,r=0){return m(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),uu(e,t,r)}}),uc=n$({pad4d_:function(e,t,r=0){return m(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),uu(e,t,r)}}),uf=n$({spaceToBatchND_:function(e,t,r){let n=nT(e,"x","spaceToBatchND");return m(n.rank>=1+t.length,()=>`input rank ${n.rank} should be > than [blockShape] ${t.length}`),m(r.length===t.length,()=>`paddings.shape[0] ${r.length} must be equal to [blockShape] ${t.length}`),m(n.shape.reduce((e,n,a)=>a>0&&a<=t.length?e&&(n+r[a-1][0]+r[a-1][1])%t[a-1]==0:e,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${r.toString()} must be divisible by blockShapes ${t.toString()}`),na.runKernel(t1,{x:n},{blockShape:t,paddings:r})}});e.s(["spaceToBatchND",0,uf],22947);let um=n$({pool_:function(e,t,r,n,a,s,i){var o,l,u,h,p;let d,c,f,g,y,b,x,v,w;null==a&&(a=[1,1]),null==s&&(s=1),0===n&&(n="valid");let S=nT(e,"x","maxPool"),N=S,k=!1;3===S.rank&&(k=!0,N=sU(S,[1,S.shape[0],S.shape[1],S.shape[2]])),m(s7(s,a),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`);let I=sQ(N.shape,t,s,a,n),T=[I.dilationHeight,I.dilationWidth];d="same"===n?(o=[I.filterHeight,I.filterWidth],l=T,f=(c=o.map((e,t)=>e+(e-1)*(l[t]-1)).map(e=>e-1)).map(e=>Math.floor(e/2)),g=c.map((e,t)=>e-f[t]),c.map((e,t)=>[f[t],g[t]])):[[0,0],[0,0]];let C=1===T[0]&&1===T[1],[E,$]=(u=[I.inHeight,I.inWidth],h=T,y=(p=d).map(e=>e[0]),x=u.concat(y,b=p.map(e=>e[1])),v=h.map((e,t)=>(e-x[t]%e)%e),w=b.map((e,t)=>e+v[t]),[h.map((e,t)=>[y[t],w[t]]),h.map((e,t)=>[0,v[t]])]),A=C?n:"valid",R=C?N:uf(N,T,E),D=("avg"===r?()=>lu(R,t,s,A,i):()=>l8(R,t,s,A,i))(),F=C?D:lc(D,T,$);return k?sU(F,[F.shape[1],F.shape[2],F.shape[3]]):F}});e.s(["pool",0,um],94125);let ug=n$({prod_:function(e,t=null,r=!1){let n=nT(e,"x","prod");"bool"===n.dtype&&(n=aR(n,"int32"));let a={x:n};return na.runKernel(t$,a,{axis:t,keepDims:r})}});e.s(["prod",0,ug],95558);let uy=n$({raggedGather_:function(e,t,r,n){let a=e.map((e,t)=>nT(e,`tensors${t}`,"raggedGather","int32")),s=nT(t,"paramsDenseValues","raggedGather"),i=nT(r,"indices","raggedGather","int32"),o=na.runKernel(tA,{paramsNestedSplits:a,paramsDenseValues:s,indices:i},{outputRaggedRank:n});return{outputNestedSplits:o.slice(0,o.length-1),outputDenseValues:o[o.length-1]}}}),ub=n$({raggedRange_:function(e,t,r){let n=nT(e,"starts","raggedRange"),a=nT(t,"limits","raggedRange",n.dtype),s=nT(r,"deltas","raggedRange",n.dtype),i=na.runKernel(tR,{starts:n,limits:a,deltas:s});return{rtNestedSplits:i[0],rtDenseValues:i[1]}}}),ux=n$({raggedTensorToTensor_:function(e,t,r,n,a){let s=nT(e,"shape","raggedTensorToTensor","int32"),i=nT(t,"values","raggedTensorToTensor"),o=nT(r,"defaultValue","raggedTensorToTensor",i.dtype),l=n.map((e,t)=>nT(e,`tensors${t}`,"raggedTensorToTensor","int32"));return na.runKernel(tD,{shape:s,values:i,defaultValue:o,rowPartitionTensors:l},{rowPartitionTypes:a})}}),uv=n$({rand_:function(e,t,r){Z(e);let n=b(e),a=null;if(null==r||"float32"===r)a=new Float32Array(n);else if("int32"===r)a=new Int32Array(n);else if("bool"===r)a=new Uint8Array(n);else throw Error(`Unknown data type ${r}`);for(let e=0;e<n;e++)a[e]=t();return na.makeTensor(a,e,r)}});var uw=e.i(89378);class uS{constructor(e,t,r,n,a){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=n,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=uw.alea(s.toString())}nextValue(){let e,t;if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let r=!1;for(;!r;){let n,a,s;do s=(n=2*this.random()-1)*n+(a=2*this.random()-1)*a;while(s>=1||0===s)let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*n*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class uN{constructor(e,t,r,n){this.alpha=e,this.beta=1/t,this.dtype=r;const a=n||Math.random();this.randu=uw.alea(a.toString()),this.randn=new uS(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,r,n,a,s;for(;;){do n=this.randn.nextValue(),s=1+this.c*n;while(s<=0)if(s*=s*s,t=1-.331*(e=n*n)*e,r=.5*e+this.d*(1-s+Math.log(s)),(a=this.randu())<t||Math.log(a)<r)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class uk{constructor(e=0,t=1,r,n){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=r,null==n&&(n=Math.random()),"number"==typeof n&&(n=n.toString()),!this.canReturnFloat()&&this.range<=1)throw Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=uw.alea(n)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}let uI=n$({randomGamma_:function(e,t,r=1,n="float32",a){if(Z(e),null==r&&(r=1),null==n&&(n="float32"),"float32"!==n&&"int32"!==n)throw Error(`Unsupported data type ${n}`);let s=new uN(t,r,n,a),i=aA(e,n);for(let e=0;e<i.values.length;e++)i.values[e]=s.nextValue();return i.toTensor()}}),uT=n$({randomNormal_:function(e,t=0,r=1,n,a){if(Z(e),null!=n&&"bool"===n)throw Error(`Unsupported data type ${n}`);let s=new uS(t,r,n,!1,a),i=aA(e,n);for(let e=0;e<i.values.length;e++)i.values[e]=s.nextValue();return i.toTensor()}});e.s(["randomNormal",0,uT],39316);let uC=n$({randomStandardNormal_:function(e,t,r){if(null!=t&&"bool"===t)throw Error(`Unsupported data type ${t}`);return uT(e,0,1,t,r)}}),uE=n$({randomUniform_:function(e,t=0,r=1,n="float32",a){Z(e);let s=aA(e,n),i=new uk(t,r,null,a);for(let e=0;e<s.values.length;e++)s.values[e]=i.nextValue();return s.toTensor()}});e.s(["randomUniform",0,uE],79362);let u$=n$({randomUniformInt_:function(e,t,r,n){return uE(e,t,r,"int32",n)}}),uA=n$({reciprocal_:function(e){let t=nT(e,"x","reciprocal");return na.runKernel(t_,{x:t})}});e.s(["reciprocal",0,uA],80781);let uR=n$({reverse1d_:function(e){let t=nT(e,"x","reverse");return m(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),sZ(t,0)}}),uD=n$({reverse2d_:function(e,t){let r=nT(e,"x","reverse");return m(2===r.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${r.rank}.`),sZ(r,t)}}),uF=n$({reverse3d_:function(e,t){let r=nT(e,"x","reverse");return m(3===r.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${r.rank}.`),sZ(r,t)}}),uO=n$({reverse4d_:function(e,t){let r=nT(e,"x","reverse");return m(4===r.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${r.rank}.`),sZ(r,t)}}),u_=n$({rsqrt_:function(e){let t=nT(e,"x","rsqrt","float32");return na.runKernel(tU,{x:t})}});e.s(["rsqrt",0,u_],56367);let uM=n$({selu_:function(e){let t=nT(e,"x","selu");return na.runKernel(tK,{x:t})}});e.s(["selu",0,uM],82669);let uL=n$({separableConv2d_:function(e,t,r,n,a,s=[1,1],i="NHWC"){let o=nT(e,"x","separableConv2d"),l=nT(t,"depthwiseFilter","separableConv2d"),u=nT(r,"pointwiseFilter","separableConv2d"),h=o,p=!1;if(3===o.rank&&(p=!0,h=sU(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");m(4===h.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),m(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),m(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),m(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),m(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let d=l.shape[2],c=l.shape[3];m(u.shape[2]===d*c,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*c}, but got ${u.shape[2]}.`);let f=ia(iw(h,l,n,a,i,s),u,1,"valid",i);return p?sU(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});async function uz(e,t){let r=nT(e,"x","setdiff1d"),n=nT(t,"y","setdiff1d");m(r.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${r.dtype}) and y (${n.dtype}).`),m(1===r.rank,()=>`x should be 1D tensor, but got x (${r.shape}).`),m(1===n.rank,()=>`y should be 1D tensor, but got y (${n.shape}).`);let a=await r.data(),s=new Set(await n.data()),i=0;for(let e=0;e<a.length;e++)!s.has(a[e])&&i++;let o=new rH([i],r.dtype),l=new rH([i],"int32");for(let e=0,t=0;e<a.length;e++)!s.has(a[e])&&(o.values[t]=a[e],l.values[t]=e,t++);return[o.toTensor(),l.toTensor()]}e.s(["separableConv2d",0,uL],81982);let uP=n$({sign_:function(e){let t=nT(e,"x","sign");return na.runKernel(tY,{x:t})}});e.s(["sign",0,uP],4509);let uB=n$({sin_:function(e){let t=nT(e,"x","sin","float32");return na.runKernel("Sin",{x:t})}});e.s(["sin",0,uB],49729);let uV=n$({sinh_:function(e){let t=nT(e,"x","sinh");return na.runKernel(tZ,{x:t})}});e.s(["sinh",0,uV],41001);let uW=n$({slice1d_:function(e,t,r){let n=nT(e,"x","slice1d");return m(1===n.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),sG(n,[t],[r])}});e.s(["slice1d",0,uW],70402);let uU=n$({slice2d_:function(e,t,r){let n=nT(e,"x","slice2d");return m(2===n.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),sG(n,t,r)}});e.s(["slice2d",0,uU],58063);let uG=n$({slice3d_:function(e,t,r){let n=nT(e,"x","slice3d");return m(3===n.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),sG(n,t,r)}});e.s(["slice3d",0,uG],13741);let uq=n$({slice4d_:function(e,t,r){let n=nT(e,"x","slice4d");return m(4===n.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),sG(n,t,r)}});e.s(["slice4d",0,uq],23582);let uH=n$({softmax_:function(e,t=-1){let r=nT(e,"logits","softmax","float32");if(-1===t&&(t=r.rank-1),t!==r.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${r.rank} and dim was ${t}`);let n={dim:t};return na.runKernel(t3,{logits:r},n)}});e.s(["softmax",0,uH],41721);let uj=n$({stridedSlice_:function(e,t,r,n,a=0,s=0,i=0,o=0,l=0){let u=nT(e,"x","stridedSlice","string_or_numeric");return na.runKernel(rt,{x:u},{begin:t,end:r,strides:n,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l})}});e.s(["stridedSlice",0,uj],25273);let uK=n$({tan_:function(e){let t=nT(e,"x","tan","float32");return na.runKernel("Tan",{x:t})}});function uX(e,t,r){if(y(e),null!=t&&3!==t.length)throw Error("tensor3d() requires shape to have three numbers");let n=nk(e,r);if(3!==n.length&&1!==n.length)throw Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===n.length&&null==t)throw Error("tensor3d() requires shape to be provided when `values` are a flat array");return nR(e,t,n,r)}function uZ(e,t,r){if(y(e),null!=t&&4!==t.length)throw Error("tensor4d() requires shape to have four numbers");let n=nk(e,r);if(4!==n.length&&1!==n.length)throw Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===n.length&&null==t)throw Error("tensor4d() requires shape to be provided when `values` are a flat array");return nR(e,t,n,r)}function uY(e,t,r){if(y(e),null!=t&&5!==t.length)throw Error("tensor5d() requires shape to have five numbers");let n=nk(e,r);if(5!==n.length&&1!==n.length)throw Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===n.length&&null==t)throw Error("tensor5d() requires shape to be provided when `values` are a flat array");return nR(e,t,n,r)}function uJ(e,t,r){if(y(e),null!=t&&6!==t.length)throw Error("tensor6d() requires shape to have six numbers");let n=nk(e,r);if(6!==n.length&&1!==n.length)throw Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===n.length&&null==t)throw Error("tensor6d() requires shape to be provided when `values` are a flat array");return nR(e,t=t||n,n,r)}function uQ(e,t,r){let n=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${r.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${n}, and batchDim: ${a}.`;if(r.rank<a)throw Error(s+` update.rank < ${a}. `);if(e.length<n+(r.rank-a))throw Error(s+` Output shape length < ${n+(r.rank-a)}`);if(r.rank!==a+e.length-n)throw Error(s+` update.rank != ${a+e.length-n}`);for(let e=0;e<a;++e)if(r.shape[e]!==t.shape[e])throw Error(s+` updates.shape[${e}] (${r.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<r.rank-a;++t)if(r.shape[t+a]!==e[t+n])throw Error(s+` updates.shape[${t+a}] (${r.shape[t+a]}) != shape[${t+a}] (${e[t+a]})`)}function u0(e,t,r){if(t.rank<1)throw Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(r.length<1)throw Error(`Output rank must be greater or equal to 1, but got shape: ${r}`);if(0===r.length){if(0===t.size)throw Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw Error(`Updates specified for empty output. updates shape: ${e.shape}`)}uQ(r,t,e)}function u1(e,t,r){let n=t.shape.length,a=n>1?t.shape[n-1]:1,s=r.length,i=1;for(let e=a;e<s;++e)i*=r[e];let o=a<1?1:a,l=b(t.shape)/o,u=[...G(r.slice(0,a)),1];return{sliceRank:a,numUpdates:l,sliceSize:i,strides:u,outputSize:b(r)}}e.s(["tan",0,uK],84580),e.s(["tensor3d",()=>uX],18181),e.s(["calculateShapes",()=>u1,"validateInput",()=>u0,"validateUpdateShape",()=>uQ],87271);let u2=n$({tensorScatterUpdate_:function(e,t,r){let n=nT(e,"tensor","tensorScatterupdate"),a=nT(t,"indices","tensorScatterupdate","int32"),s=nT(r,"updates","tensorScatterupdate");if(u0(s,a,n.shape),n.dtype!==s.dtype)throw Error(`tensor and updates must have the same dtype, instead they are ${n.dtype} and ${s.dtype}.`);return na.runKernel(tq,{tensor:n,indices:a,updates:s},{})}}),u3=n$({topk_:function(e,t=1,r=!0){let n=nT(e,"x","topk");if(0===n.rank)throw Error("topk() expects the input to be of rank 1 or higher");let a=n.shape[n.shape.length-1];if(t<0)throw Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let[s,i]=na.runKernel(ro,{x:n},{k:t,sorted:r});return{values:s,indices:i}}});e.s(["topk",0,u3],40939);let u4=n$({truncatedNormal_:function(e,t=0,r=1,n,a){if(Z(e),null!=n&&"bool"===n)throw Error("Unsupported data type $ { dtype }");let s=new uS(t,r,n,!0,a),i=aA(e,n);for(let e=0;e<i.values.length;e++)i.values[e]=s.nextValue();return i.toTensor()}});e.s(["truncatedNormal",0,u4],2510);let u6=n$({unique_:function(e,t=0){let r=nT(e,"x","unique","string_or_numeric");m(r.rank>0,()=>"The input tensor must be at least 1D");let[n,a]=na.runKernel(rh,{x:r},{axis:t});return{values:n,indices:a}}});e.s(["unique",0,u6],20691);let u5=n$({unsortedSegmentSum_:function(e,t,r){let n=nT(e,"x","unsortedSegmentSum"),a=nT(t,"segmentIds","unsortedSegmentSum","int32");return m(S(r),()=>"numSegments must be of dtype int"),na.runKernel(rd,{x:n,segmentIds:a},{numSegments:r})}});function u8(e,t){return l6(e,t,"right")}function u9(e,t=!0,r,n){return na.makeVariable(e,t,r,n)}function u7(e,t){let r=[];for(let e=0;e<t.length;e++)t[e]&&r.push(e);let n=aA(e,"int32"),a=aA([r.length,e.length],"int32");for(let t=0;t<r.length;t++){let s=n.indexToLoc(r[t]),i=t*e.length;a.values.set(s,i)}return a.toTensor()}async function he(e){let t=nT(e,"condition","whereAsync","bool"),r=await t.data(),n=u7(t.shape,r);return e!==t&&t.dispose(),n}async function ht(e,t,r){let n=nT(e,"tensor","boolMask"),a=nT(t,"mask","boolMask","bool"),s=null==r?0:r,i=a.rank,o=n.shape;m(i>0,()=>"mask cannot be scalar"),g(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let e=s;e<s+i;e++)l*=o[e];let u=sU(n,o.slice(0,s).concat([l],o.slice(s+i))),h=sU(a,[-1]),p=await he(h),d=oN(p,[1]),c=lj(u,d,s);return e!==n&&n.dispose(),t!==a&&a.dispose(),d.dispose(),u.dispose(),h.dispose(),p.dispose(),c}e.s(["unsortedSegmentSum",0,u5],73934),e.s(["variable",()=>u9],80765),e.s(["whereImpl",()=>u7],92135),e.s(["booleanMaskAsync",0,ht],14044),e.i(14044),e.i(90049),e.i(99269);let hr=n$({movingAverage_:function(e,t,r,n,a=!0){let s=nT(e,"v","movingAverage"),i=nT(t,"x","movingAverage"),o=nT(r,"decay","movingAverage");r8(s,i),m(w(s.shape,i.shape),()=>"Shape mismatch in v and x");let l=aK(1),u=a5(l,o),h=aL(a5(i,s),u);return a&&(m(null!=n,()=>"When using zeroDebias: true, step is required."),h=aM(h,a5(l,a6(o,nT(n,"step","movingAverage"))))),aO(s,h)}});e.s(["movingAverage",0,hr],54661),e.i(54661);let hn=n$({scatterND_:function(e,t,r){Z(r);let n=nT(e,"indices","scatterND","int32"),a=nT(t,"updates","scatterND");return u0(a,n,r),na.runKernel(tG,{indices:n,updates:a},{shape:r})}});e.s(["scatterND",0,hn],24308),e.i(24308),e.i(36975);let ha=n$({sparseToDense_:function(e,t,r,n=0){Z(r);let a=nT(e,"sparseIndices","sparseToDense","int32"),s=nT(t,"sparseValues","sparseToDense","string_or_numeric"),i=nT(n,"defaultValue","sparseToDense",s.dtype);if("int32"!==a.dtype)throw Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${a.dtype}.`);if(a.rank>2)throw Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${a.shape}.`);let o=a.rank>0?a.shape[0]:1,l=a.rank>1?a.shape[1]:1;if(r.length!==l)throw Error(`outputShape has incorrect number of elements:, ${r.length}, should be: ${l}.`);let u=s.size;if(0!==s.rank&&(1!==s.rank||u!==o))throw Error(`sparseValues has incorrect shape ${s.shape}, should be [] or [${o}]`);if(s.dtype!==i.dtype)throw Error("sparseValues.dtype must match defaultValues.dtype");return na.runKernel(t9,{sparseIndices:a,sparseValues:s,defaultValue:i},{outputShape:r})}});e.s(["sparseToDense",0,ha],28546),e.i(28546);let hs=n$({gatherND_:function(e,t){let r=nT(t,"indices","gatherND","int32"),n=nT(e,"x","gatherND","string_or_numeric");return na.runKernel(e4,{params:n,indices:r})}});e.s(["gatherND",0,hs],48708),e.i(48708);let hi=n$({dropout_:function(e,t,r,n){let a=nT(e,"x","dropout");if(m("float32"===a.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`),m(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return e instanceof rJ?a.clone():a;let s=function(e,t){if(null==t)return e.shape.slice();if(w(e.shape,t))return t;if(e.shape.length===t.length){let r=[];for(let n=0;n<e.shape.length;n++)null==t[n]&&null!=e.shape[n]?r.push(e.shape[n]):r.push(t[n]);return r}return t}(a,r),i=1-t;return aL(a,aM(lH(aO(uE(s,0,1,"float32",n),i)),i))}});async function ho(e,t,r=1){let n=nT(e,"predictions","inTopK"),a=nT(t,"targets","inTopK");m(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),m(n.rank-1===a.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${a.rank}`),g(n.shape.slice(0,n.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=n.shape[n.shape.length-1];m(r>0&&r<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${r}`);let i=await n.data(),o=await a.data(),[l,u]=[i.length/s,s],h=D("bool",l);for(let e=0;e<l;e++){let t=e*u,n=i.subarray(t,t+u),a=[];for(let e=0;e<n.length;e++)a.push({value:n[e],index:e});a.sort((e,t)=>t.value-e.value),h[e]=0;for(let t=0;t<r;t++)if(a[t].index===o[e]){h[e]=1;break}}return e!==n&&n.dispose(),t!==a&&a.dispose(),nD(h,a.shape,"bool")}e.s(["dropout",0,hi],16738),e.i(16738),e.i(96851),e.s(["inTopKAsync",0,ho],8760),e.i(8760),e.s(["OP_SCOPE_SUFFIX",0,nE,"abs",0,a9,"acos",0,o8,"acosh",0,o9,"add",0,aO,"addN",0,o7,"all",0,le,"any",0,lt,"argMax",0,lr,"argMin",0,ln,"asin",0,la,"asinh",0,ls,"atan",0,li,"atan2",0,lo,"atanh",0,ll,"avgPool",0,lu,"avgPool3d",0,lh,"basicLSTMCell",0,ld,"batchNorm",0,lf,"batchNorm2d",0,lm,"batchNorm3d",0,lg,"batchNorm4d",0,ly,"batchToSpaceND",0,lc,"bincount",0,i6,"bitwiseAnd",0,lb,"booleanMaskAsync",0,ht,"broadcastArgs",0,lx,"broadcastTo",0,i7,"buffer",()=>aA,"cast",0,aR,"ceil",0,lv,"clipByValue",0,lw,"clone",0,aD,"complex",0,nA,"concat",0,sB,"concat1d",0,lS,"concat2d",0,lN,"concat3d",0,lk,"concat4d",0,lI,"conv1d",0,lT,"conv2d",0,ia,"conv2dTranspose",0,lC,"conv3d",0,lE,"conv3dTranspose",0,lA,"cos",0,lR,"cosh",0,lD,"cosineWindow",()=>iA,"cumprod",0,lF,"cumsum",0,lO,"denseBincount",0,l_,"depthToSpace",0,lM,"depthwiseConv2d",0,iw,"diag",0,lL,"dilation2d",0,lz,"div",0,aM,"divNoNan",0,lB,"dot",0,lV,"dropout",0,hi,"einsum",0,iB,"elu",0,io,"enclosingPowerOfTwo",()=>i$,"ensureShape",0,lW,"equal",0,lP,"erf",0,lU,"euclideanNorm",0,lG,"exp",0,oV,"expandDims",0,iV,"expm1",0,lq,"eye",0,oI,"fft",0,sj,"fill",()=>a3,"floor",0,lH,"floorDiv",0,a_,"fused",0,iC,"gather",0,lj,"gatherND",0,hs,"greater",0,i8,"greaterEqual",0,oa,"ifft",0,sX,"imag",0,sV,"image",()=>o2,"inTopKAsync",0,ho,"irfft",0,sY,"isFinite",0,lK,"isInf",0,lX,"isNaN",0,lZ,"leakyRelu",0,il,"less",0,os,"lessEqual",0,i5,"linalg",()=>o3,"linspace",()=>lY,"localResponseNormalization",0,lJ,"log",0,oL,"log1p",0,oW,"logSigmoid",0,l0,"logSoftmax",0,l1,"logSumExp",0,oG,"logicalAnd",0,oi,"logicalNot",0,l2,"logicalOr",0,l3,"logicalXor",0,l4,"losses",()=>o4,"lowerBound",()=>l5,"matMul",0,iI,"max",0,ov,"maxPool",0,l8,"maxPool3d",0,l9,"maxPoolWithArgmax",0,l7,"maximum",0,sr,"mean",0,o$,"meshgrid",()=>ue,"min",0,ow,"minimum",0,oo,"mirrorPad",0,ut,"mod",0,ur,"moments",0,un,"movingAverage",0,hr,"mul",0,aL,"multiRNNCell",0,ua,"multinomial",0,us,"neg",0,ol,"norm",0,oS,"notEqual",0,oA,"oneHot",0,ui,"ones",()=>oR,"onesLike",0,uo,"op",()=>n$,"outerProduct",0,ul,"pad",0,uu,"pad1d",0,uh,"pad2d",0,up,"pad3d",0,ud,"pad4d",0,uc,"pool",0,um,"pow",0,a6,"prelu",0,iu,"print",()=>aF,"prod",0,ug,"raggedGather",0,uy,"raggedRange",0,ub,"raggedTensorToTensor",0,ux,"rand",0,uv,"randomGamma",0,uI,"randomNormal",0,uT,"randomStandardNormal",0,uC,"randomUniform",0,uE,"randomUniformInt",0,u$,"range",()=>ot,"real",0,sW,"reciprocal",0,uA,"relu",0,ih,"relu6",0,ip,"reshape",0,sU,"reverse",0,sZ,"reverse1d",0,uR,"reverse2d",0,uD,"reverse3d",0,uF,"reverse4d",0,uO,"rfft",0,sK,"round",0,i9,"rsqrt",0,u_,"scalar",()=>aK,"scatterND",0,hn,"searchSorted",0,l6,"selu",0,uM,"separableConv2d",0,uL,"setdiff1dAsync",0,uz,"sigmoid",0,id,"sign",0,uP,"signal",()=>o1,"sin",0,uB,"sinh",0,uV,"slice",0,sG,"slice1d",0,uW,"slice2d",0,uU,"slice3d",0,uG,"slice4d",0,uq,"softmax",0,uH,"softplus",0,lQ,"spaceToBatchND",0,uf,"sparse",()=>o6,"sparseToDense",0,ha,"spectral",()=>o0,"split",0,sq,"sqrt",0,az,"square",0,aP,"squaredDifference",0,oP,"squeeze",0,oN,"stack",0,ou,"step",0,ic,"stridedSlice",0,uj,"string",()=>o5,"sub",0,a5,"sum",0,im,"tan",0,uK,"tanh",0,lp,"tensor",()=>nD,"tensor1d",()=>iE,"tensor2d",()=>iF,"tensor3d",()=>uX,"tensor4d",()=>uZ,"tensor5d",()=>uY,"tensor6d",()=>uJ,"tensorScatterUpdate",0,u2,"tile",0,iz,"topk",0,u3,"transpose",0,oT,"truncatedNormal",0,u4,"unique",0,u6,"unsortedSegmentSum",0,u5,"unstack",0,oh,"upperBound",()=>u8,"variable",()=>u9,"where",0,oe,"whereAsync",0,he,"zeros",()=>sH,"zerosLike",0,aB],9670)},70001,95253,89132,3130,71722,66841,e=>{"use strict";e.i(70306);var t,r,n,a,s,i=e.i(29064);(0,i.env)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var o=e.i(17372),l=e.i(61898);e.s(["io",0,l],95253);var l=l,u=e.i(86962),h=e.i(34338);e.s(["util",0,h],89132);var h=h,p=e.i(67034);(t=a||(a={}))[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF",(n=(r=s||(s={})).CheckpointFormatVersion||(r.CheckpointFormatVersion={}))[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2";let d={};function c(e,t){d[e]={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t}}function f(e){return d[e]}function m(e){delete d[e]}e.s(["deregisterOp",()=>m,"getRegisteredOp",()=>f,"registerOp",()=>c],3130);var g=e.i(39705),h=h;function y(e,t,r,n,a){let s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){let e=s.inputIndexStart,i=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===s.type)return b(t.inputNames[o],r,n,a);if("tensors"===s.type){let s=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter((e,t)=>{var r;return(null==(r=s[t])?void 0:r.op)!=="NoOp"}).map(e=>b(e,r,n,a))}let l=b(t.inputNames[o],r,n,a),u=l.dataSync();return"number"===s.type?u[0]:h.toNestedArray(l.shape,u)}let i=t.attrParams[e];return i&&i.value}function b(e,t,r,n){let[a,s]=S(e,r);if(null!=n){let e=n.getHashTableHandleByName(a);if(null!=e)return e}let i=r.currentContextIds.find(e=>!!t[w(a,e)]);return void 0!==i?t[w(a,i)][s]:void 0}function x(e,t,r){return t[w(e,r.currentContextId)]}function v(e,t){let[r,n,a]=S(e,t);return[w(r,t&&t.currentContextId),n,a]}function w(e,t){return t?`${e}-${t}`:e}function S(e,t){let r;if(""===e)return["",0,void 0];let n=null!=t&&null!=t.parseNodeNameCache;if(n){let r=t.parseNodeNameCache.get(e);if(null!=r)return r}let a=e.split(":");if(1===a.length)r=[e,0,void 0];else{let e=a[0],t=3===a.length?a[1]:void 0;r=[e,Number(a[a.length-1]),t]}return n&&t.parseNodeNameCache.set(e,r),r}function N(e,t,r){let n=y("pad",e,t,r);if("explicit"===n){n=y("explicitPaddings",e,t,r);let a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=n[2*e],a[e][1]=n[2*e+1];return a}return n}function k(e){return e.kept?e:(0,g.clone)(e)}e.s(["json",0,[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]],28245);var I=e.i(28245);e.s(["json",0,[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]],9470);var T=e.i(9470);e.s(["json",0,[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}]],82990);var C=e.i(82990);e.s(["json",0,[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}]],21690);var E=e.i(21690);e.s(["json",0,[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}]],67831);var $=e.i(67831);e.s(["json",0,[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}]],14304);var A=e.i(14304);e.s(["json",0,[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}]],22104);var R=e.i(22104);e.s(["json",0,[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}]],90091);var D=e.i(90091);e.s(["json",0,[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]],46207);var F=e.i(46207);e.s(["json",0,[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}]],95893);var O=e.i(95893);e.s(["json",0,[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}]],46722);var _=e.i(46722);e.s(["json",0,[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}]],49625);var M=e.i(49625);e.s(["json",0,[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}]],4179);var L=e.i(4179);e.s(["json",0,[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}]],72396);var z=e.i(72396);e.s(["json",0,[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}]],74440);var P=e.i(74440);e.s(["json",0,[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}]],35645);var B=e.i(35645);e.s(["json",0,[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}]],95414);var V=e.i(95414);e.s(["json",0,[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}]],76286);var W=e.i(76286);e.s(["json",0,[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}]],38464);var U=e.i(38464);class G{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[I,T,C,E,$,A,R,D,F,O,_,M,L,z,P,B,V,W,U].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e,t={}){let r=e.node,n=[],a=[],s=[],i=r.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?n.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):(null==t.input||0===t.input.length)&&s.push(e[t.name]),e),{}),o=[],l=[],u={},h={};null!=t&&(u=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));let p=Object.keys(i);p.forEach(e=>{let t=i[e];t.inputNames.forEach((e,r)=>{let[n,,a]=v(e),s=i[n];if(null!=s.outputs){let e=s.outputs.indexOf(a);if(-1!==e){let a=`${n}:${e}`;t.inputNames[r]=a}}t.inputs.push(s),s.children.push(t)})}),0===Object.keys(h).length?p.forEach(e=>{let t=i[e];0===t.children.length&&l.push(t)}):Object.keys(h).forEach(e=>{let[t]=v(e),r=i[t];null!=r&&(r.signatureKey=h[e],l.push(r))}),Object.keys(u).length>0?Object.keys(u).forEach(e=>{let[t]=v(e),r=i[t];r&&(r.signatureKey=u[e],o.push(r))}):o=n;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));let c={nodes:i,inputs:o,outputs:l,weights:a,placeholders:n,signature:t,functions:d};return s.length>0&&(c.initNodes=s),c}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){let t=d[e.op]||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.slice(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(r.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(r.attrParams=t.attrs.reduce((t,r)=>{let n,a=r.type;switch(r.type){case"string":void 0===(n=H(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(n=H(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"string[]":void 0===(n=er(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(n=er(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":void 0===(n=K(e.attr,r.tfName,r.defaultValue||0))&&r.tfDeprecatedName&&(n=K(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":void 0===(n=et(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(n=et(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":void 0===(n=j(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(n=j(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool[]":void 0===(n=ea(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(n=ea(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":void 0===(n=ee(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(n=ee(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape[]":void 0===(n=en(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(n=en(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":void 0===(n=Y(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(n=Y(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype[]":void 0===(n=J(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(n=J(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"func":void 0===(n=Z(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(n=Z(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw Error(`Unsupported param type: ${r.type} for op: ${e.op}`)}return t[r.name]={value:n,type:a},t},{})),r}mapFunction(e){let t=e.nodeDef,r=[],n={};null!=t&&(n=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&r.push(e[t.name]),e),{}));let a=[],s=[];e.signature.inputArg.forEach(e=>{let[t]=v(e.name),r={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:X(e.type),type:"dtype"}},children:[]};r.signatureKey=e.name,a.push(r),n[t]=r}),Object.keys(n).forEach(e=>{let t=n[e];t.inputNames.forEach((e,r)=>{let[a,,s]=v(e),i=n[a];if(null!=i.outputs){let e=i.outputs.indexOf(s);if(-1!==e){let n=`${a}:${e}`;t.inputNames[r]=n}}t.inputs.push(i),i.children.push(t)})});let i=e.ret;e.signature.outputArg.forEach(e=>{let[t,r]=v(i[e.name]),a=n[t];null!=a&&(a.defaultOutput=r,s.push(a))});let o=this.mapArgsToSignature(e);return{nodes:n,inputs:a,outputs:s,weights:r,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return null!=t&&(r=t[r]),{name:r,dtype:e.type}}}function q(e,t){let r=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){let t=(0,i.env)().global;if(void 0!==t.atob)return t.atob(e);if(void 0!==p.Buffer)return new p.Buffer(e,"base64").toString();throw Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?r:r.toLowerCase()}function H(e,t,r,n=!1){let a=e[t];return null!=a?q(a.s,n):r}function j(e,t,r){let n=e[t];return n?n.b:r}function K(e,t,r){let n=e[t]||{},a=null!=n.i?n.i:null!=n.f?n.f:r;return"number"==typeof a?a:parseInt(a,10)}function X(e){switch("string"==typeof e&&(e=a[e]),e){case a.DT_FLOAT:case a.DT_HALF:return"float32";case a.DT_INT32:case a.DT_INT64:case a.DT_INT8:case a.DT_UINT8:return"int32";case a.DT_BOOL:return"bool";case a.DT_DOUBLE:return"float32";case a.DT_STRING:return"string";case a.DT_COMPLEX64:case a.DT_COMPLEX128:return"complex64";default:return null}}function Z(e,t,r){let n=e[t];return n&&n.func?n.func.name:r}function Y(e,t,r){let n=e[t];return n&&n.type?X(n.type):r}function J(e,t,r){let n=e[t];return n&&n.list&&n.list.type?n.list.type.map(e=>X(e)):r}function Q(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"==typeof e.size?e.size:parseInt(e.size,10)):[]}function ee(e,t,r){let n=e[t];return n&&n.shape?Q(n.shape):r}function et(e,t,r){let n=e[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(e=>"number"==typeof e?e:parseInt(e,10)):r}function er(e,t,r,n=!1){let a=e[t];return a&&a.list&&a.list.s?a.list.s.map(e=>q(e,n)):r}function en(e,t,r){let n=e[t];return n&&n.list&&n.list.shape?n.list.shape.map(e=>Q(e)):r}function ea(e,t,r){let n=e[t];return n&&n.list&&n.list.b?n.list.b:r}var h=h,h=h;class es{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return b(e,this.tensorMap,this.context)}getAttr(e,t){let r=this.node.rawAttrs[e];if(null!=r.tensor)return b(e,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return K(this.node.rawAttrs,e,t);if(null!=r.s)return H(this.node.rawAttrs,e,t);if(null!=r.b)return j(this.node.rawAttrs,e,t);if(null!=r.shape)return ee(this.node.rawAttrs,e,t);if(null!=r.type)return Y(this.node.rawAttrs,e,t);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return et(this.node.rawAttrs,e,t);if(null!=r.list.s)return er(this.node.rawAttrs,e,t);if(null!=r.list.shape)return en(this.node.rawAttrs,e,t);if(null!=r.list.b)return ea(this.node.rawAttrs,e,t);if(null!=r.list.type)return J(this.node.rawAttrs,e,t)}return t}}e.s([],59835),e.i(59835);var ei=e.i(9670);e.s(["OP_SCOPE_SUFFIX",()=>ei.OP_SCOPE_SUFFIX,"abs",()=>ei.abs,"acos",()=>ei.acos,"acosh",()=>ei.acosh,"add",()=>ei.add,"addN",()=>ei.addN,"all",()=>ei.all,"any",()=>ei.any,"argMax",()=>ei.argMax,"argMin",()=>ei.argMin,"asin",()=>ei.asin,"asinh",()=>ei.asinh,"atan",()=>ei.atan,"atan2",()=>ei.atan2,"atanh",()=>ei.atanh,"avgPool",()=>ei.avgPool,"avgPool3d",()=>ei.avgPool3d,"basicLSTMCell",()=>ei.basicLSTMCell,"batchNorm",()=>ei.batchNorm,"batchNorm2d",()=>ei.batchNorm2d,"batchNorm3d",()=>ei.batchNorm3d,"batchNorm4d",()=>ei.batchNorm4d,"batchToSpaceND",()=>ei.batchToSpaceND,"bincount",()=>ei.bincount,"bitwiseAnd",()=>ei.bitwiseAnd,"booleanMaskAsync",()=>ei.booleanMaskAsync,"broadcastArgs",()=>ei.broadcastArgs,"broadcastTo",()=>ei.broadcastTo,"buffer",()=>ei.buffer,"cast",()=>ei.cast,"ceil",()=>ei.ceil,"clipByValue",()=>ei.clipByValue,"clone",()=>ei.clone,"complex",()=>ei.complex,"concat",()=>ei.concat,"concat1d",()=>ei.concat1d,"concat2d",()=>ei.concat2d,"concat3d",()=>ei.concat3d,"concat4d",()=>ei.concat4d,"conv1d",()=>ei.conv1d,"conv2d",()=>ei.conv2d,"conv2dTranspose",()=>ei.conv2dTranspose,"conv3d",()=>ei.conv3d,"conv3dTranspose",()=>ei.conv3dTranspose,"cos",()=>ei.cos,"cosh",()=>ei.cosh,"cosineWindow",()=>ei.cosineWindow,"cumprod",()=>ei.cumprod,"cumsum",()=>ei.cumsum,"denseBincount",()=>ei.denseBincount,"depthToSpace",()=>ei.depthToSpace,"depthwiseConv2d",()=>ei.depthwiseConv2d,"diag",()=>ei.diag,"dilation2d",()=>ei.dilation2d,"div",()=>ei.div,"divNoNan",()=>ei.divNoNan,"dot",()=>ei.dot,"dropout",()=>ei.dropout,"einsum",()=>ei.einsum,"elu",()=>ei.elu,"enclosingPowerOfTwo",()=>ei.enclosingPowerOfTwo,"ensureShape",()=>ei.ensureShape,"equal",()=>ei.equal,"erf",()=>ei.erf,"euclideanNorm",()=>ei.euclideanNorm,"exp",()=>ei.exp,"expandDims",()=>ei.expandDims,"expm1",()=>ei.expm1,"eye",()=>ei.eye,"fft",()=>ei.fft,"fill",()=>ei.fill,"floor",()=>ei.floor,"floorDiv",()=>ei.floorDiv,"fused",()=>ei.fused,"gather",()=>ei.gather,"gatherND",()=>ei.gatherND,"greater",()=>ei.greater,"greaterEqual",()=>ei.greaterEqual,"ifft",()=>ei.ifft,"imag",()=>ei.imag,"image",()=>ei.image,"inTopKAsync",()=>ei.inTopKAsync,"irfft",()=>ei.irfft,"isFinite",()=>ei.isFinite,"isInf",()=>ei.isInf,"isNaN",()=>ei.isNaN,"leakyRelu",()=>ei.leakyRelu,"less",()=>ei.less,"lessEqual",()=>ei.lessEqual,"linalg",()=>ei.linalg,"linspace",()=>ei.linspace,"localResponseNormalization",()=>ei.localResponseNormalization,"log",()=>ei.log,"log1p",()=>ei.log1p,"logSigmoid",()=>ei.logSigmoid,"logSoftmax",()=>ei.logSoftmax,"logSumExp",()=>ei.logSumExp,"logicalAnd",()=>ei.logicalAnd,"logicalNot",()=>ei.logicalNot,"logicalOr",()=>ei.logicalOr,"logicalXor",()=>ei.logicalXor,"losses",()=>ei.losses,"lowerBound",()=>ei.lowerBound,"matMul",()=>ei.matMul,"max",()=>ei.max,"maxPool",()=>ei.maxPool,"maxPool3d",()=>ei.maxPool3d,"maxPoolWithArgmax",()=>ei.maxPoolWithArgmax,"maximum",()=>ei.maximum,"mean",()=>ei.mean,"meshgrid",()=>ei.meshgrid,"min",()=>ei.min,"minimum",()=>ei.minimum,"mirrorPad",()=>ei.mirrorPad,"mod",()=>ei.mod,"moments",()=>ei.moments,"movingAverage",()=>ei.movingAverage,"mul",()=>ei.mul,"multiRNNCell",()=>ei.multiRNNCell,"multinomial",()=>ei.multinomial,"neg",()=>ei.neg,"norm",()=>ei.norm,"notEqual",()=>ei.notEqual,"oneHot",()=>ei.oneHot,"ones",()=>ei.ones,"onesLike",()=>ei.onesLike,"op",()=>ei.op,"outerProduct",()=>ei.outerProduct,"pad",()=>ei.pad,"pad1d",()=>ei.pad1d,"pad2d",()=>ei.pad2d,"pad3d",()=>ei.pad3d,"pad4d",()=>ei.pad4d,"pool",()=>ei.pool,"pow",()=>ei.pow,"prelu",()=>ei.prelu,"print",()=>ei.print,"prod",()=>ei.prod,"raggedGather",()=>ei.raggedGather,"raggedRange",()=>ei.raggedRange,"raggedTensorToTensor",()=>ei.raggedTensorToTensor,"rand",()=>ei.rand,"randomGamma",()=>ei.randomGamma,"randomNormal",()=>ei.randomNormal,"randomStandardNormal",()=>ei.randomStandardNormal,"randomUniform",()=>ei.randomUniform,"randomUniformInt",()=>ei.randomUniformInt,"range",()=>ei.range,"real",()=>ei.real,"reciprocal",()=>ei.reciprocal,"relu",()=>ei.relu,"relu6",()=>ei.relu6,"reshape",()=>ei.reshape,"reverse",()=>ei.reverse,"reverse1d",()=>ei.reverse1d,"reverse2d",()=>ei.reverse2d,"reverse3d",()=>ei.reverse3d,"reverse4d",()=>ei.reverse4d,"rfft",()=>ei.rfft,"round",()=>ei.round,"rsqrt",()=>ei.rsqrt,"scalar",()=>ei.scalar,"scatterND",()=>ei.scatterND,"searchSorted",()=>ei.searchSorted,"selu",()=>ei.selu,"separableConv2d",()=>ei.separableConv2d,"setdiff1dAsync",()=>ei.setdiff1dAsync,"sigmoid",()=>ei.sigmoid,"sign",()=>ei.sign,"signal",()=>ei.signal,"sin",()=>ei.sin,"sinh",()=>ei.sinh,"slice",()=>ei.slice,"slice1d",()=>ei.slice1d,"slice2d",()=>ei.slice2d,"slice3d",()=>ei.slice3d,"slice4d",()=>ei.slice4d,"softmax",()=>ei.softmax,"softplus",()=>ei.softplus,"spaceToBatchND",()=>ei.spaceToBatchND,"sparse",()=>ei.sparse,"sparseToDense",()=>ei.sparseToDense,"spectral",()=>ei.spectral,"split",()=>ei.split,"sqrt",()=>ei.sqrt,"square",()=>ei.square,"squaredDifference",()=>ei.squaredDifference,"squeeze",()=>ei.squeeze,"stack",()=>ei.stack,"step",()=>ei.step,"stridedSlice",()=>ei.stridedSlice,"string",()=>ei.string,"sub",()=>ei.sub,"sum",()=>ei.sum,"tan",()=>ei.tan,"tanh",()=>ei.tanh,"tensor",()=>ei.tensor,"tensor1d",()=>ei.tensor1d,"tensor2d",()=>ei.tensor2d,"tensor3d",()=>ei.tensor3d,"tensor4d",()=>ei.tensor4d,"tensor5d",()=>ei.tensor5d,"tensor6d",()=>ei.tensor6d,"tensorScatterUpdate",()=>ei.tensorScatterUpdate,"tile",()=>ei.tile,"topk",()=>ei.topk,"transpose",()=>ei.transpose,"truncatedNormal",()=>ei.truncatedNormal,"unique",()=>ei.unique,"unsortedSegmentSum",()=>ei.unsortedSegmentSum,"unstack",()=>ei.unstack,"upperBound",()=>ei.upperBound,"variable",()=>ei.variable,"where",()=>ei.where,"whereAsync",()=>ei.whereAsync,"zeros",()=>ei.zeros,"zerosLike",()=>ei.zerosLike],90802);var eo=e.i(90802),el=eo,eu=e.i(83654),eh=e.i(48012),ep=e.i(74647),ed=e.i(3116),ec=e.i(42130),ef=e.i(98976),em=e.i(33236),h=h;function eg(e,t,r=""){if("number"!=typeof e&&"number"!=typeof t){h.assert(e.length===t.length,()=>r+` Shapes ${e} and ${t} must match`);for(let n=0;n<e.length;n++){let a=e[n],s=t[n];h.assert(a<0||s<0||a===s,()=>r+` Shapes ${e} and ${t} must match`)}}}function ey(e){return!("number"==typeof e||e.some(e=>e<0))}function eb(e,t,r){let n=ex(e,r),a=!ey(n);if(a&&0===t.length)throw Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(a&&t.forEach(e=>{n=ex(e.shape,n)}),!ey(n))throw Error(`Non-fully-defined elementShape: ${n}`);return n}function ex(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let r=[];for(let n=0;n<e.length;++n){let a=e[n],s=t[n];if(a>=0&&s>=0&&a!==s)throw Error(`Incompatible shape during merge: ${e} vs. ${t}`);r[n]=a>=0?a:s}return r}class ev{constructor(e,t,r,n,a,s,i){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=n,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=(0,eu.scalar)(0),(0,o.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),eg(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,(0,o.keep)(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,r)=>this.write(e,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return(0,ef.tensor)([],[0].concat(this.elementShape));let r=this.readMany(e);return eg(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),(0,ec.stack)(r,0)}concat(e){if(e&&e!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return(0,ef.tensor)([],[0].concat(this.elementShape));let t=[];for(let e=0;e<this.size();e++)t.push(e);let r=this.readMany(t);return eg(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),(0,eh.concat)(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,(0,em.unstack)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0,n=e.map(e=>r+=e);if(r!==t.shape[0])throw Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=0===r?0:t.size/r,s=[];(0,o.tidy)(()=>{t=(0,ep.reshape)(t,[1,r,a]);for(let r=0;r<e.length;++r){let i=[0,0===r?0:n[r-1],0],o=[1,e[r],a];s[r]=(0,ep.reshape)((0,ed.slice)(t,i,o),this.elementShape)}return s});let i=[];for(let t=0;t<e.length;t++)i[t]=t;this.writeMany(i,s)}}class ew{get id(){return this.idTensor.id}constructor(e,t,r,n=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,null!=e&&e.forEach(e=>{if(r!==e.dtype)throw Error(`Invalid data types; op elements ${r}, but list elements ${e.dtype}`);eg(t,e.shape,"TensorList shape mismatch: "),(0,o.keep)(e)}),this.idTensor=(0,eu.scalar)(0),this.maxNumElements=n,(0,o.keep)(this.idTensor)}copy(){return new ew([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);eg(e,this.elementShape,"TensorList shape mismatch: ");let n=eb(this.elementShape,this.tensors,e);return(0,o.tidy)(()=>{let e=this.tensors.map(e=>(0,ep.reshape)(e,n));return(0,ec.stack)(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw Error("Trying to pop from an empty list.");let r=eb(this.elementShape,this.tensors,e),n=this.tensors.pop();return n.kept=!1,eg(n.shape,e,"TensorList shape mismatch: "),(0,ep.reshape)(n,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(eg(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw Error("Trying to push element into a full list.");(0,o.keep)(e),this.tensors.push(e)}resize(e){if(e<0)throw Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new ew([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw Error(`element at index ${e} is null.`);eg(this.tensors[e].shape,t,"TensorList shape mismatch: ");let n=eb(this.elementShape,this.tensors,t);return(0,ep.reshape)(this.tensors[e],n)}setItem(e,t){if(t.dtype!==this.elementDtype)throw Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);eg(this.elementShape,t.shape,"TensorList shape mismatch: "),(0,o.keep)(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);eg(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());let n=eb(this.elementShape,this.tensors,r);return 0===e.length?(0,ef.tensor)([],[0].concat(n)):(0,o.tidy)(()=>{let t=e.map(e=>(0,ep.reshape)(this.tensors[e],n));return(0,ec.stack)(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);eg(this.elementShape,t,"TensorList shape mismatch: ");let r=eb(this.elementShape,this.tensors,t);return 0===this.size()?(0,ef.tensor)([],[0].concat(r)):(0,o.tidy)(()=>{let e=this.tensors.map(e=>(0,ep.reshape)(e,r));return(0,eh.concat)(e,0)})}}let eS=async(e,t,r)=>{switch(e.op){case"If":case"StatelessIf":{let n=y("thenBranch",e,t,r),a=y("elseBranch",e,t,r),s=y("cond",e,t,r),i=y("args",e,t,r);if((await s.data())[0])return r.functionMap[n].executeFunctionAsync(i,r.tensorArrayMap,r.tensorListMap);return r.functionMap[a].executeFunctionAsync(i,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{let n=y("body",e,t,r),a=y("cond",e,t,r),s=y("args",e,t,r),i=await r.functionMap[a].executeFunctionAsync(s,r.tensorArrayMap,r.tensorListMap),o=s.map(e=>e.id),l=await i[0].data();i.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()});let u=s;for(;l[0];){let e=u,t=(u=await r.functionMap[n].executeFunctionAsync(u,r.tensorArrayMap,r.tensorListMap)).map(e=>e.id);e.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});let s=await r.functionMap[a].executeFunctionAsync(u,r.tensorArrayMap,r.tensorListMap);l=await s[0].data(),s.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return u}case"LoopCond":return[k(y("pred",e,t,r))];case"Switch":{let n=y("pred",e,t,r),a=y("data",e,t,r);return a.kept||(a=k(a)),(await n.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let n=e.inputNames.find(e=>void 0!==b(e,t,r));if(n)return[k(b(n,t,r))];return}case"Enter":{let n=y("frameName",e,t,r),a=y("tensor",e,t,r);return r.enterFrame(n),[k(a)]}case"Exit":{let n=y("tensor",e,t,r);return r.exitFrame(),[k(n)]}case"NextIteration":{let n=y("tensor",e,t,r);return r.nextIteration(),[k(n)]}case"TensorArrayV3":{let n=y("size",e,t,r),a=y("dtype",e,t,r),s=y("elementShape",e,t,r),i=y("dynamicSize",e,t,r),o=y("clearAfterRead",e,t,r),l=y("identicalElementShapes",e,t,r),u=new ev(y("name",e,t,r),a,n,s,l,i,o);return r.addTensorArray(u),[u.idTensor,(0,eu.scalar)(1)]}case"TensorArrayWriteV3":{let n=y("tensorArrayId",e,t,r),a=y("index",e,t,r),s=y("tensor",e,t,r),i=r.getTensorArray(n.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{let n=y("tensorArrayId",e,t,r),a=y("index",e,t,r);return[r.getTensorArray(n.id).read(a)]}case"TensorArrayGatherV3":{let n=y("tensorArrayId",e,t,r),a=y("indices",e,t,r),s=y("dtype",e,t,r);return[r.getTensorArray(n.id).gather(a,s)]}case"TensorArrayScatterV3":{let n=y("tensorArrayId",e,t,r),a=y("indices",e,t,r),s=y("tensor",e,t,r),i=r.getTensorArray(n.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{let n=y("tensorArrayId",e,t,r),a=r.getTensorArray(n.id),s=y("dtype",e,t,r);return[a.concat(s)]}case"TensorArraySplitV3":{let n=y("tensorArrayId",e,t,r),a=y("tensor",e,t,r),s=y("lengths",e,t,r),i=r.getTensorArray(n.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{let n=y("tensorArrayId",e,t,r),a=r.getTensorArray(n.id);return[(0,eu.scalar)(a.size(),"int32")]}case"TensorArrayCloseV3":{let n=y("tensorArrayId",e,t,r),a=r.getTensorArray(n.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let n=y("tensorListId",e,t,r),a=y("index",e,t,r),s=y("tensor",e,t,r),i=r.getTensorList(n.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{let n=y("tensorListId",e,t,r),a=y("index",e,t,r),s=y("elementShape",e,t,r),i=y("elementDType",e,t,r);return[r.getTensorList(n.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let n=y("indices",e,t,r),a=function(e,t,r,n){if(t.length!==e.shape[0])throw Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(null!=n&&-1!==n&&a>=n)throw Error(`Max index must be < array size (${a}  vs. ${n})`);let s=new ew([],r,e.dtype,n),i=(0,em.unstack)(e,0);return t.forEach((e,t)=>{s.setItem(e,i[t])}),s}(y("tensor",e,t,r),n,y("elementShape",e,t,r),y("numElements",e,t,r));return r.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=y("elementShape",e,t,r),a=y("elementDType",e,t,r),s=y("TensorListReserve"===e.op?"numElements":"maxNumElements",e,t,r),i=new ew([],n,a,"TensorListReserve"===e.op?-1:s);return r.addTensorList(i),[i.idTensor]}case"TensorListGather":{let n=y("tensorListId",e,t,r),a=y("indices",e,t,r),s=y("elementShape",e,t,r),i=y("elementDType",e,t,r);return[r.getTensorList(n.id).gather(a,i,s)]}case"TensorListStack":{let n=y("tensorListId",e,t,r),a=y("elementShape",e,t,r),s=y("elementDType",e,t,r),i=y("numElements",e,t,r);return[r.getTensorList(n.id).stack(a,s,i)]}case"TensorListFromTensor":{let n=function(e,t,r){let n=e.dtype;if(e.shape.length<1)throw Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==r)throw Error(`Invalid data types; op elements ${e.dtype}, but list elements ${r}`);return eg(e.shape.slice(1),t,"TensorList shape mismatch: "),new ew((0,em.unstack)(e),t,n)}(y("tensor",e,t,r),y("elementShape",e,t,r),y("elementDType",e,t,r));return r.addTensorList(n),[n.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let n=y("tensorListId",e,t,r),a=r.getTensorList(n.id),s=y("dtype",e,t,r),i=y("elementShape",e,t,r);return[a.concat(s,i)]}case"TensorListPushBack":{let n=y("tensorListId",e,t,r),a=y("tensor",e,t,r),s=r.getTensorList(n.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{let n=y("tensorListId",e,t,r),a=y("elementShape",e,t,r),s=y("elementDType",e,t,r);return[r.getTensorList(n.id).popBack(a,s)]}case"TensorListSplit":{let n=y("tensor",e,t,r),a=y("elementShape",e,t,r),s=function(e,t,r){let n=0,a=t.map(e=>n+=e);if(n!==e.shape[0])throw Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${e.shape}`);let s=ex(e.shape.slice(1),r),i=0===n?0:e.size/n,l=(0,o.tidy)(()=>{let r=[];e=(0,ep.reshape)(e,[1,n,i]);for(let n=0;n<t.length;++n){let o=[0,0===n?0:a[n-1],0],l=[1,t[n],i];r[n]=(0,ep.reshape)((0,ed.slice)(e,o,l),s)}return e.dispose(),r}),u=new ew([],r,e.dtype,t.length);for(let e=0;e<l.length;e++)u.setItem(e,l[e]);return u}(n,y("lengths",e,t,r),a);return r.addTensorList(s),[s.idTensor]}case"TensorListLength":{let n=y("tensorListId",e,t,r),a=r.getTensorList(n.id);return[(0,eu.scalar)(a.size(),"int32")]}case"TensorListResize":{let n=y("tensorListId",e,t,r),a=y("size",e,t,r),s=r.getTensorList(n.id).resize(a);return r.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var eN=eo;function ek(e,t,r){let[n,a]=y("fusedOps",e,t,r),s="biasadd"===n,i="prelu"===a,o=y("numArgs",e,t,r);if(s){if(i&&2!==o)throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&1!==o)throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if("fusedbatchnorm"===n)throw Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let l=y("strides",e,t,r),u=N(e,t,r),h=y("dataFormat",e,t,r).toUpperCase(),p=y("dilations",e,t,r),[d,c]=y("args",e,t,r);return s||(c=d,d=void 0),{stride:l,pad:u,dataFormat:h,dilations:p,biasArg:d,preluArg:c,activationFunc:a,leakyreluAlpha:y("leakyreluAlpha",e,t,r)}}var eI=eo,eT=eo;function eC(e,t,r){let n=y("boxes",e,t,r),a=y("scores",e,t,r),s=y("maxOutputSize",e,t,r),i=y("iouThreshold",e,t,r);return{boxes:n,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:y("scoreThreshold",e,t,r),softNmsSigma:y("softNmsSigma",e,t,r)}}let eE=async(e,t,r,n,a=eT)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:n,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=eC(e,t,r),h=await a.image.nonMaxSuppressionWithScoreAsync(n,s,i,o,l,u);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:n,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=eC(e,t,r),u=y("padToMaxOutputSize",e,t,r),h=await a.image.nonMaxSuppressionPaddedAsync(n,s,i,o,l,u);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:n,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=eC(e,t,r);return[await a.image.nonMaxSuppressionAsync(n,s,i,o,l)]}case"Where":{let n=a.cast(y("condition",e,t,r),"bool"),s=[await a.whereAsync(n)];return n.dispose(),s}case"ListDiff":return a.setdiff1dAsync(y("x",e,t,r),y("y",e,t,r));default:throw TypeError(`Node type ${e.op} is not implemented`)}};var e$=eo,eA=eo,h=h;class eR{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=(0,eu.scalar)(0),this.tensorMap=new Map,(0,o.keep)(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return eu.scalar(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let r=await e.data();return this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),(0,o.tidy)(()=>{let e=(0,em.unstack)(t),n=r.length,a=e.length;h.assert(n===a,()=>`The number of elements doesn't match, keys has ${n} elements, the values has ${a} elements.`);for(let t=0;t<n;t++){let n=r[t],a=e[t];(0,o.keep)(a),this.tensorMap.set(n,a)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let r=await e.data();return(0,o.tidy)(()=>{let e=[];for(let n=0;n<r.length;n++){let a=r[n],s=this.findWithDefault(a,t);e.push(s)}return(0,ec.stack)(e)})}findWithDefault(e,t){let r=this.tensorMap.get(e);return null!=r?r:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}let eD=async(e,t,r,n)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=n.getHashTableHandleByName(e.name);if(null!=a)return[a];{let a=new eR(y("keyDType",e,t,r),y("valueDType",e,t,r));return n.addHashTable(e.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let a=y("tableHandle",e,t,r,n),s=y("keys",e,t,r),i=y("values",e,t,r),o=n.getHashTableById(a.id);return[await o.import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let a=y("tableHandle",e,t,r,n),s=y("keys",e,t,r),i=y("defaultValue",e,t,r),o=n.getHashTableById(a.id);return[await o.find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=y("tableHandle",e,t,r,n);return[n.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};var eF=eo,eO=eo,e_=eo,eM=eo,eL=eo,ez=eo,h=h,eP=eo,eB=eo,eV=eo,eW=eo,eU=eo;function eG(e,t,r,n,a=o.tidy){let s=((e,t,r)=>{switch(e.category){case"arithmetic":return a(()=>((e,t,r,n=eo)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(y("a",e,t,r),y("b",e,t,r))];case"AddN":return[n.addN(y("tensors",e,t,r))];case"FloorMod":case"Mod":return[n.mod(y("a",e,t,r),y("b",e,t,r))];case"Mul":return[n.mul(y("a",e,t,r),y("b",e,t,r))];case"RealDiv":case"Div":return[n.div(y("a",e,t,r),y("b",e,t,r))];case"DivNoNan":return[n.divNoNan(y("a",e,t,r),y("b",e,t,r))];case"FloorDiv":return[n.floorDiv(y("a",e,t,r),y("b",e,t,r))];case"Sub":return[n.sub(y("a",e,t,r),y("b",e,t,r))];case"Minimum":return[n.minimum(y("a",e,t,r),y("b",e,t,r))];case"Maximum":return[n.maximum(y("a",e,t,r),y("b",e,t,r))];case"Pow":return[n.pow(y("a",e,t,r),y("b",e,t,r))];case"SquaredDifference":return[n.squaredDifference(y("a",e,t,r),y("b",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"basic_math":return a(()=>((e,t,r,n=el)=>{switch(e.op){case"Abs":case"ComplexAbs":return[n.abs(y("x",e,t,r))];case"Acos":return[n.acos(y("x",e,t,r))];case"Acosh":return[n.acosh(y("x",e,t,r))];case"Asin":return[n.asin(y("x",e,t,r))];case"Asinh":return[n.asinh(y("x",e,t,r))];case"Atan":return[n.atan(y("x",e,t,r))];case"Atan2":return[n.atan2(y("x",e,t,r),y("y",e,t,r))];case"Atanh":return[n.atanh(y("x",e,t,r))];case"Ceil":return[n.ceil(y("x",e,t,r))];case"Complex":return[n.complex(y("real",e,t,r),y("imag",e,t,r))];case"Cos":return[n.cos(y("x",e,t,r))];case"Cosh":return[n.cosh(y("x",e,t,r))];case"Elu":return[n.elu(y("x",e,t,r))];case"Erf":return[n.erf(y("x",e,t,r))];case"Exp":return[n.exp(y("x",e,t,r))];case"Expm1":return[n.expm1(y("x",e,t,r))];case"Floor":return[n.floor(y("x",e,t,r))];case"Log":return[n.log(y("x",e,t,r))];case"Log1p":return[n.log1p(y("x",e,t,r))];case"Imag":return[n.imag(y("x",e,t,r))];case"Neg":return[n.neg(y("x",e,t,r))];case"Reciprocal":return[n.reciprocal(y("x",e,t,r))];case"Real":return[n.real(y("x",e,t,r))];case"Relu":return[n.relu(y("x",e,t,r))];case"Round":return[n.round(y("x",e,t,r))];case"Selu":return[n.selu(y("x",e,t,r))];case"Sigmoid":return[n.sigmoid(y("x",e,t,r))];case"Sin":return[n.sin(y("x",e,t,r))];case"Sign":return[n.sign(y("x",e,t,r))];case"Sinh":return[n.sinh(y("x",e,t,r))];case"Softplus":return[n.softplus(y("x",e,t,r))];case"Sqrt":return[n.sqrt(y("x",e,t,r))];case"Square":return[n.square(y("x",e,t,r))];case"Tanh":return[n.tanh(y("x",e,t,r))];case"Tan":return[n.tan(y("x",e,t,r))];case"ClipByValue":return[n.clipByValue(y("x",e,t,r),y("clipValueMin",e,t,r),y("clipValueMax",e,t,r))];case"Relu6":return[n.relu6(y("x",e,t,r))];case"Rsqrt":return[n.rsqrt(b(e.inputNames[0],t,r))];case"LeakyRelu":return[n.leakyRelu(y("x",e,t,r),y("alpha",e,t,r))];case"Prelu":return[n.prelu(y("x",e,t,r),y("alpha",e,t,r))];case"IsNan":return[n.isNaN(b(e.inputNames[0],t,r))];case"IsInf":return[n.isInf(b(e.inputNames[0],t,r))];case"IsFinite":return[n.isFinite(b(e.inputNames[0],t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"control":return eS(e,t,r);case"convolution":return a(()=>((e,t,r,n=eN)=>{switch(e.op){case"Conv1D":{let a=y("stride",e,t,r),s=y("pad",e,t,r),i=y("dataFormat",e,t,r).toUpperCase(),o=y("dilation",e,t,r);return[n.conv1d(y("x",e,t,r),y("filter",e,t,r),a,s,i,o)]}case"Conv2D":{let a=y("strides",e,t,r),s=N(e,t,r),i=y("dataFormat",e,t,r).toUpperCase(),o=y("dilations",e,t,r);return[n.conv2d(y("x",e,t,r),y("filter",e,t,r),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:h,leakyreluAlpha:p}=ek(e,t,r);return[n.fused.conv2d({x:y("x",e,t,r),filter:y("filter",e,t,r),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:h,preluActivationWeights:u,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:h,leakyreluAlpha:p}=ek(e,t,r);return[n.fused.depthwiseConv2d({x:y("x",e,t,r),filter:y("filter",e,t,r),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:h,preluActivationWeights:u,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=y("outputShape",e,t,r),s=y("strides",e,t,r),i=N(e,t,r);return[n.conv2dTranspose(y("x",e,t,r),y("filter",e,t,r),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=y("strides",e,t,r),s=N(e,t,r),i=y("dilations",e,t,r),o=y("dataFormat",e,t,r).toUpperCase();return[n.depthwiseConv2d(y("input",e,t,r),y("filter",e,t,r),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let a=y("strides",e,t,r),s=y("pad",e,t,r),i=y("dataFormat",e,t,r).toUpperCase(),o=y("dilations",e,t,r);return[n.conv3d(y("x",e,t,r),y("filter",e,t,r),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let a=y("strides",e,t,r),s=y("pad",e,t,r),i=y("kernelSize",e,t,r);return[n.avgPool(y("x",e,t,r),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{let a=y("strides",e,t,r),s=y("pad",e,t,r),i=y("kernelSize",e,t,r);return[n.maxPool(y("x",e,t,r),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{let a=y("strides",e,t,r),s=y("pad",e,t,r),i=y("kernelSize",e,t,r),o=y("includeBatchInIndex",e,t,r),{result:l,indexes:u}=n.maxPoolWithArgmax(y("x",e,t,r),[i[1],i[2]],[a[1],a[2]],s,o);return[l,u]}case"AvgPool3D":{let a=y("strides",e,t,r),s=y("pad",e,t,r),i=y("kernelSize",e,t,r);return[n.avgPool3d(y("x",e,t,r),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{let a=y("strides",e,t,r),s=y("pad",e,t,r),i=y("kernelSize",e,t,r);return[n.maxPool3d(y("x",e,t,r),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{let a=y("strides",e,t,r),s=y("pad",e,t,r),i=y("dilations",e,t,r),o=a[1],l=a[2],u=i[1],h=i[2];return[n.dilation2d(y("x",e,t,r),y("filter",e,t,r),[o,l],s,[u,h],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"creation":return a(()=>((e,t,r,n=eI)=>{switch(e.op){case"Fill":{let a=y("shape",e,t,r),s=y("dtype",e,t,r),i=y("value",e,t,r);return[n.fill(a,i,s)]}case"LinSpace":{let a=y("start",e,t,r),s=y("stop",e,t,r),i=y("num",e,t,r);return[n.linspace(a,s,i)]}case"Multinomial":{let a=y("logits",e,t,r),s=y("numSamples",e,t,r),i=y("seed",e,t,r);return[n.multinomial(a,s,i)]}case"OneHot":{let a=y("indices",e,t,r),s=y("depth",e,t,r),i=y("onValue",e,t,r),o=y("offValue",e,t,r),l=y("dtype",e,t,r);return[n.oneHot(a,s,i,o,l)]}case"Ones":return[n.ones(y("shape",e,t,r),y("dtype",e,t,r))];case"OnesLike":return[n.onesLike(y("x",e,t,r))];case"RandomStandardNormal":return[n.randomStandardNormal(y("shape",e,t,r),y("dtype",e,t,r),y("seed",e,t,r))];case"RandomUniform":return[n.randomUniform(y("shape",e,t,r),y("minval",e,t,r),y("maxval",e,t,r),y("dtype",e,t,r))];case"RandomUniformInt":return[n.randomUniformInt(y("shape",e,t,r),y("minval",e,t,r),y("maxval",e,t,r),y("seed",e,t,r))];case"Range":{let a=y("start",e,t,r),s=y("stop",e,t,r),i=y("step",e,t,r);return[n.range(a,s,i,y("dtype",e,t,r))]}case"TruncatedNormal":{let a=y("shape",e,t,r),s=y("mean",e,t,r),i=y("stdDev",e,t,r),o=y("seed",e,t,r);return[n.truncatedNormal(a,s,i,y("dtype",e,t,r),o)]}case"Zeros":return[n.zeros(y("shape",e,t,r),y("dtype",e,t,r))];case"ZerosLike":return[n.zerosLike(y("x",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"dynamic":return eE(e,t,r);case"evaluation":return a(()=>((e,t,r,n=e$)=>{switch(e.op){case"LowerBound":{let a=y("sortedSequence",e,t,r),s=y("values",e,t,r);return[n.lowerBound(a,s)]}case"TopKV2":{let a=y("x",e,t,r),s=y("k",e,t,r),i=y("sorted",e,t,r),o=n.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{let a=y("sortedSequence",e,t,r),s=y("values",e,t,r);return[n.upperBound(a,s)]}case"Unique":{let a=y("x",e,t,r),s=n.unique(a);return[s.values,s.indices]}case"UniqueV2":{let a=y("x",e,t,r),s=y("axis",e,t,r),i=n.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"image":return a(()=>((e,t,r,n=eF)=>{switch(e.op){case"ResizeBilinear":{let a=y("images",e,t,r),s=y("size",e,t,r),i=y("alignCorners",e,t,r),o=y("halfPixelCenters",e,t,r);return[n.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let a=y("images",e,t,r),s=y("size",e,t,r),i=y("alignCorners",e,t,r),o=y("halfPixelCenters",e,t,r);return[n.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{let a=y("image",e,t,r),s=y("boxes",e,t,r),i=y("boxInd",e,t,r),o=y("cropSize",e,t,r),l=y("method",e,t,r),u=y("extrapolationValue",e,t,r);return[n.image.cropAndResize(a,s,i,o,l,u)]}case"ImageProjectiveTransformV3":{let a=y("images",e,t,r),s=y("transforms",e,t,r),i=y("outputShape",e,t,r),o=y("fillValue",e,t,r),l=y("interpolation",e,t,r),u=y("fillMode",e,t,r);return[n.image.transform(a,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"graph":return a(()=>((e,t,r,n=eA)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=y("default",e,t,r);return[b(e.name,t,r)||a];case"Placeholder":return[b(e.name,t,r)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[k(y("x",e,t,r))];case"IdentityN":return y("x",e,t,r).map(e=>k(e));case"Shape":return[n.tensor1d(y("x",e,t,r).shape,"int32")];case"ShapeN":return y("x",e,t,r).map(e=>n.tensor1d(e.shape));case"Size":return[n.scalar(y("x",e,t,r).size,"int32")];case"Rank":return[n.scalar(y("x",e,t,r).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":let s=y("x",e,t,r),i=y("data",e,t,r),o=y("message",e,t,r),l=y("summarize",e,t,r);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"logical":return a(()=>((e,t,r,n=eO)=>{switch(e.op){case"Equal":return[n.equal(y("a",e,t,r),y("b",e,t,r))];case"NotEqual":return[n.notEqual(y("a",e,t,r),y("b",e,t,r))];case"Greater":return[n.greater(y("a",e,t,r),y("b",e,t,r))];case"GreaterEqual":return[n.greaterEqual(y("a",e,t,r),y("b",e,t,r))];case"Less":return[n.less(y("a",e,t,r),y("b",e,t,r))];case"LessEqual":return[n.lessEqual(y("a",e,t,r),y("b",e,t,r))];case"LogicalAnd":return[n.logicalAnd(y("a",e,t,r),y("b",e,t,r))];case"LogicalNot":return[n.logicalNot(y("a",e,t,r))];case"LogicalOr":return[n.logicalOr(y("a",e,t,r),y("b",e,t,r))];case"Select":case"SelectV2":return[n.where(y("condition",e,t,r),y("a",e,t,r),y("b",e,t,r))];case"BitwiseAnd":return[n.bitwiseAnd(y("a",e,t,r),y("b",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"matrices":return a(()=>((e,t,r,n=e_)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(y("a",e,t,r),y("b",e,t,r),y("transposeA",e,t,r),y("transposeB",e,t,r))];case"Einsum":return[n.einsum(y("equation",e,t,r),...y("tensors",e,t,r))];case"Transpose":return[n.transpose(y("x",e,t,r),y("perm",e,t,r))];case"_FusedMatMul":let[a,s]=y("fusedOps",e,t,r),i="prelu"===s,o=y("numArgs",e,t,r),l=y("leakyreluAlpha",e,t,r);if("biasadd"===a){if(i&&2!==o)throw Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==o)throw Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,h]=y("args",e,t,r);return[n.fused.matMul({a:y("a",e,t,r),b:y("b",e,t,r),transposeA:y("transposeA",e,t,r),transposeB:y("transposeB",e,t,r),bias:u,activation:s,preluActivationWeights:h,leakyreluAlpha:l})];case"MatrixBandPart":return[n.linalg.bandPart(y("a",e,t,r),y("numLower",e,t,r),y("numUpper",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"normalization":return a(()=>((e,t,r,n=eM)=>{switch(e.op){case"EuclideanNorm":return[n.euclideanNorm(y("x",e,t,r),y("axis",e,t,r),y("keepDims",e,t,r))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[n.batchNorm(y("x",e,t,r),y("mean",e,t,r),y("variance",e,t,r),y("offset",e,t,r),y("scale",e,t,r),y("epsilon",e,t,r))];case"LRN":return[n.localResponseNormalization(y("x",e,t,r),y("radius",e,t,r),y("bias",e,t,r),y("alpha",e,t,r),y("beta",e,t,r))];case"Softmax":return[n.softmax(y("x",e,t,r))];case"LogSoftmax":return[n.logSoftmax(y("x",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"ragged":return a(()=>((e,t,r,n=eL)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:s}=n.raggedGather(y("paramsNestedSplits",e,t,r),y("paramsDenseValues",e,t,r),y("indices",e,t,r),y("outputRaggedRank",e,t,r));return a.concat(s)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:s}=n.raggedRange(y("starts",e,t,r),y("limits",e,t,r),y("splits",e,t,r));return[a,s]}case"RaggedTensorToTensor":return[n.raggedTensorToTensor(y("shape",e,t,r),y("values",e,t,r),y("defaultValue",e,t,r),y("rowPartitionTensors",e,t,r),y("rowPartitionTypes",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"reduction":return a(()=>((e,t,r,n=ez)=>{switch(e.op){case"Max":{let a=y("axis",e,t,r),s=y("keepDims",e,t,r);return[n.max(y("x",e,t,r),a,s)]}case"Mean":{let a=y("axis",e,t,r),s=y("keepDims",e,t,r);return[n.mean(y("x",e,t,r),a,s)]}case"Min":{let a=y("axis",e,t,r),s=y("keepDims",e,t,r);return[n.min(y("x",e,t,r),a,s)]}case"Sum":{let a=y("axis",e,t,r),s=y("keepDims",e,t,r);return[n.sum(y("x",e,t,r),a,s)]}case"All":{let a=y("axis",e,t,r),s=y("keepDims",e,t,r);return[n.all(y("x",e,t,r),a,s)]}case"Any":{let a=y("axis",e,t,r),s=y("keepDims",e,t,r);return[n.any(y("x",e,t,r),a,s)]}case"ArgMax":{let a=y("axis",e,t,r);return[n.argMax(y("x",e,t,r),a)]}case"ArgMin":{let a=y("axis",e,t,r);return[n.argMin(y("x",e,t,r),a)]}case"Prod":{let a=y("axis",e,t,r),s=y("keepDims",e,t,r);return[n.prod(y("x",e,t,r),a,s)]}case"Cumprod":{let a=y("axis",e,t,r),s=y("exclusive",e,t,r),i=y("reverse",e,t,r);return[n.cumprod(y("x",e,t,r),a,s,i)]}case"Cumsum":{let a=y("axis",e,t,r),s=y("exclusive",e,t,r),i=y("reverse",e,t,r);return[n.cumsum(y("x",e,t,r),a,s,i)]}case"Bincount":let a=y("x",e,t,r),s=y("weights",e,t,r),i=y("size",e,t,r);return[n.bincount(a,s,i)];case"DenseBincount":{let a=y("x",e,t,r),s=y("weights",e,t,r),i=y("size",e,t,r),o=y("binaryOutput",e,t,r);return[n.denseBincount(a,s,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"slice_join":return a(()=>((e,t,r,n=eP)=>{switch(e.op){case"ConcatV2":case"Concat":{let a=y("n",e,t,r),s=y("axis",e,t,r),i=y("tensors",e,t,r);return i=i.slice(0,a),[n.concat(i,s)]}case"Gather":{let a=y("x",e,t,r),s=y("indices",e,t,r);return[n.gather(a,n.cast(s,"int32"),0)]}case"GatherV2":{let a=y("axis",e,t,r),s=y("batchDims",e,t,r),i=y("x",e,t,r),o=y("indices",e,t,r);return[n.gather(i,n.cast(o,"int32"),a,s)]}case"Reverse":{let a=y("dims",e,t,r),s=[];for(let e=0;e<a.length;e++)a[e]&&s.push(e);let i=y("x",e,t,r);return[n.reverse(i,s)]}case"ReverseV2":{let a=y("axis",e,t,r),s=y("x",e,t,r);return[n.reverse(s,a)]}case"Slice":{let a=y("begin",e,t,r),s=y("size",e,t,r);return[n.slice(y("x",e,t,r),a,s)]}case"StridedSlice":{let a=y("begin",e,t,r),s=y("end",e,t,r),i=y("strides",e,t,r),o=y("beginMask",e,t,r),l=y("endMask",e,t,r),u=y("ellipsisMask",e,t,r),h=y("newAxisMask",e,t,r),p=y("shrinkAxisMask",e,t,r),d=y("x",e,t,r);return[n.stridedSlice(d,a,s,i,o,l,u,h,p)]}case"Pack":return(0,o.tidy)(()=>{let a=y("axis",e,t,r),s=y("tensors",e,t,r),i=s[0].shape,o=n.squeeze(s[0]).shape,l=s.map(e=>{let t=h.arraysEqual(e.shape,i);if(!t&&!h.arraysEqual(n.squeeze(e).shape,o))throw Error("the input tensors shape does not match");return t?e:n.reshape(e,i)});return[n.stack(l,a)]});case"Unpack":{let a=y("axis",e,t,r),s=y("tensor",e,t,r);return n.unstack(s,a)}case"Tile":{let a=y("reps",e,t,r);return[n.tile(y("x",e,t,r),a)]}case"Split":case"SplitV":{let a=y("axis",e,t,r),s=y("numOrSizeSplits",e,t,r),i=y("x",e,t,r);return n.split(i,s,a)}case"ScatterNd":{let a=y("indices",e,t,r),s=y("values",e,t,r),i=y("shape",e,t,r);return[n.scatterND(a,s,i)]}case"GatherNd":{let a=y("x",e,t,r),s=y("indices",e,t,r);return[n.gatherND(a,s)]}case"SparseToDense":{let a=y("sparseIndices",e,t,r),s=y("outputShape",e,t,r),i=y("sparseValues",e,t,r),o=y("defaultValue",e,t,r);return[n.sparseToDense(a,i,s,i.dtype===o.dtype?o:n.cast(o,i.dtype))]}case"TensorScatterUpdate":{let a=y("indices",e,t,r),s=y("values",e,t,r),i=y("tensor",e,t,r);return[n.tensorScatterUpdate(i,a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"sparse":return a(()=>((e,t,r,n=eB)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=n.sparse.sparseFillEmptyRows(y("indices",e,t,r),y("values",e,t,r),y("denseShape",e,t,r),y("defaultValue",e,t,r));return[a,s,i,o]}case"SparseReshape":{let{outputIndices:a,outputShape:s}=n.sparse.sparseReshape(y("inputIndices",e,t,r),y("inputShape",e,t,r),y("newShape",e,t,r));return[a,s]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(y("data",e,t,r),y("indices",e,t,r),y("segmentIds",e,t,r))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(y("data",e,t,r),y("indices",e,t,r),y("segmentIds",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"spectral":return a(()=>((e,t,r,n=eV)=>{switch(e.op){case"FFT":return[n.fft(y("x",e,t,r))];case"IFFT":return[n.ifft(y("x",e,t,r))];case"RFFT":return[n.rfft(y("x",e,t,r))];case"IRFFT":return[n.irfft(y("x",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"string":return a(()=>((e,t,r,n=eW)=>{switch(e.op){case"StaticRegexReplace":return[n.string.staticRegexReplace(y("input",e,t,r),y("pattern",e,t,r),y("rewrite",e,t,r),y("replaceGlobal",e,t,r))];case"StringNGrams":{let{nGrams:a,nGramsSplits:s}=n.string.stringNGrams(y("data",e,t,r),y("dataSplits",e,t,r),y("separator",e,t,r),y("nGramWidths",e,t,r),y("leftPad",e,t,r),y("rightPad",e,t,r),y("padWidth",e,t,r),y("preserveShortSequences",e,t,r));return[a,s]}case"StringSplit":{let{indices:a,values:s,shape:i}=n.string.stringSplit(y("input",e,t,r),y("delimiter",e,t,r),y("skipEmpty",e,t,r));return[a,s,i]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(y("input",e,t,r),y("numBuckets",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"transformation":return a(()=>((e,t,r,n=eU)=>{switch(e.op){case"Cast":return[n.cast(y("x",e,t,r),y("dtype",e,t,r))];case"ExpandDims":{let a=y("axis",e,t,r);return[n.expandDims(y("x",e,t,r),a)]}case"Squeeze":{let a=y("axis",e,t,r);return[n.squeeze(y("x",e,t,r),a)]}case"Reshape":return[n.reshape(y("x",e,t,r),y("shape",e,t,r))];case"EnsureShape":return[n.ensureShape(y("x",e,t,r),y("shape",e,t,r))];case"MirrorPad":return[n.mirrorPad(y("x",e,t,r),y("padding",e,t,r),y("mode",e,t,r))];case"PadV2":case"Pad":return[n.pad(y("x",e,t,r),y("padding",e,t,r),y("constantValue",e,t,r))];case"SpaceToBatchND":{let a=y("blockShape",e,t,r),s=y("paddings",e,t,r);return[n.spaceToBatchND(y("x",e,t,r),a,s)]}case"BatchToSpaceND":{let a=y("blockShape",e,t,r),s=y("crops",e,t,r);return[n.batchToSpaceND(y("x",e,t,r),a,s)]}case"DepthToSpace":{let a=y("blockSize",e,t,r),s=y("dataFormat",e,t,r).toUpperCase();return[n.depthToSpace(y("x",e,t,r),a,s)]}case"BroadcastTo":return[n.broadcastTo(y("x",e,t,r),y("shape",e,t,r))];case"BroadcastArgs":return[n.broadcastArgs(y("s0",e,t,r),y("s1",e,t,r))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,r));case"hash_table":return eD(e,t,r,n);case"custom":let s=d[e.op];if(s&&s.customExecutor)return s.customExecutor(new es(e,t,r));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,r);return h.isPromise(s)?s.then(e=>[].concat(e)):[].concat(s)}class eq{constructor(e={},t={},r={},n={},a){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=n,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function eH(e,t,r,n){let a=new Set,s=[],i=null,o=null,l=new Set,u=new Set(Object.keys(e).map(e=>S(e)[0])),h=new Set((n=n||[]).map(e=>S(e.name)[0])),p=[...t];for(;p.length>0;){var d,c;let e=p.pop();if((eY(e)||(d=e,eX.has(d.op))||(c=e,eZ.has(c.op)))&&null==i&&(o=(i=e).children.map(e=>e.name).filter(e=>a.has(e))),a.add(e.name),!(null!=r[e.name]||u.has(e.name)||h.has(e.name))){if(0===e.inputs.length){s.push(e.name);continue}e.inputs.forEach(e=>{l.has(e.name)||(l.add(e.name),p.push(e))})}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}class ej extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}let eK=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),eX=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),eZ=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function eY(e){return eK.has(e.op)}class eJ{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new eJ(e.functions[t],this)})}getCompilationKey(e,t){let r=e.map(e=>e.name).sort(),n=t.map(e=>e.name).sort();return r.join(this.SEPARATOR)+"--"+n.join(this.SEPARATOR)}compile(e,t){let r=eH(e,t,this.weightMap,this._initNodes),{missingInputs:n,dynamicNode:a,syncInputs:s}=r;if(null!=a)throw Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(n.length>0){let r=t.map(e=>e.name),a=Object.keys(e);throw Error(`Cannot compute the outputs [${r}] from the provided inputs [${a}]. Missing the following inputs: [${n}]`)}let i=function(e,t){let{usedNodes:r,inputs:n}=t,a=Object.keys(n).map(e=>S(e)[0]).map(t=>e.nodes[t]),s=e.initNodes||[],i=e=>r.has("string"==typeof e?e:e.name);function o(e){return[...new Map(e.map(e=>[e.name,e])).values()]}let l=o([...a,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),h=new Map(u.map(e=>[e.name,e])),p={};for(let e of u)for(let t of(p[e.name]=p[e.name]||0,e.children))i(t)||(p[t.name]=1/0),p[t.name]=(p[t.name]||0)+1;let d=Object.entries(p).filter(([,e])=>0===e).map(([e])=>e),c=[...d];for(;d.length>0;){let e=d.pop();for(let t of h.get(e).children.filter(i))0==--p[t.name]&&(c.push(t.name),d.push(t.name))}let f=function(e,t){let r=new Map(e.map(e=>[e.name,e])),n=t.map(e=>e.name),a=new Set(n);for(;n.length>0;){let e=n.pop();for(let t of r.get(e).children)!r.has(t.name)||a.has(t.name)||(a.add(t.name),n.push(t.name))}return e.filter(e=>a.has(e.name))}(c.map(e=>h.get(e)),l);return function(e,t){let r=new Map(e.map((e,t)=>[e.name,t])),n=new Set(t.map(e=>e.name)),a=e=>n.has("string"==typeof e?e:e.name),s=new Set(e.map(e=>e.name)),i=e=>s.has("string"==typeof e?e:e.name);for(let t of e){for(let e of t.children.filter(i)){if(!r.has(e.name))throw new ej(`Child ${e.name} of node ${t.name} is unreachable.`);if(r.get(t.name)>r.get(e.name))throw new ej(`Node ${t.name} is scheduled to run after its child ${e.name}.`)}if(!a(t))for(let e of t.inputs){if(!r.has(e.name))throw new ej(`Input ${e.name} of node ${t.name} is unreachable.`);if(r.get(e.name)>r.get(t.name))throw new ej(`Node ${t.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}(this.graph,r),o=function(e){let t=new Map(e.map((e,t)=>[e.name,t])),r=Number.MAX_SAFE_INTEGER,n=e.map((e,t)=>eY(e)?r:t),a=e=>{let r=n[t.get(e.name)];return null==r?-1:r},s=e.map((e,t)=>e.children.map(a).reduce((e,t)=>Math.max(e,t),n[t])),i=new Map;for(let t=0;t<e.length;++t){let n=s[t];if(n===r)continue;let a=e[t],o=e[n];i.has(o.name)||i.set(o.name,[]),i.get(o.name).push(a)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;let t=e.clone();return(0,o.keep)(t),t}cloneTensorList(e){return e?e.map(e=>this.cloneAndKeepTensor(e)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([e,t])=>[e,this.cloneTensorList(t)]))}execute(e,t){this.disposeIntermediateTensors();let r=Object.keys(e=this.mapInputs(e)).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let n=r.map(e=>this.graph.nodes[S(e)[0]]),a=t.map(e=>S(e)[0]),s=new Set(a),l=a.map(e=>this.graph.nodes[e]);0===l.length&&(l=this._outputs);let u=this.getCompilationKey(n,l),p=this.compiledMap.get(u);null==p&&(p=this.compile(e,l),this.compiledMap.set(u,p));try{this.keepIntermediateTensors=(0,i.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}let d={},c={};return(0,o.tidy)(()=>{let r=new eq(this.weightMap,d,c,this.functionExecutorMap,this.parseNodeNameCache),n=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(t=>{let[a,s]=S(t,r),i=[];i[s]=e[t],n[a]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[a]=this.cloneTensorList(i))});let a=this.getFrozenTensorIds(n),{orderedNodes:i,nodeLiveUntilMap:o}=p;for(let e of i){if(n[e.name])continue;let t=eG(e,n,r,this._resourceManager);if(h.isPromise(t))throw Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);n[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,n,r,a,s,o.get(e.name))}return null==this.parent&&r.dispose(a),t.map(e=>b(e,n,r))})}getFrozenTensorIds(e){return new Set([].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id))))}checkTensorForDisposal(e,t,r,n,a,s,i){if(!(eY(t)||s.has(e))){for(let n of r[e])null!=n&&(i[n.id]=(i[n.id]||0)+t.children.length);for(let e of t.inputs){if(eY(e))continue;let t=x(e.name,r,n);if(null!=t)for(let e of t){if(!e||e.kept||a.has(e.id))continue;let t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,r,n,a,s){if(!eY(e)&&null!=s){for(let e of s)if(!(eY(e)||a.has(e.name)))for(let a of x(e.name,t,r))!a||a.kept||n.has(a.id)||a.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,r=!1,n={},a={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=(0,i.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}let s=new eq(this.weightMap,n,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(e,s,t,r),l=t.map(e=>b(e,o,s)),u=new Set([...l.map(e=>e.id),...Object.keys(e).map(t=>e[t].id),...this.weightIds]);return Object.values(o).forEach(e=>{e.forEach(e=>{!e||e.isDisposed||u.has(e.id)||e.dispose()})}),null==this.parent&&s.dispose(u),l}async executeFunctionAsync(e,t,r){let n=e.reduce((e,t,r)=>(e[this.inputs[r].name]=t,e),{});return this._executeAsync(n,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,n){let a=Object.keys(e),s=a.map(e=>this.graph.nodes[S(e)[0]]),i=r.map(e=>S(e)[0]),o=new Set(i),l=i.map(e=>this.graph.nodes[e]);0===l.length&&(l=this._outputs);let{usedNodes:u,missingInputs:h,dynamicNode:p,syncInputs:d}=eH(e,l,this.weightMap,this._initNodes),c=[...s,...this.graph.weights,...this._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{let[r,n]=S(t),a=[];a[n]=e[t],f[r]=a});let m={},g=this.getFrozenTensorIds(f),y={};for(;c.length>0;){let e=this.processStack(s,c,t,f,y,g,o,m,u);await Promise.all(e)}null!=p||n||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let x=l.filter(e=>!eY(e)&&!b(e.name,f,t)).map(e=>e.name);if(x.length>0){let e="";throw null!=p&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),Error(`Cannot compute the outputs [${x}] from the provided inputs [${a}]. Consider providing the following inputs: [${h}]. ${e}`)}return f}processStack(e,t,r,n,a,s,i,o,l){let u=[];for(;t.length>0;){let e=t.pop();r.currentContext=e.contexts;let p="";if("Enter"===e.node.op&&y("isConstant",e.node,n,r)&&([p]=v(e.node.name,r)),null==n[e.node.name]){let d=eG(e.node,n,r,this._resourceManager);p||([p]=v(e.node.name,r));let c=r.currentContext;h.isPromise(d)?u.push(d.then(u=>(n[p]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(u)),r.currentContext=c,this.checkTensorForDisposal(p,e.node,n,r,s,i,o),this.processChildNodes(e.node,t,r,n,a,l),u))):(n[p]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(d)),this.checkTensorForDisposal(p,e.node,n,r,s,i,o),this.processChildNodes(e.node,t,r,n,a,l))}else this.processChildNodes(e.node,t,r,n,a,l)}return u}processChildNodes(e,t,r,n,a,s){e.children.forEach(e=>{let[i]=v(e.name,r);!a[i]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!b(e,n,r))&&(a[i]=!0,t.push({contexts:r.currentContext,node:e})):e.inputNames.every(e=>!!b(e,n,r))&&(a[i]=!0,t.push({contexts:r.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let r=e[t],[n]=S(t),a=this.graph.nodes[n];if(a.attrParams.shape&&a.attrParams.shape.value){let e=a.attrParams.shape.value,t=e.length===r.shape.length&&r.shape.every((t,r)=>-1===e[r]||e[r]===t);h.assert(t,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${r.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&h.assert(r.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var t,r;let n={};for(let a in e){let s=null==(r=null==(t=this._signature)?void 0:t.inputs)?void 0:r[a];null!=s?n[s.name]=e[a]:n[a]=e[a]}return n}checkInputs(e){let t=Object.keys(e).filter(e=>{let[t]=S(e);return null==this.graph.nodes[t]});if(t.length>0)throw Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(e=>{var t,r;let n=null==(r=null==(t=this._signature)?void 0:t.outputs)?void 0:r[e];return null!=n?n.name:e},{})}checkOutputs(e){e.forEach(e=>{let[t]=S(e);if(!this.graph.nodes[t])throw Error(`The output '${e}' is not found in the graph`)})}}class eQ{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}var e0=e.i(7926);class e1{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},r=l){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=r,null==t&&(this.loadOptions={}),this.resourceManager=new eQ}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return h.isPromise(e)?e.then(e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw Error("Model artifacts missing streamWeights function");let t=await (0,e0.decodeWeightsStream)(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let r=this.artifacts.modelTopology,n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){let e=this.artifacts.userDefinedMetadata;null!=e.signature&&(n=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=n,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new eJ(G.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let t=G.Instance.transformGraph(e.modelInitializer);this.initializer=new eJ(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){let t=this.io.getSaveHandlers(e);if(0===t.length)throw Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof u.Tensor?[e]:e,r={};return t.forEach((e,t)=>r[this.structuredOutputKeys[t]]=e),r}return e}predict(e,t){let r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,t){let r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var t;if(!(e instanceof u.Tensor)&&!Array.isArray(e)){let r=null==(t=this.signature)?void 0:t.inputs;if(null!=r)for(let t in r){let n=r[t];null!=n.resourceId&&(e[t]=this.resourceIdToCapturedInput[n.resourceId])}return e}e=Array.isArray(e)?e:[e];let r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let n=0;return this.inputNodes.reduce((t,r)=>{var a,s,i;let o=null==(i=null==(s=null==(a=this.signature)?void 0:a.inputs)?void 0:s[r])?void 0:i.resourceId;return null!=o?t[r]=this.resourceIdToCapturedInput[o]:t[r]=e[n++],t},{})}normalizeOutputs(e){return Array.isArray(e=e||this.outputNodes)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,r=Object.keys(t);for(let n=0;n<r.length;n++){let a=t[r[n]];this.resourceIdToCapturedInput[a.resourceId]=e[n]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,o.dispose)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function e2(e,t={},r=l){var n;if(null==e)throw Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&((n=e).endsWith("/")||(n+="/"),e=`${n}model.json?tfjs-format=file`);let a=new e1(e,t,r);return await a.load(),a}function e3(e){let t;if(null==e)throw Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");if(e instanceof Array){let[r,n]=e;if(!r)throw Error("modelJSON must be the first element of the array");if(!n||!(n instanceof ArrayBuffer))throw Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw Error("Model JSON is missing 'weightsManifest'");let a=l.getWeightSpecs(r.weightsManifest),s=l.getModelArtifactsForJSONSync(r,a,n);t=l.fromMemorySync(s)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=l.fromMemorySync(e);else throw Error("Unknown model format");let r=new e1(t);return r.load(),r}e.s(["GraphModel",()=>e1,"loadGraphModel",()=>e2,"loadGraphModelSync",()=>e3],71722),e.s(["version",()=>"4.22.0"],66841),e.s([],70001)},47493,e=>{"use strict";e.i(70001);var t=e.i(71722),r=e.i(3130),n=e.i(66841);e.s(["GraphModel",()=>t.GraphModel,"deregisterOp",()=>r.deregisterOp,"loadGraphModel",()=>t.loadGraphModel,"loadGraphModelSync",()=>t.loadGraphModelSync,"registerOp",()=>r.registerOp,"version_converter",()=>n.version])},53988,39250,64791,55785,80109,41667,17723,57889,79975,58318,e=>{"use strict";let t;var r,n,a=e.i(24452),s=e.i(29064),i=e.i(75660),o=e.i(97969),l=e.i(86962),u=e.i(59551),h=e.i(62836),p=e.i(33977),d=e.i(18181);let c=!1;function f(e,r=3){let n,s;if(r>4)throw Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw Error("pixels passed to tf.browser.fromPixels() can not be null");let l=!1,u=!1,h=!1,p=!1,c=!1,m=!1;if(e.data instanceof Uint8Array)l=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)u=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)h=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)p=!0;else if(null!=e.getContext)c=!0;else if("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap)m=!0;else throw Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(null!=(0,o.getKernel)(i.FromPixels,a.ENGINE.backendName))return a.ENGINE.runKernel(i.FromPixels,{pixels:e},{numChannels:r});let[g,y]=h?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(c)n=e.getContext("2d").getImageData(0,0,g,y).data;else if(u||l)n=e.data;else if(p||h||m){if(null==t)if("undefined"==typeof document)if("undefined"!=typeof OffscreenCanvas&&"undefined"!=typeof OffscreenCanvasRenderingContext2D)t=new OffscreenCanvas(1,1).getContext("2d");else throw Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else t=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});t.canvas.width=g,t.canvas.height=y,t.drawImage(e,0,0,g,y),n=t.getImageData(0,0,g,y).data}if(4===r)s=new Int32Array(n);else{let e=g*y;s=new Int32Array(e*r);for(let t=0;t<e;t++)for(let e=0;e<r;++e)s[t*r+e]=n[4*t+e]}let b=[y,g,r];return(0,d.tensor3d)(s,b,"int32")}async function m(e,t=3){var r;let n=null;if((0,s.env)().getBool("WRAP_TO_IMAGEBITMAP")&&"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&null!=(r=e)&&0!==r.width&&0!==r.height&&!(null!=e&&e.data instanceof Uint8Array)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return f(n,t)}function g(e){if(2!==e.rank&&3!==e.rank)throw Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function y(e,t){let r=(0,u.convertToTensor)(e,"img","toPixels");if(!(e instanceof l.Tensor)){let e=r;r=(0,h.cast)(e,"int32"),e.dispose()}g(r);let[n,s]=r.shape.slice(0,2),p=2===r.rank?1:r.shape[2],d=await r.data(),f="float32"===r.dtype?255:1,m=new Uint8ClampedArray(s*n*4);for(let e=0;e<n*s;++e){let t=[0,0,0,255];for(let n=0;n<p;n++){let a=d[e*p+n];if("float32"===r.dtype){if(a<0||a>1)throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${a}.`)}else if("int32"===r.dtype&&(a<0||a>255))throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${a}.`);1===p?(t[0]=a*f,t[1]=a*f,t[2]=a*f):t[n]=a*f}let n=4*e;m[n+0]=Math.round(t[0]),m[n+1]=Math.round(t[1]),m[n+2]=Math.round(t[2]),m[n+3]=Math.round(t[3])}if(null!=t){c||null!=(0,o.getKernel)(i.Draw,a.ENGINE.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),c=!0),t.width=s,t.height=n;let e=t.getContext("2d"),r=new ImageData(m,s,n);e.putImageData(r,0,0)}return r!==e&&r.dispose(),m}function b(e,t,r){let n=(0,u.convertToTensor)(e,"img","draw");if(!(e instanceof l.Tensor)){let e=n;n=(0,h.cast)(e,"int32"),e.dispose()}g(n);var s=null==r?void 0:r.imageOptions;let o=(null==s?void 0:s.alpha)||1;if(o>1||o<0)throw Error(`Alpha value ${o} is suppoed to be in range [0 - 1].`);let p={image:n};a.ENGINE.runKernel(i.Draw,p,{canvas:t,options:r})}let x=(0,p.op)({fromPixels_:f});e.s(["draw",()=>b,"fromPixels",0,x,"fromPixelsAsync",()=>m,"toPixels",()=>y],53988);var v=e.i(86879);function w(e,t){let r=e.shape.length,n=t.shape.length;if(r<1)throw Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${r}.`);if(n<1)throw Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if("int32"!==t.dtype)throw Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[n-1]>r)throw Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[n-1]} vs. ${r}`);if(0===(0,v.sizeFromShape)(e.shape))throw Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let e=0;e<a.length-1;++e)i*=a[e];let o=e.shape,l=a.slice();l.pop();let u=1;for(let e=s;e<r;++e)u*=o[e],l.push(o[e]);let h=[...(0,v.computeStrides)(e.shape).map(e=>e/u),1].slice(0,s);return[l,i,u,h]}function S(e,t,r){let n=e.shape.length;v.assert(n===t.length,()=>`Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`),v.assert(n===r.length,()=>`Error in slice${n}D: Length of size ${r} must match the rank of the array (${n}).`);for(let a=0;a<n;++a)v.assert(t[a]+r[a]<=e.shape[a],()=>`Error in slice${n}D: begin[${a}] + size[${a}] (${t[a]+r[a]}) would overflow input.shape[${a}] (${e.shape[a]})`)}function N(e){let t=[],r=0;for(;e>0;)1&e&&t.push(r),e/=2,r++;return t}function k(e,t,r){let n=[];for(let a=0;a<e.length;a++)n[a]=Math.ceil((t[a]-e[a])/r[a]);return n}function I(e,t,r,n){let a=[...e];for(let e=a.length;e<n.length;e++)a.push(1);for(let e=0;e<r;e++)0===e?a[t]=1:(a.splice(t,0,1),a.pop());return a}function T(e,t){let r=[];for(let n=0;n<e;n++)r.push(t+n);return r}function C(e,t,r,n,a,s,i,o,l){let u=e.length,h=Array(u),p=Array(u),d=Array(u);if(t.length&&r>0){let l=t[0],u=r+1;h=E(i,l,u,n,e),p=$(o,l,u,a,e),d=I(s,l,u,e)}else for(let t=0;t<u;t++)h[t]=R(i,n,s,e,t,l),p[t]=D(o,a,s,e,t,l),d[t]=A(s,t,l);return{begin:h,end:p,strides:d}}function E(e,t,r,n,a){let s=[...a],i=T(r,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{var o,l,u;let i=(o=t,l=r,(u=a)<=o?u:u-(l-1)),h=n[i];e&1<<i&&(h=0),s[a]=h}return s}function $(e,t,r,n,a){let s=[...a],i=T(r,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{var o,l,u;let i=(o=t,l=r,(u=a)<=o?u:u-(l-1)),h=n[i];e&1<<i&&(h=Number.MAX_SAFE_INTEGER),s[a]=h}for(let e=0;e<s.length;e++){let t=a[e];s[e]<0&&(s[e]+=t),s[e]=v.clamp(0,s[e],a[e])}return s}function A(e,t,r){let n=e[t];return(r&1<<t||null==n)&&(n=1),n}function R(e,t,r,n,a,s){let i=t[a],o=r[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let l=n[a];return i<0&&(i+=l),i=v.clamp(0,i,l-1)}function D(e,t,r,n,a,s){let i=t[a],o=r[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let l=n[a];return i<0&&(i+=l),i=o>0?v.clamp(0,i,l):v.clamp(-1,i,l-1)}function F(e,t,r){let n=r.length;for(let e=0;e<r.length;e++)if(r[e]>1){n=e;break}for(let a=n+1;a<r.length;a++)if(t[a]>0||r[a]!==e[a])return!1;return!0}function O(e,t){let r=e.length>0?e[e.length-1]:1;for(let n=0;n<e.length-1;n++)r+=e[n]*t[n];return r}function _(e,t,r){let n,a,s=e.shape.length;return(n="number"==typeof t?[t,...Array(s-1).fill(0)]:t.length<s?t.concat(Array(s-t.length).fill(0)):t.slice()).forEach(e=>{v.assert(-1!==e,()=>"slice() does not support negative begin indexing.")}),a=(a=null==r?Array(s).fill(-1):"number"==typeof r?[r,...Array(s-1).fill(-1)]:r.length<s?r.concat(Array(s-r.length).fill(-1)):r).map((t,r)=>t>=0?t:(v.assert(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${r}.`),e.shape[r]-n[r])),[n,a]}function M(e,t,r,n,a,s,i,o,l){let u;if(null==n?(u=Array(t.length)).fill(1):u=n,null!=i&&(i&i-1)!=0)throw Error("Multiple ellipses in slice is not allowed.");let h=!1,p={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:r.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let e=0;e<p.dims;e++)h&&(1<<e&o)!=0&&p.numAddAxisAfterEllipsis++,1<<e&i&&(h=!0);!h&&(p.ellipsisMask|=1<<p.dims,p.dims++);let d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};var c=p,f=d;f.beginMask=0,f.endMask=0,f.shrinkAxisMask=0;let m=0;f.beginValid=null!=c.begin,f.endValid=null!=c.end,f.begin=Array(f.dims),f.end=Array(f.dims),f.strides=Array(f.dims),f.finalShapeGatherIndices=[],f.finalShapeGatherIndicesSparse=[],f.inputShapeGatherIndicesSparse=Array(f.dims);for(let e=0;e<c.dims;e++)if(1<<e&c.ellipsisMask){let t=Math.min(f.dims-(c.dims-e)+1+c.numAddAxisAfterEllipsis,f.dims);for(;m<t;m++)f.begin[m]=0,f.end[m]=0,f.strides[m]=1,f.beginMask|=1<<m,f.endMask|=1<<m,f.finalShapeGatherIndices.push(m),f.finalShapeGatherIndicesSparse.push(-1),f.inputShapeGatherIndicesSparse[m]=e}else if(1<<e&c.newAxisMask)f.finalShapeGatherIndices.push(-2),f.finalShapeGatherIndicesSparse.push(-1);else{if(m===f.begin.length)throw Error(`Index out of range using input dim ${m}; input has only ${f.dims} dims, ${f.begin.length}.`);null!=c.begin&&(f.begin[m]=c.begin[e]),null!=c.end&&(f.end[m]=c.end[e]),f.strides[m]=c.strides[e],c.beginMask&1<<e&&(f.beginMask|=1<<m),c.endMask&1<<e&&(f.endMask|=1<<m),c.shrinkAxisMask&1<<e?(f.finalShapeGatherIndices.push(-1),f.finalShapeGatherIndicesSparse.push(-1),f.shrinkAxisMask|=1<<m):(f.finalShapeGatherIndices.push(m),f.finalShapeGatherIndicesSparse.push(e)),f.inputShapeGatherIndicesSparse[m]=e,m++}let g=!0,y=!0,b=!0,x=[],v=[];for(let t=0;t<e.length;++t){let r;if(0===d.strides[t])throw Error(`strides[${t}] must be non-zero`);let n=!!(d.shrinkAxisMask&1<<t),a=e[t];if(-1===a){x.push(n?1:-1);continue}let s=[d.beginMask&1<<t,d.endMask&1<<t],i=[d.strides[t]>0?0:-1,d.strides[t]>0?a:a-1];if(n&&d.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");b=b&&1===d.strides[t];let o=!!(d.beginMask&1<<t&&d.endMask&1<<t);if(d.beginValid&&d.endValid){if(n){let e=d.begin[t]<0?a+d.begin[t]:d.begin[t];if(d.begin[t]=e,d.end[t]=d.begin[t]+1,e<0||e>=a)throw Error(`slice index ${d.begin[t]} of dimension ${t} out of bounds.`)}else d.begin[t]=L(d.begin[t],0,d.strides[t],a,s,i),d.end[t]=L(d.end[t],1,d.strides[t],a,s,i);let e=1===d.strides[t]&&0===d.begin[t]&&d.end[t]===a;g=g&&e,y=y&&(0===t&&1===d.strides[t]||e)}else g=g&&1===d.strides[t]&&o,y=y&&(0===t&&1===d.strides[t]||o);let l=!1;if(d.beginValid&&d.endValid?(r=d.end[t]-d.begin[t],l=!0):n?(r=1,l=!0):o&&a>=0&&(r=d.strides[t]<0?-a:a,l=!0),l){let e;e=0===r||r<0!=d.strides[t]<0?0:Math.trunc(r/d.strides[t])+ +(r%d.strides[t]!=0),x.push(e)}else x.push(-1)}for(let e=0;e<d.finalShapeGatherIndices.length;++e){let t=d.finalShapeGatherIndices[e];t>=0?v.push(x[t]):-2===t&&v.push(1)}return{finalShapeSparse:v.filter((e,t)=>-2!==d.finalShapeGatherIndices[t]),finalShape:v,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:d.begin,end:d.end,strides:d.strides}}function L(e,t,r,n,a,s){if(a[t])return r>0?s[t]:s[t+1&1];{let t=e<0?n+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}e.s(["prepareAndValidate",()=>w],39250),e.s(["assertParamsValid",()=>S,"computeFlatOffset",()=>O,"computeOutShape",()=>k,"getNormalizedAxes",()=>C,"isSliceContinous",()=>F,"maskToAxes",()=>N,"parseSliceParams",()=>_,"sliceInfo",()=>M,"startForAxis",()=>R,"startIndicesWithElidedDims",()=>E,"stopForAxis",()=>D,"stopIndicesWithElidedDims",()=>$,"stridesForAxis",()=>A,"stridesWithElidedDims",()=>I],64791),e.s(["version",()=>"4.22.0"],55785);var z=e.i(91587),P=e.i(64791);function B(e){return e<=30?e:(0,v.nearestDivisor)(e,Math.floor(Math.sqrt(e)))}function V(e,t){let r,n=!1;for(e<=30?(r=e,n=!0):r=(0,v.nearestDivisor)(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=(0,v.nearestDivisor)(e,r+1);return r}function W(e,t,r){let n=[],a=e.length;for(let s=0;s<a;s++)s!==t?n.push(e[s]):n.push(r);return n}function U(e,t,r,n){let a=t.shape.length,s=e.shape.length;if(0!==n&&(n<-a||n>a))throw Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${n}`);if(n<0&&(n+=a),n>s)throw Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(r<n)throw Error(`batchDims (${n}) must be less than or equal to axis (${r}).`);for(let r=0;r<n;++r)if(e.shape[r]!==t.shape[r])throw Error(`x.shape[${r}]: ${e.shape[r]} should be equal to indices.shape[${r}]: ${t.shape[r]}.`);let i=e.shape[r],o=[],l=1,u=1,h=1;for(let t=0;t<n;++t)o.push(e.shape[t]),l*=e.shape[t];for(let t=n;t<r;t++)o.push(e.shape[t]),u*=e.shape[t];for(let e=n;e<a;e++)o.push(t.shape[e]);for(let t=r+1;t<s;t++)o.push(e.shape[t]),h*=e.shape[t];return{batchSize:l,sliceSize:h,outerSize:u,dimSize:i,outputShape:o}}e.s(["PARALLELIZE_THRESHOLD",0,30,"computeOptimalWindowSize",()=>B],67118),e.s(["collectGatherOpShapeInfo",()=>U,"computeOutShape",()=>W,"segOpComputeOptimalWindowSize",()=>V],62188);var G=e.i(62188);function q(e){try{return e.map(e=>(0,z.decodeString)(e))}catch(e){throw Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function H(e){return e.map(e=>(0,z.encodeString)(e))}e.s(["fromStringArrayToUint8",()=>H,"fromUint8ToStringArray",()=>q],64609),e.i(64609);var j=e.i(15401),K=e.i(42242);function X(e,t){let r=e[0].length;e.forEach((e,t)=>{v.assert(e.length===r,()=>`Error in concat${r}D: rank of tensors[${t}] must be the same as the rank of the rest (${r})`)}),v.assert(t>=0&&t<r,()=>`Error in concat${r}D: axis must be between 0 and ${r-1}.`);let n=e[0];e.forEach((e,a)=>{for(let s=0;s<r;s++)v.assert(s===t||e[s]===n[s],()=>`Error in concat${r}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${n}) along the non-concatenated axis ${a}.`)})}function Z(e,t){let r=e[0].slice();for(let n=1;n<e.length;n++)r[t]+=e[n][t];return r}e.s(["assertParamsConsistent",()=>X,"computeOutShape",()=>Z],8293),e.i(8293);var Y=e.i(19813),J=e.i(77744);function Q(e,t,r){let n=[];if(null==r&&null==t)return n;if(null==t)for(;n.length<e+r.length;)n.push(-1);else n=t.slice();if(null==r)return n;if(e+r.length!==n.length)throw Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+r.length}, but shape.rank = ${n.length}`);for(let a=1;a<r.length;++a){let s=r[a],i=n[n.length-r.length+a],o=n[i];if(s>=0)if(o>=0){if(o!==s)throw Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else n[i]=s}return n}function ee(e){let t={FIRST_DIM_SIZE:n.FIRST_DIM_SIZE,VALUE_ROWIDS:n.VALUE_ROWIDS,ROW_LENGTHS:n.ROW_LENGTHS,ROW_SPLITS:n.ROW_SPLITS,ROW_LIMITS:n.ROW_LIMITS,ROW_STARTS:n.ROW_STARTS},r=[];for(let n of e)if(n in t)r.push(t[n]);else break;return r}function et(e){return 0===e.length?0:e[0]===n.FIRST_DIM_SIZE?e.length-1:e.length}function er(e,t){if(null==e||null==t)return;let r=e.length,n=t.length;if(r>=n)throw Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${r} must be less than ragged tensor input flatValues.rank = ${n})`);for(let a=0;a<Math.min(r,n-1);++a){let r=e[a],n=t[a+1];if(r>=0&&n>=0&&1!==r&&r!==n)throw Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${r} but ragged tensor input.flatValues.shape[${a-e.length}] = ${n}`)}}e.s([],4444),e.i(4444),(r=n||(n={}))[r.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",r[r.VALUE_ROWIDS=1]="VALUE_ROWIDS",r[r.ROW_LENGTHS=2]="ROW_LENGTHS",r[r.ROW_SPLITS=3]="ROW_SPLITS",r[r.ROW_LIMITS=4]="ROW_LIMITS",r[r.ROW_STARTS=5]="ROW_STARTS",e.s(["RowPartitionType",()=>n,"combineRaggedTensorToTensorShapes",()=>Q,"getRaggedRank",()=>et,"getRowPartitionTypesHelper",()=>ee,"validateDefaultValueShape",()=>er],81973),e.i(81973),e.i(67118);var en=e.i(8308);function ea(e,t,r){return[r*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function es(e,t,r,n=!0){let a=[];if(n)(a=a.concat(t.slice(0))).push(e[0]/r),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let r=t.length;for(let n=0;n<r;++n)a=a.concat([e[n+1]/t[n],t[n]]);a=a.concat(e.slice(r+1))}return a}function ei(e,t,r=!0){let n=[];if(r){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{let r=[],a=[];for(let n=1;n<e;++n)n>=2*t+1||n%2==1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function eo(e,t,r,n=!0){let a=[];n?a.push(e[0]/r):a.push(e[0]*r);for(let r=1;r<e.length;++r)r<=t.length?n?a.push(t[r-1]*e[r]):a.push(e[r]/t[r-1]):a.push(e[r]);return a}function el(e,t){let r=[0];for(let n=0;n<t;++n)r.push(e[n][0]);return r}function eu(e,t,r){let n=e.slice(0,1);for(let a=0;a<r;++a)n.push(e[a+1]-t[a][0]-t[a][1]);return n}e.s(["getImageCenter",()=>ea],47606),e.i(47606),e.s(["getPermuted",()=>ei,"getReshaped",()=>es,"getReshapedPermuted",()=>eo,"getSliceBeginCoords",()=>el,"getSliceSize",()=>eu],45079),e.i(45079),e.i(39250);var eh=e.i(87271);e.s(["SELU_SCALE",0,1.0507009873554805,"SELU_SCALEALPHA",0,1.7580993408473768],80109),e.i(80109),e.s(["ERF_A1",0,.254829592,"ERF_A2",0,-.284496736,"ERF_A3",0,1.421413741,"ERF_A4",0,-1.453152027,"ERF_A5",0,1.061405429,"ERF_P",0,.3275911],40834),e.i(40834);var ep=e.i(71070);function ed(e,t){if(e.length!==t.length)throw Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let r=new Float32Array(2*e.length);for(let n=0;n<r.length;n+=2)r[n]=e[n/2],r[n+1]=t[n/2];return r}function ec(e){let t=new Float32Array(e.length/2),r=new Float32Array(e.length/2);for(let n=0;n<e.length;n+=2)t[n/2]=e[n],r[n/2]=e[n+1];return{real:t,imag:r}}function ef(e){let t=Math.ceil(e.length/4),r=new Float32Array(t),n=new Float32Array(t);for(let t=0;t<e.length;t+=4)r[Math.floor(t/4)]=e[t],n[Math.floor(t/4)]=e[t+1];return{real:r,imag:n}}function em(e){let t=Math.floor(e.length/4),r=new Float32Array(t),n=new Float32Array(t);for(let t=2;t<e.length;t+=4)r[Math.floor(t/4)]=e[t],n[Math.floor(t/4)]=e[t+1];return{real:r,imag:n}}function eg(e,t){return{real:e[2*t],imag:e[2*t+1]}}function ey(e,t,r,n){e[2*n]=t,e[2*n+1]=r}function eb(e,t){let r=new Float32Array(e/2),n=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);r[a]=Math.cos(s),n[a]=Math.sin(s)}return{real:r,imag:n}}function ex(e,t,r){let n=(r?2:-2)*Math.PI*(e/t);return{real:Math.cos(n),imag:Math.sin(n)}}e.s(["assignToTypedArray",()=>ey,"complexWithEvenIndex",()=>ef,"complexWithOddIndex",()=>em,"exponent",()=>ex,"exponents",()=>eb,"getComplexWithIndex",()=>eg,"mergeRealAndImagArrays",()=>ed,"splitRealAndImagArrays",()=>ec],27047),e.i(27047);let ev=/->/g;function ew(e,t){let r=((e=e.replace(/\s/g,"")).length-e.replace(ev,"").length)/2;if(r<1)throw Error("Equations without an arrow are not supported.");if(r>1)throw Error('Equation must contain exactly one arrow ("->").');let[n,a]=e.split("->");(0,v.assert)(-1===n.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');let s=n.split(","),i=s.length;if(t!==i)throw Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let e=0;e<a.length;++e){let t=a[e];if(!s.some(e=>-1!==e.indexOf(t)))throw Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===o.indexOf(t)&&o.push(t)}for(let e=0;e<n.length;++e){let t=n[e];-1===o.indexOf(t)&&","!==t&&o.push(t)}let l=Array(s.length);for(let e=0;e<i;++e){if(new Set(s[e].split("")).size!==s[e].length)throw Error(`Found duplicate axes in input component ${s[e]}. Support for duplicate axes in input is not implemented yet.`);l[e]=[];for(let t=0;t<s[e].length;++t)l[e].push(o.indexOf(s[e][t]))}let u=o.length,h=a.length,p=[];for(let e=h;e<u;++e)p.push(e);return{allDims:o,summedDims:p,idDims:l}}function eS(e,t){let r=Array(e);r.fill(-1);for(let e=0;e<t.length;++e)r[t[e]]=e;let n=[];for(let t=0;t<e;++t)-1===r[t]&&n.push(t);return{permutationIndices:r=r.filter(e=>-1!==e),expandDims:n}}function eN(e,t,r){let n=Array(e);for(let e=0;e<r.length;++e){let a=r[e].shape;for(let r=0;r<t[e].length;++r)void 0===n[t[e][r]]?n[t[e][r]]=a[r]:(0,v.assert)(n[t[e][r]]===a[r],()=>`Expected dimension ${n[t[e][r]]} at axis ${r} of input shaped ${JSON.stringify(a)}, but got dimension ${a[r]}`)}}function ek(e,t){let r=[],n=0;0===e.length&&e.push(-1),n=e.length+1;for(let e=0;e<n;++e)r.push([]);let a=[];for(let n=0;n<e.length;++n)for(let s of function(e,t){let r=[];for(let n=0;n<e.length;++n)(0===e[n].length||-1!==e[n].indexOf(t)||-1===t)&&r.push(n);return r}(t,e[n]))-1===a.indexOf(s)&&(r[n].push(s),a.push(s));return{path:e,steps:r}}function eI(e){return e.every((e,t)=>e===t)}function eT(e,t,r=0){let n=[];if("number"==typeof t)(0,v.assert)(e.shape[r]%t==0,()=>"Number of splits must evenly divide the axis."),n=Array(t).fill(e.shape[r]/t);else{let a=t.reduce((e,t)=>(-1===t&&(e+=1),e),0);(0,v.assert)(a<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(-1!==s){let n=t.reduce((e,t)=>t>0?e+t:e);t[s]=e.shape[r]-n}(0,v.assert)(e.shape[r]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),n=t}return n}function eC(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function eE(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function e$(e,t,r){return`indices(${e}, 0) is invalid: ${t} >= ${r}`}function eA(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function eR(e,t){return`size ${e} must be non-negative, not ${t}`}function eD(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function eF(e,t){let r=(0,v.sizeFromShape)(e),n=(0,v.sizeFromShape)(t);return`Input to reshape is a SparseTensor with ${r}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${e} outputShape= ${t}`}function eO(e,t){let r=(0,v.sizeFromShape)(e),n=(0,v.sizeFromShape)(t);return`Input to reshape is a tensor with ${r} dense values, but the requested shape has ${n}. inputShape=${e} outputShape=${t}`}function e_(){return"segment ids must be >= 0"}function eM(){return"segment ids are not increasing"}function eL(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function ez(e,t,r){return`Bad: indices[${e}] == ${t} out of range [0, ${r})`}e.s(["checkEinsumDimSizes",()=>eN,"decodeEinsumEquation",()=>ew,"getEinsumComputePath",()=>ek,"getEinsumPermutation",()=>eS,"isIdentityPermutation",()=>eI],82415),e.i(82415),e.s(["prepareSplitSize",()=>eT],29997),e.i(29997),e.s(["getSparseFillEmptyRowsIndicesDenseShapeMismatch",()=>eC,"getSparseFillEmptyRowsNegativeIndexErrorMessage",()=>eE,"getSparseFillEmptyRowsOutOfRangeIndexErrorMessage",()=>e$],69888),e.i(69888),e.s(["getSparseReshapeEmptyTensorZeroOutputDimErrorMessage",()=>eD,"getSparseReshapeInputOutputMismatchErrorMessage",()=>eO,"getSparseReshapeInputOutputMultipleErrorMessage",()=>eF,"getSparseReshapeMultipleNegativeOneOutputDimErrorMessage",()=>eA,"getSparseReshapeNegativeOutputDimErrorMessage",()=>eR],65990),e.i(65990),e.s(["getSparseSegmentReductionIndicesOutOfRangeErrorMessage",()=>ez,"getSparseSegmentReductionNegativeSegmentIdsErrorMessage",()=>e_,"getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage",()=>eM,"getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage",()=>eL],58472),e.i(58472),e.s(["ERF_A1",0,.254829592,"ERF_A2",0,-.284496736,"ERF_A3",0,1.421413741,"ERF_A4",0,-1.453152027,"ERF_A5",0,1.061405429,"ERF_P",0,.3275911,"PARALLELIZE_THRESHOLD",0,30,"RowPartitionType",()=>n,"SELU_SCALE",0,1.0507009873554805,"SELU_SCALEALPHA",0,1.7580993408473768,"applyActivation",()=>J.applyActivation,"assertAndGetBroadcastShape",()=>K.assertAndGetBroadcastShape,"assertAxesAreInnerMostDims",()=>j.assertAxesAreInnerMostDims,"assertParamsConsistent",()=>X,"assignToTypedArray",()=>ey,"axesAreInnerMostDims",()=>j.axesAreInnerMostDims,"calculateShapes",()=>eh.calculateShapes,"checkEinsumDimSizes",()=>eN,"checkPadOnDimRoundingMode",()=>Y.checkPadOnDimRoundingMode,"combineLocations",()=>j.combineLocations,"combineRaggedTensorToTensorShapes",()=>Q,"complexWithEvenIndex",()=>ef,"complexWithOddIndex",()=>em,"computeConv2DInfo",()=>Y.computeConv2DInfo,"computeConv3DInfo",()=>Y.computeConv3DInfo,"computeDefaultPad",()=>Y.computeDefaultPad,"computeDilation2DInfo",()=>Y.computeDilation2DInfo,"computeOptimalWindowSize",()=>B,"computeOutAndReduceShapes",()=>j.computeOutAndReduceShapes,"computeOutShape",()=>Z,"computePool2DInfo",()=>Y.computePool2DInfo,"computePool3DInfo",()=>Y.computePool3DInfo,"convertConv2DDataFormat",()=>Y.convertConv2DDataFormat,"decodeEinsumEquation",()=>ew,"eitherStridesOrDilationsAreOne",()=>Y.eitherStridesOrDilationsAreOne,"expandShapeToKeepDim",()=>j.expandShapeToKeepDim,"exponent",()=>ex,"exponents",()=>eb,"fromStringArrayToUint8",()=>H,"fromUint8ToStringArray",()=>q,"getAxesPermutation",()=>j.getAxesPermutation,"getBroadcastDims",()=>K.getBroadcastDims,"getComplexWithIndex",()=>eg,"getEinsumComputePath",()=>ek,"getEinsumPermutation",()=>eS,"getFusedBiasGradient",()=>J.getFusedBiasGradient,"getFusedDyActivation",()=>J.getFusedDyActivation,"getImageCenter",()=>ea,"getInnerMostAxes",()=>j.getInnerMostAxes,"getPermuted",()=>ei,"getRaggedRank",()=>et,"getReductionAxes",()=>K.getReductionAxes,"getReshaped",()=>es,"getReshapedPermuted",()=>eo,"getRowPartitionTypesHelper",()=>ee,"getSliceBeginCoords",()=>el,"getSliceSize",()=>eu,"getSparseFillEmptyRowsIndicesDenseShapeMismatch",()=>eC,"getSparseFillEmptyRowsNegativeIndexErrorMessage",()=>eE,"getSparseFillEmptyRowsOutOfRangeIndexErrorMessage",()=>e$,"getSparseReshapeEmptyTensorZeroOutputDimErrorMessage",()=>eD,"getSparseReshapeInputOutputMismatchErrorMessage",()=>eO,"getSparseReshapeInputOutputMultipleErrorMessage",()=>eF,"getSparseReshapeMultipleNegativeOneOutputDimErrorMessage",()=>eA,"getSparseReshapeNegativeOutputDimErrorMessage",()=>eR,"getSparseSegmentReductionIndicesOutOfRangeErrorMessage",()=>ez,"getSparseSegmentReductionNegativeSegmentIdsErrorMessage",()=>e_,"getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage",()=>eM,"getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage",()=>eL,"getUndoAxesPermutation",()=>j.getUndoAxesPermutation,"isIdentityPermutation",()=>eI,"log",()=>ep.log,"mergeRealAndImagArrays",()=>ed,"prepareAndValidate",()=>w,"prepareSplitSize",()=>eT,"segment_util",0,G,"shouldFuse",()=>J.shouldFuse,"slice_util",0,P,"splitRealAndImagArrays",()=>ec,"stridesOrDilationsArePositive",()=>Y.stridesOrDilationsArePositive,"tupleValuesAreOne",()=>Y.tupleValuesAreOne,"upcastType",()=>en.upcastType,"validateDefaultValueShape",()=>er,"validateInput",()=>eh.validateInput,"validateUpdateShape",()=>eh.validateUpdateShape,"warn",()=>ep.warn],41667),e.s([],1865),e.i(1865);var eP=e.i(67768),eB=e.i(92135);e.s(["nonMaxSuppressionV3Impl",()=>eP.nonMaxSuppressionV3Impl,"nonMaxSuppressionV4Impl",()=>eP.nonMaxSuppressionV4Impl,"nonMaxSuppressionV5Impl",()=>eP.nonMaxSuppressionV5Impl,"whereImpl",()=>eB.whereImpl],17723);var eV=e.i(40922),eW=e.i(6587),eU=e.i(54463),eG=e.i(73824),eq=e.i(91995),eH=e.i(84652),ej=e.i(52850);class eK{static sgd(e){return new ej.SGDOptimizer(e)}static momentum(e,t,r=!1){return new eq.MomentumOptimizer(e,t,r)}static rmsprop(e,t=.9,r=0,n=null,a=!1){return new eH.RMSPropOptimizer(e,t,r,n,a)}static adam(e=.001,t=.9,r=.999,n=null){return new eU.AdamOptimizer(e,t,r,n)}static adadelta(e=.001,t=.95,r=null){return new eV.AdadeltaOptimizer(e,t,r)}static adamax(e=.002,t=.9,r=.999,n=null,a=0){return new eG.AdamaxOptimizer(e,t,r,n,a)}static adagrad(e,t=.1){return new eW.AdagradOptimizer(e,t)}}e.s(["OptimizerConstructors",()=>eK],57889),e.s(["train",0,eK],79975);let eX="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function eZ(){return new Promise(e=>eX(()=>e()))}e.s(["nextFrame",()=>eZ],58318)},6851,e=>{"use strict";e.i(70306),e.i(59966);var t=e.i(61898),r=e.i(59551),n=e.i(86879),a=e.i(62836),s=e.i(91555),i=e.i(90889),o=e.i(33977),l=e.i(90049);let u=(0,o.op)({confusionMatrix_:function(e,t,o){let u=(0,r.convertToTensor)(e,"labels","confusionMatrix"),h=(0,r.convertToTensor)(t,"predictions","confusionMatrix");n.assert(null==o||o>0&&Number.isInteger(o),()=>`If provided, numClasses must be a positive integer, but got ${o}`),n.assert(1===u.rank,()=>`Expected the rank of labels to be 1, but got ${u.rank}`),n.assert(1===h.rank,()=>`Expected the rank of predictions to be 1, but got ${h.rank}`),n.assert(u.shape[0]===h.shape[0],()=>`Mismatch in the number of examples: ${u.shape[0]} vs. ${h.shape[0]}. Labels and predictions should have the same number of elements.`),n.assert(o>0&&Number.isInteger(o),()=>`numClasses is required to be a positive integer, but got ${o}`);let p=(0,i.oneHot)((0,a.cast)(u,"int32"),o),d=(0,i.oneHot)((0,a.cast)(h,"int32"),o),c=(0,l.transpose)(p),f=(0,s.matMul)(c,d);return(0,a.cast)(f,"int32")}});e.s([],5122),e.i(5122),e.s(["confusionMatrix",0,u],62903);var h=e.i(62903),p=e.i(42242),d=e.i(53988),c=e.i(39250),f=e.i(87271),m=e.i(64791),g=e.i(86862),y=e.i(41175),b=e.i(24452),x=e.i(91587);function v(e,t,r){return null==r&&(r=w()),S(e,t,(e,t)=>T(e,t,r))}function w(){return 32===b.ENGINE.backend.floatPrecision()?.001:.1}function S(e,t,a){let s=!0;if(((0,x.isTypedArray)(e)||(0,x.isTypedArray)(t))&&(s=!1),(0,x.isTypedArray)(e)&&(0,x.isTypedArray)(t)&&(s=!0),s){let r=e.constructor.name,n=t.constructor.name;if(r!==n)throw Error(`Arrays are of different type. Actual: ${r}. Expected: ${n}`)}if(Array.isArray(e)&&Array.isArray(t)){let a=(0,r.inferShape)(e),s=(0,r.inferShape)(t);if(!(0,n.arraysEqual)(a,s))throw Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${s}]`)}let i=(0,x.isTypedArray)(e)?e:(0,x.flatten)(e),o=(0,x.isTypedArray)(t)?t:(0,x.flatten)(t);if(i.length!==o.length)throw Error(`Arrays have different lengths actual: ${i.length} vs expected: ${o.length}.
Actual:   ${i}.
Expected: ${o}.`);for(let e=0;e<o.length;++e){let t=i[e],r=o[e];if(!a(t,r))throw Error(`Arrays differ: actual[${e}] = ${t}, expected[${e}] = ${r}.
Actual:   ${i}.
Expected: ${o}.`)}"undefined"!=typeof expect&&expect().nothing()}function N(e,t){e().then(()=>t.fail(),()=>t()),"undefined"!=typeof expect&&expect().nothing()}function k(e,t){let r="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return(0,n.isString)(e)||(0,n.isString)(e[0])||(0,n.isString)(t)||(0,n.isString)(t[0])?S(e,r,(e,t)=>e==t):S(e,t,(e,t)=>T(e,t,0))}function I(e,t,r){if(null==r&&(r=w()),!T(e,t,r))throw Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function T(e,t,r){return!(isFinite(e)||isFinite(t))||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>r)}function C(e,t,r){for(let n=0;n<e.length;n++)if(e[n]<t||e[n]>r)throw Error(`Value out of range:${e[n]} low: ${t}, high: ${r}`)}function E(e,t){let r=new Float32Array(e),n=new Float32Array(t);if(r.length!==n.length)throw Error(`Expected ArrayBuffer to be of length ${n.length}, but it was ${r.length}`);for(let e=0;e<n.length;e++)if(r[e]!==n[e])throw Error(`Expected ArrayBuffer value at ${e} to be ${n[e]} but got ${r[e]} instead`)}function $(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(e=>{t.addEventListener("loadeddata",r=>e(t)),t.load()})}async function A(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}e.s(["TEST_EPSILON_FLOAT16",0,.1,"createVideoElement",()=>$,"encodeStrings",()=>function e(t){for(let r=0;r<t.length;r++){let n=t[r];Array.isArray(n)?e(n):t[r]=(0,x.encodeString)(n)}return t},"expectArrayBuffersEqual",()=>E,"expectArraysClose",()=>v,"expectArraysEqual",()=>k,"expectNumbersClose",()=>I,"expectPromiseToFail",()=>N,"expectValuesInRange",()=>C,"play",()=>A,"testEpsilon",()=>w],94196);var R=e.i(94196),D=e.i(34338),F=e.i(55785),O=e.i(86962),_=e.i(41667),M=e.i(62893),L=e.i(17723);e.s([],21475),e.i(21475);var z=e.i(40922),P=e.i(6587),B=e.i(54463),V=e.i(73824),W=e.i(91995),U=e.i(18985),G=e.i(57889),q=e.i(84652),H=e.i(52850),j=e.i(8308),K=e.i(9670),X=e.i(99963),Z=e.i(79975),Y=e.i(17372),J=e.i(97969),Q=e.i(56425),ee=e.i(29064),et=e.i(58318),er=e.i(90422),en=e.i(75660);e.s(["Abs",()=>en.Abs,"Acos",()=>en.Acos,"Acosh",()=>en.Acosh,"AdadeltaOptimizer",()=>z.AdadeltaOptimizer,"AdagradOptimizer",()=>P.AdagradOptimizer,"AdamOptimizer",()=>B.AdamOptimizer,"AdamaxOptimizer",()=>V.AdamaxOptimizer,"Add",()=>en.Add,"AddN",()=>en.AddN,"All",()=>en.All,"Any",()=>en.Any,"ArgMax",()=>en.ArgMax,"ArgMin",()=>en.ArgMin,"Asin",()=>en.Asin,"Asinh",()=>en.Asinh,"Atan",()=>en.Atan,"Atan2",()=>en.Atan2,"Atanh",()=>en.Atanh,"AvgPool",()=>en.AvgPool,"AvgPool3D",()=>en.AvgPool3D,"AvgPool3DGrad",()=>en.AvgPool3DGrad,"AvgPoolGrad",()=>en.AvgPoolGrad,"BatchMatMul",()=>en.BatchMatMul,"BatchToSpaceND",()=>en.BatchToSpaceND,"Bincount",()=>en.Bincount,"BitwiseAnd",()=>en.BitwiseAnd,"BroadcastArgs",()=>en.BroadcastArgs,"BroadcastTo",()=>en.BroadcastTo,"Cast",()=>en.Cast,"Ceil",()=>en.Ceil,"ClipByValue",()=>en.ClipByValue,"Complex",()=>en.Complex,"ComplexAbs",()=>en.ComplexAbs,"Concat",()=>en.Concat,"Conv2D",()=>en.Conv2D,"Conv2DBackpropFilter",()=>en.Conv2DBackpropFilter,"Conv2DBackpropInput",()=>en.Conv2DBackpropInput,"Conv3D",()=>en.Conv3D,"Conv3DBackpropFilterV2",()=>en.Conv3DBackpropFilterV2,"Conv3DBackpropInputV2",()=>en.Conv3DBackpropInputV2,"Cos",()=>en.Cos,"Cosh",()=>en.Cosh,"CropAndResize",()=>en.CropAndResize,"Cumprod",()=>en.Cumprod,"Cumsum",()=>en.Cumsum,"DataStorage",()=>er.DataStorage,"DenseBincount",()=>en.DenseBincount,"DepthToSpace",()=>en.DepthToSpace,"DepthwiseConv2dNative",()=>en.DepthwiseConv2dNative,"DepthwiseConv2dNativeBackpropFilter",()=>en.DepthwiseConv2dNativeBackpropFilter,"DepthwiseConv2dNativeBackpropInput",()=>en.DepthwiseConv2dNativeBackpropInput,"Diag",()=>en.Diag,"Dilation2D",()=>en.Dilation2D,"Dilation2DBackpropFilter",()=>en.Dilation2DBackpropFilter,"Dilation2DBackpropInput",()=>en.Dilation2DBackpropInput,"Draw",()=>en.Draw,"ENV",()=>ee.ENV,"Einsum",()=>en.Einsum,"Elu",()=>en.Elu,"EluGrad",()=>en.EluGrad,"Environment",()=>ee.Environment,"Equal",()=>en.Equal,"Erf",()=>en.Erf,"Exp",()=>en.Exp,"ExpandDims",()=>en.ExpandDims,"Expm1",()=>en.Expm1,"FFT",()=>en.FFT,"Fill",()=>en.Fill,"FlipLeftRight",()=>en.FlipLeftRight,"Floor",()=>en.Floor,"FloorDiv",()=>en.FloorDiv,"FromPixels",()=>en.FromPixels,"FusedBatchNorm",()=>en.FusedBatchNorm,"FusedConv2D",()=>en.FusedConv2D,"FusedDepthwiseConv2D",()=>en.FusedDepthwiseConv2D,"GatherNd",()=>en.GatherNd,"GatherV2",()=>en.GatherV2,"Greater",()=>en.Greater,"GreaterEqual",()=>en.GreaterEqual,"IFFT",()=>en.IFFT,"Identity",()=>en.Identity,"Imag",()=>en.Imag,"IsFinite",()=>en.IsFinite,"IsInf",()=>en.IsInf,"IsNan",()=>en.IsNan,"KernelBackend",()=>er.KernelBackend,"LRN",()=>en.LRN,"LRNGrad",()=>en.LRNGrad,"LeakyRelu",()=>en.LeakyRelu,"Less",()=>en.Less,"LessEqual",()=>en.LessEqual,"LinSpace",()=>en.LinSpace,"Log",()=>en.Log,"Log1p",()=>en.Log1p,"LogSoftmax",()=>en.LogSoftmax,"LogicalAnd",()=>en.LogicalAnd,"LogicalNot",()=>en.LogicalNot,"LogicalOr",()=>en.LogicalOr,"LogicalXor",()=>en.LogicalXor,"LowerBound",()=>en.LowerBound,"MatrixBandPart",()=>en.MatrixBandPart,"Max",()=>en.Max,"MaxPool",()=>en.MaxPool,"MaxPool3D",()=>en.MaxPool3D,"MaxPool3DGrad",()=>en.MaxPool3DGrad,"MaxPoolGrad",()=>en.MaxPoolGrad,"MaxPoolWithArgmax",()=>en.MaxPoolWithArgmax,"Maximum",()=>en.Maximum,"Mean",()=>en.Mean,"Min",()=>en.Min,"Minimum",()=>en.Minimum,"MirrorPad",()=>en.MirrorPad,"Mod",()=>en.Mod,"MomentumOptimizer",()=>W.MomentumOptimizer,"Multinomial",()=>en.Multinomial,"Multiply",()=>en.Multiply,"Neg",()=>en.Neg,"NonMaxSuppressionV3",()=>en.NonMaxSuppressionV3,"NonMaxSuppressionV4",()=>en.NonMaxSuppressionV4,"NonMaxSuppressionV5",()=>en.NonMaxSuppressionV5,"NotEqual",()=>en.NotEqual,"OP_SCOPE_SUFFIX",()=>K.OP_SCOPE_SUFFIX,"OneHot",()=>en.OneHot,"OnesLike",()=>en.OnesLike,"Optimizer",()=>U.Optimizer,"OptimizerConstructors",()=>G.OptimizerConstructors,"Pack",()=>en.Pack,"PadV2",()=>en.PadV2,"Pool",()=>en.Pool,"Pow",()=>en.Pow,"Prelu",()=>en.Prelu,"Prod",()=>en.Prod,"RMSPropOptimizer",()=>q.RMSPropOptimizer,"RaggedGather",()=>en.RaggedGather,"RaggedRange",()=>en.RaggedRange,"RaggedTensorToTensor",()=>en.RaggedTensorToTensor,"Range",()=>en.Range,"Rank",()=>j.Rank,"Real",()=>en.Real,"RealDiv",()=>en.RealDiv,"Reciprocal",()=>en.Reciprocal,"Reduction",()=>X.Reduction,"Relu",()=>en.Relu,"Relu6",()=>en.Relu6,"Reshape",()=>en.Reshape,"ResizeBilinear",()=>en.ResizeBilinear,"ResizeBilinearGrad",()=>en.ResizeBilinearGrad,"ResizeNearestNeighbor",()=>en.ResizeNearestNeighbor,"ResizeNearestNeighborGrad",()=>en.ResizeNearestNeighborGrad,"Reverse",()=>en.Reverse,"RotateWithOffset",()=>en.RotateWithOffset,"Round",()=>en.Round,"Rsqrt",()=>en.Rsqrt,"SGDOptimizer",()=>H.SGDOptimizer,"ScatterNd",()=>en.ScatterNd,"SearchSorted",()=>en.SearchSorted,"Select",()=>en.Select,"Selu",()=>en.Selu,"Sigmoid",()=>en.Sigmoid,"Sign",()=>en.Sign,"Sin",()=>en.Sin,"Sinh",()=>en.Sinh,"Slice",()=>en.Slice,"Softmax",()=>en.Softmax,"Softplus",()=>en.Softplus,"SpaceToBatchND",()=>en.SpaceToBatchND,"SparseFillEmptyRows",()=>en.SparseFillEmptyRows,"SparseReshape",()=>en.SparseReshape,"SparseSegmentMean",()=>en.SparseSegmentMean,"SparseSegmentSum",()=>en.SparseSegmentSum,"SparseToDense",()=>en.SparseToDense,"SplitV",()=>en.SplitV,"Sqrt",()=>en.Sqrt,"Square",()=>en.Square,"SquaredDifference",()=>en.SquaredDifference,"StaticRegexReplace",()=>en.StaticRegexReplace,"Step",()=>en.Step,"StridedSlice",()=>en.StridedSlice,"StringNGrams",()=>en.StringNGrams,"StringSplit",()=>en.StringSplit,"StringToHashBucketFast",()=>en.StringToHashBucketFast,"Sub",()=>en.Sub,"Sum",()=>en.Sum,"Tan",()=>en.Tan,"Tanh",()=>en.Tanh,"Tensor",()=>O.Tensor,"TensorBuffer",()=>O.TensorBuffer,"TensorScatterUpdate",()=>en.TensorScatterUpdate,"Tile",()=>en.Tile,"TopK",()=>en.TopK,"Transform",()=>en.Transform,"Transpose",()=>en.Transpose,"Unique",()=>en.Unique,"Unpack",()=>en.Unpack,"UnsortedSegmentSum",()=>en.UnsortedSegmentSum,"UpperBound",()=>en.UpperBound,"Variable",()=>O.Variable,"ZerosLike",()=>en.ZerosLike,"_FusedMatMul",()=>en._FusedMatMul,"abs",()=>K.abs,"acos",()=>K.acos,"acosh",()=>K.acosh,"add",()=>K.add,"addN",()=>K.addN,"all",()=>K.all,"any",()=>K.any,"argMax",()=>K.argMax,"argMin",()=>K.argMin,"asin",()=>K.asin,"asinh",()=>K.asinh,"atan",()=>K.atan,"atan2",()=>K.atan2,"atanh",()=>K.atanh,"avgPool",()=>K.avgPool,"avgPool3d",()=>K.avgPool3d,"backend",()=>Y.backend,"backend_util",0,_,"basicLSTMCell",()=>K.basicLSTMCell,"batchNorm",()=>K.batchNorm,"batchNorm2d",()=>K.batchNorm2d,"batchNorm3d",()=>K.batchNorm3d,"batchNorm4d",()=>K.batchNorm4d,"batchToSpaceND",()=>K.batchToSpaceND,"bincount",()=>K.bincount,"bitwiseAnd",()=>K.bitwiseAnd,"booleanMaskAsync",()=>K.booleanMaskAsync,"broadcastArgs",()=>K.broadcastArgs,"broadcastTo",()=>K.broadcastTo,"broadcast_util",0,p,"browser",0,d,"buffer",()=>K.buffer,"cast",()=>K.cast,"ceil",()=>K.ceil,"clipByValue",()=>K.clipByValue,"clone",()=>K.clone,"complex",()=>K.complex,"concat",()=>K.concat,"concat1d",()=>K.concat1d,"concat2d",()=>K.concat2d,"concat3d",()=>K.concat3d,"concat4d",()=>K.concat4d,"conv1d",()=>K.conv1d,"conv2d",()=>K.conv2d,"conv2dTranspose",()=>K.conv2dTranspose,"conv3d",()=>K.conv3d,"conv3dTranspose",()=>K.conv3dTranspose,"copyRegisteredKernels",()=>J.copyRegisteredKernels,"cos",()=>K.cos,"cosh",()=>K.cosh,"cosineWindow",()=>K.cosineWindow,"cumprod",()=>K.cumprod,"cumsum",()=>K.cumsum,"customGrad",()=>Q.customGrad,"denseBincount",()=>K.denseBincount,"deprecationWarn",()=>Y.deprecationWarn,"depthToSpace",()=>K.depthToSpace,"depthwiseConv2d",()=>K.depthwiseConv2d,"device_util",0,M,"diag",()=>K.diag,"dilation2d",()=>K.dilation2d,"disableDeprecationWarnings",()=>Y.disableDeprecationWarnings,"dispose",()=>Y.dispose,"disposeVariables",()=>Y.disposeVariables,"div",()=>K.div,"divNoNan",()=>K.divNoNan,"dot",()=>K.dot,"dropout",()=>K.dropout,"einsum",()=>K.einsum,"elu",()=>K.elu,"enableDebugMode",()=>Y.enableDebugMode,"enableProdMode",()=>Y.enableProdMode,"enclosingPowerOfTwo",()=>K.enclosingPowerOfTwo,"engine",()=>Y.engine,"ensureShape",()=>K.ensureShape,"env",()=>ee.env,"equal",()=>K.equal,"erf",()=>K.erf,"euclideanNorm",()=>K.euclideanNorm,"exp",()=>K.exp,"expandDims",()=>K.expandDims,"expm1",()=>K.expm1,"eye",()=>K.eye,"fft",()=>K.fft,"fill",()=>K.fill,"findBackend",()=>Y.findBackend,"findBackendFactory",()=>Y.findBackendFactory,"floor",()=>K.floor,"floorDiv",()=>K.floorDiv,"fused",()=>K.fused,"gather",()=>K.gather,"gatherND",()=>K.gatherND,"gather_util",0,c,"getBackend",()=>Y.getBackend,"getGradient",()=>J.getGradient,"getKernel",()=>J.getKernel,"getKernelsForBackend",()=>J.getKernelsForBackend,"grad",()=>Q.grad,"grads",()=>Q.grads,"greater",()=>K.greater,"greaterEqual",()=>K.greaterEqual,"ifft",()=>K.ifft,"imag",()=>K.imag,"image",()=>K.image,"inTopKAsync",()=>K.inTopKAsync,"io",0,t,"irfft",()=>K.irfft,"isFinite",()=>K.isFinite,"isInf",()=>K.isInf,"isNaN",()=>K.isNaN,"keep",()=>Y.keep,"kernel_impls",0,L,"leakyRelu",()=>K.leakyRelu,"less",()=>K.less,"lessEqual",()=>K.lessEqual,"linalg",()=>K.linalg,"linspace",()=>K.linspace,"localResponseNormalization",()=>K.localResponseNormalization,"log",()=>K.log,"log1p",()=>K.log1p,"logSigmoid",()=>K.logSigmoid,"logSoftmax",()=>K.logSoftmax,"logSumExp",()=>K.logSumExp,"logicalAnd",()=>K.logicalAnd,"logicalNot",()=>K.logicalNot,"logicalOr",()=>K.logicalOr,"logicalXor",()=>K.logicalXor,"losses",()=>K.losses,"lowerBound",()=>K.lowerBound,"matMul",()=>K.matMul,"math",0,h,"max",()=>K.max,"maxPool",()=>K.maxPool,"maxPool3d",()=>K.maxPool3d,"maxPoolWithArgmax",()=>K.maxPoolWithArgmax,"maximum",()=>K.maximum,"mean",()=>K.mean,"memory",()=>Y.memory,"meshgrid",()=>K.meshgrid,"min",()=>K.min,"minimum",()=>K.minimum,"mirrorPad",()=>K.mirrorPad,"mod",()=>K.mod,"moments",()=>K.moments,"movingAverage",()=>K.movingAverage,"mul",()=>K.mul,"multiRNNCell",()=>K.multiRNNCell,"multinomial",()=>K.multinomial,"neg",()=>K.neg,"nextFrame",()=>et.nextFrame,"norm",()=>K.norm,"notEqual",()=>K.notEqual,"oneHot",()=>K.oneHot,"ones",()=>K.ones,"onesLike",()=>K.onesLike,"op",()=>K.op,"outerProduct",()=>K.outerProduct,"pad",()=>K.pad,"pad1d",()=>K.pad1d,"pad2d",()=>K.pad2d,"pad3d",()=>K.pad3d,"pad4d",()=>K.pad4d,"pool",()=>K.pool,"pow",()=>K.pow,"prelu",()=>K.prelu,"print",()=>K.print,"prod",()=>K.prod,"profile",()=>Y.profile,"raggedGather",()=>K.raggedGather,"raggedRange",()=>K.raggedRange,"raggedTensorToTensor",()=>K.raggedTensorToTensor,"rand",()=>K.rand,"randomGamma",()=>K.randomGamma,"randomNormal",()=>K.randomNormal,"randomStandardNormal",()=>K.randomStandardNormal,"randomUniform",()=>K.randomUniform,"randomUniformInt",()=>K.randomUniformInt,"range",()=>K.range,"ready",()=>Y.ready,"real",()=>K.real,"reciprocal",()=>K.reciprocal,"registerBackend",()=>Y.registerBackend,"registerGradient",()=>J.registerGradient,"registerKernel",()=>J.registerKernel,"relu",()=>K.relu,"relu6",()=>K.relu6,"removeBackend",()=>Y.removeBackend,"reshape",()=>K.reshape,"reverse",()=>K.reverse,"reverse1d",()=>K.reverse1d,"reverse2d",()=>K.reverse2d,"reverse3d",()=>K.reverse3d,"reverse4d",()=>K.reverse4d,"rfft",()=>K.rfft,"round",()=>K.round,"rsqrt",()=>K.rsqrt,"scalar",()=>K.scalar,"scatterND",()=>K.scatterND,"scatter_util",0,f,"searchSorted",()=>K.searchSorted,"selu",()=>K.selu,"separableConv2d",()=>K.separableConv2d,"serialization",0,g,"setBackend",()=>Y.setBackend,"setPlatform",()=>Y.setPlatform,"setdiff1dAsync",()=>K.setdiff1dAsync,"sigmoid",()=>K.sigmoid,"sign",()=>K.sign,"signal",()=>K.signal,"sin",()=>K.sin,"sinh",()=>K.sinh,"slice",()=>K.slice,"slice1d",()=>K.slice1d,"slice2d",()=>K.slice2d,"slice3d",()=>K.slice3d,"slice4d",()=>K.slice4d,"slice_util",0,m,"softmax",()=>K.softmax,"softplus",()=>K.softplus,"spaceToBatchND",()=>K.spaceToBatchND,"sparse",()=>K.sparse,"sparseToDense",()=>K.sparseToDense,"spectral",()=>K.spectral,"split",()=>K.split,"sqrt",()=>K.sqrt,"square",()=>K.square,"squaredDifference",()=>K.squaredDifference,"squeeze",()=>K.squeeze,"stack",()=>K.stack,"step",()=>K.step,"stridedSlice",()=>K.stridedSlice,"string",()=>K.string,"sub",()=>K.sub,"sum",()=>K.sum,"sumOutType",()=>j.sumOutType,"tan",()=>K.tan,"tanh",()=>K.tanh,"tensor",()=>K.tensor,"tensor1d",()=>K.tensor1d,"tensor2d",()=>K.tensor2d,"tensor3d",()=>K.tensor3d,"tensor4d",()=>K.tensor4d,"tensor5d",()=>K.tensor5d,"tensor6d",()=>K.tensor6d,"tensorScatterUpdate",()=>K.tensorScatterUpdate,"tensor_util",0,y,"test_util",0,R,"tidy",()=>Y.tidy,"tile",()=>K.tile,"time",()=>Y.time,"topk",()=>K.topk,"train",()=>Z.train,"transpose",()=>K.transpose,"truncatedNormal",()=>K.truncatedNormal,"unique",()=>K.unique,"unregisterGradient",()=>J.unregisterGradient,"unregisterKernel",()=>J.unregisterKernel,"unsortedSegmentSum",()=>K.unsortedSegmentSum,"unstack",()=>K.unstack,"upcastType",()=>j.upcastType,"upperBound",()=>K.upperBound,"util",0,D,"valueAndGrad",()=>Q.valueAndGrad,"valueAndGrads",()=>Q.valueAndGrads,"variable",()=>K.variable,"variableGrads",()=>Q.variableGrads,"version_core",()=>F.version,"where",()=>K.where,"whereAsync",()=>K.whereAsync,"zeros",()=>K.zeros,"zerosLike",()=>K.zerosLike],51995),e.i(51995),e.s(["Abs",()=>en.Abs,"Acos",()=>en.Acos,"Acosh",()=>en.Acosh,"AdadeltaOptimizer",()=>z.AdadeltaOptimizer,"AdagradOptimizer",()=>P.AdagradOptimizer,"AdamOptimizer",()=>B.AdamOptimizer,"AdamaxOptimizer",()=>V.AdamaxOptimizer,"Add",()=>en.Add,"AddN",()=>en.AddN,"All",()=>en.All,"Any",()=>en.Any,"ArgMax",()=>en.ArgMax,"ArgMin",()=>en.ArgMin,"Asin",()=>en.Asin,"Asinh",()=>en.Asinh,"Atan",()=>en.Atan,"Atan2",()=>en.Atan2,"Atanh",()=>en.Atanh,"AvgPool",()=>en.AvgPool,"AvgPool3D",()=>en.AvgPool3D,"AvgPool3DGrad",()=>en.AvgPool3DGrad,"AvgPoolGrad",()=>en.AvgPoolGrad,"BatchMatMul",()=>en.BatchMatMul,"BatchToSpaceND",()=>en.BatchToSpaceND,"Bincount",()=>en.Bincount,"BitwiseAnd",()=>en.BitwiseAnd,"BroadcastArgs",()=>en.BroadcastArgs,"BroadcastTo",()=>en.BroadcastTo,"Cast",()=>en.Cast,"Ceil",()=>en.Ceil,"ClipByValue",()=>en.ClipByValue,"Complex",()=>en.Complex,"ComplexAbs",()=>en.ComplexAbs,"Concat",()=>en.Concat,"Conv2D",()=>en.Conv2D,"Conv2DBackpropFilter",()=>en.Conv2DBackpropFilter,"Conv2DBackpropInput",()=>en.Conv2DBackpropInput,"Conv3D",()=>en.Conv3D,"Conv3DBackpropFilterV2",()=>en.Conv3DBackpropFilterV2,"Conv3DBackpropInputV2",()=>en.Conv3DBackpropInputV2,"Cos",()=>en.Cos,"Cosh",()=>en.Cosh,"CropAndResize",()=>en.CropAndResize,"Cumprod",()=>en.Cumprod,"Cumsum",()=>en.Cumsum,"DataStorage",()=>er.DataStorage,"DenseBincount",()=>en.DenseBincount,"DepthToSpace",()=>en.DepthToSpace,"DepthwiseConv2dNative",()=>en.DepthwiseConv2dNative,"DepthwiseConv2dNativeBackpropFilter",()=>en.DepthwiseConv2dNativeBackpropFilter,"DepthwiseConv2dNativeBackpropInput",()=>en.DepthwiseConv2dNativeBackpropInput,"Diag",()=>en.Diag,"Dilation2D",()=>en.Dilation2D,"Dilation2DBackpropFilter",()=>en.Dilation2DBackpropFilter,"Dilation2DBackpropInput",()=>en.Dilation2DBackpropInput,"Draw",()=>en.Draw,"ENV",()=>ee.ENV,"Einsum",()=>en.Einsum,"Elu",()=>en.Elu,"EluGrad",()=>en.EluGrad,"Environment",()=>ee.Environment,"Equal",()=>en.Equal,"Erf",()=>en.Erf,"Exp",()=>en.Exp,"ExpandDims",()=>en.ExpandDims,"Expm1",()=>en.Expm1,"FFT",()=>en.FFT,"Fill",()=>en.Fill,"FlipLeftRight",()=>en.FlipLeftRight,"Floor",()=>en.Floor,"FloorDiv",()=>en.FloorDiv,"FromPixels",()=>en.FromPixels,"FusedBatchNorm",()=>en.FusedBatchNorm,"FusedConv2D",()=>en.FusedConv2D,"FusedDepthwiseConv2D",()=>en.FusedDepthwiseConv2D,"GatherNd",()=>en.GatherNd,"GatherV2",()=>en.GatherV2,"Greater",()=>en.Greater,"GreaterEqual",()=>en.GreaterEqual,"IFFT",()=>en.IFFT,"Identity",()=>en.Identity,"Imag",()=>en.Imag,"IsFinite",()=>en.IsFinite,"IsInf",()=>en.IsInf,"IsNan",()=>en.IsNan,"KernelBackend",()=>er.KernelBackend,"LRN",()=>en.LRN,"LRNGrad",()=>en.LRNGrad,"LeakyRelu",()=>en.LeakyRelu,"Less",()=>en.Less,"LessEqual",()=>en.LessEqual,"LinSpace",()=>en.LinSpace,"Log",()=>en.Log,"Log1p",()=>en.Log1p,"LogSoftmax",()=>en.LogSoftmax,"LogicalAnd",()=>en.LogicalAnd,"LogicalNot",()=>en.LogicalNot,"LogicalOr",()=>en.LogicalOr,"LogicalXor",()=>en.LogicalXor,"LowerBound",()=>en.LowerBound,"MatrixBandPart",()=>en.MatrixBandPart,"Max",()=>en.Max,"MaxPool",()=>en.MaxPool,"MaxPool3D",()=>en.MaxPool3D,"MaxPool3DGrad",()=>en.MaxPool3DGrad,"MaxPoolGrad",()=>en.MaxPoolGrad,"MaxPoolWithArgmax",()=>en.MaxPoolWithArgmax,"Maximum",()=>en.Maximum,"Mean",()=>en.Mean,"Min",()=>en.Min,"Minimum",()=>en.Minimum,"MirrorPad",()=>en.MirrorPad,"Mod",()=>en.Mod,"MomentumOptimizer",()=>W.MomentumOptimizer,"Multinomial",()=>en.Multinomial,"Multiply",()=>en.Multiply,"Neg",()=>en.Neg,"NonMaxSuppressionV3",()=>en.NonMaxSuppressionV3,"NonMaxSuppressionV4",()=>en.NonMaxSuppressionV4,"NonMaxSuppressionV5",()=>en.NonMaxSuppressionV5,"NotEqual",()=>en.NotEqual,"OP_SCOPE_SUFFIX",()=>K.OP_SCOPE_SUFFIX,"OneHot",()=>en.OneHot,"OnesLike",()=>en.OnesLike,"Optimizer",()=>U.Optimizer,"OptimizerConstructors",()=>G.OptimizerConstructors,"Pack",()=>en.Pack,"PadV2",()=>en.PadV2,"Pool",()=>en.Pool,"Pow",()=>en.Pow,"Prelu",()=>en.Prelu,"Prod",()=>en.Prod,"RMSPropOptimizer",()=>q.RMSPropOptimizer,"RaggedGather",()=>en.RaggedGather,"RaggedRange",()=>en.RaggedRange,"RaggedTensorToTensor",()=>en.RaggedTensorToTensor,"Range",()=>en.Range,"Rank",()=>j.Rank,"Real",()=>en.Real,"RealDiv",()=>en.RealDiv,"Reciprocal",()=>en.Reciprocal,"Reduction",()=>X.Reduction,"Relu",()=>en.Relu,"Relu6",()=>en.Relu6,"Reshape",()=>en.Reshape,"ResizeBilinear",()=>en.ResizeBilinear,"ResizeBilinearGrad",()=>en.ResizeBilinearGrad,"ResizeNearestNeighbor",()=>en.ResizeNearestNeighbor,"ResizeNearestNeighborGrad",()=>en.ResizeNearestNeighborGrad,"Reverse",()=>en.Reverse,"RotateWithOffset",()=>en.RotateWithOffset,"Round",()=>en.Round,"Rsqrt",()=>en.Rsqrt,"SGDOptimizer",()=>H.SGDOptimizer,"ScatterNd",()=>en.ScatterNd,"SearchSorted",()=>en.SearchSorted,"Select",()=>en.Select,"Selu",()=>en.Selu,"Sigmoid",()=>en.Sigmoid,"Sign",()=>en.Sign,"Sin",()=>en.Sin,"Sinh",()=>en.Sinh,"Slice",()=>en.Slice,"Softmax",()=>en.Softmax,"Softplus",()=>en.Softplus,"SpaceToBatchND",()=>en.SpaceToBatchND,"SparseFillEmptyRows",()=>en.SparseFillEmptyRows,"SparseReshape",()=>en.SparseReshape,"SparseSegmentMean",()=>en.SparseSegmentMean,"SparseSegmentSum",()=>en.SparseSegmentSum,"SparseToDense",()=>en.SparseToDense,"SplitV",()=>en.SplitV,"Sqrt",()=>en.Sqrt,"Square",()=>en.Square,"SquaredDifference",()=>en.SquaredDifference,"StaticRegexReplace",()=>en.StaticRegexReplace,"Step",()=>en.Step,"StridedSlice",()=>en.StridedSlice,"StringNGrams",()=>en.StringNGrams,"StringSplit",()=>en.StringSplit,"StringToHashBucketFast",()=>en.StringToHashBucketFast,"Sub",()=>en.Sub,"Sum",()=>en.Sum,"Tan",()=>en.Tan,"Tanh",()=>en.Tanh,"Tensor",()=>O.Tensor,"TensorBuffer",()=>O.TensorBuffer,"TensorScatterUpdate",()=>en.TensorScatterUpdate,"Tile",()=>en.Tile,"TopK",()=>en.TopK,"Transform",()=>en.Transform,"Transpose",()=>en.Transpose,"Unique",()=>en.Unique,"Unpack",()=>en.Unpack,"UnsortedSegmentSum",()=>en.UnsortedSegmentSum,"UpperBound",()=>en.UpperBound,"Variable",()=>O.Variable,"ZerosLike",()=>en.ZerosLike,"_FusedMatMul",()=>en._FusedMatMul,"abs",()=>K.abs,"acos",()=>K.acos,"acosh",()=>K.acosh,"add",()=>K.add,"addN",()=>K.addN,"all",()=>K.all,"any",()=>K.any,"argMax",()=>K.argMax,"argMin",()=>K.argMin,"asin",()=>K.asin,"asinh",()=>K.asinh,"atan",()=>K.atan,"atan2",()=>K.atan2,"atanh",()=>K.atanh,"avgPool",()=>K.avgPool,"avgPool3d",()=>K.avgPool3d,"backend",()=>Y.backend,"backend_util",()=>_,"basicLSTMCell",()=>K.basicLSTMCell,"batchNorm",()=>K.batchNorm,"batchNorm2d",()=>K.batchNorm2d,"batchNorm3d",()=>K.batchNorm3d,"batchNorm4d",()=>K.batchNorm4d,"batchToSpaceND",()=>K.batchToSpaceND,"bincount",()=>K.bincount,"bitwiseAnd",()=>K.bitwiseAnd,"booleanMaskAsync",()=>K.booleanMaskAsync,"broadcastArgs",()=>K.broadcastArgs,"broadcastTo",()=>K.broadcastTo,"broadcast_util",()=>p,"browser",()=>d,"buffer",()=>K.buffer,"cast",()=>K.cast,"ceil",()=>K.ceil,"clipByValue",()=>K.clipByValue,"clone",()=>K.clone,"complex",()=>K.complex,"concat",()=>K.concat,"concat1d",()=>K.concat1d,"concat2d",()=>K.concat2d,"concat3d",()=>K.concat3d,"concat4d",()=>K.concat4d,"conv1d",()=>K.conv1d,"conv2d",()=>K.conv2d,"conv2dTranspose",()=>K.conv2dTranspose,"conv3d",()=>K.conv3d,"conv3dTranspose",()=>K.conv3dTranspose,"copyRegisteredKernels",()=>J.copyRegisteredKernels,"cos",()=>K.cos,"cosh",()=>K.cosh,"cosineWindow",()=>K.cosineWindow,"cumprod",()=>K.cumprod,"cumsum",()=>K.cumsum,"customGrad",()=>Q.customGrad,"denseBincount",()=>K.denseBincount,"deprecationWarn",()=>Y.deprecationWarn,"depthToSpace",()=>K.depthToSpace,"depthwiseConv2d",()=>K.depthwiseConv2d,"device_util",()=>M,"diag",()=>K.diag,"dilation2d",()=>K.dilation2d,"disableDeprecationWarnings",()=>Y.disableDeprecationWarnings,"dispose",()=>Y.dispose,"disposeVariables",()=>Y.disposeVariables,"div",()=>K.div,"divNoNan",()=>K.divNoNan,"dot",()=>K.dot,"dropout",()=>K.dropout,"einsum",()=>K.einsum,"elu",()=>K.elu,"enableDebugMode",()=>Y.enableDebugMode,"enableProdMode",()=>Y.enableProdMode,"enclosingPowerOfTwo",()=>K.enclosingPowerOfTwo,"engine",()=>Y.engine,"ensureShape",()=>K.ensureShape,"env",()=>ee.env,"equal",()=>K.equal,"erf",()=>K.erf,"euclideanNorm",()=>K.euclideanNorm,"exp",()=>K.exp,"expandDims",()=>K.expandDims,"expm1",()=>K.expm1,"eye",()=>K.eye,"fft",()=>K.fft,"fill",()=>K.fill,"findBackend",()=>Y.findBackend,"findBackendFactory",()=>Y.findBackendFactory,"floor",()=>K.floor,"floorDiv",()=>K.floorDiv,"fused",()=>K.fused,"gather",()=>K.gather,"gatherND",()=>K.gatherND,"gather_util",()=>c,"getBackend",()=>Y.getBackend,"getGradient",()=>J.getGradient,"getKernel",()=>J.getKernel,"getKernelsForBackend",()=>J.getKernelsForBackend,"grad",()=>Q.grad,"grads",()=>Q.grads,"greater",()=>K.greater,"greaterEqual",()=>K.greaterEqual,"ifft",()=>K.ifft,"imag",()=>K.imag,"image",()=>K.image,"inTopKAsync",()=>K.inTopKAsync,"io",()=>t,"irfft",()=>K.irfft,"isFinite",()=>K.isFinite,"isInf",()=>K.isInf,"isNaN",()=>K.isNaN,"keep",()=>Y.keep,"kernel_impls",()=>L,"leakyRelu",()=>K.leakyRelu,"less",()=>K.less,"lessEqual",()=>K.lessEqual,"linalg",()=>K.linalg,"linspace",()=>K.linspace,"localResponseNormalization",()=>K.localResponseNormalization,"log",()=>K.log,"log1p",()=>K.log1p,"logSigmoid",()=>K.logSigmoid,"logSoftmax",()=>K.logSoftmax,"logSumExp",()=>K.logSumExp,"logicalAnd",()=>K.logicalAnd,"logicalNot",()=>K.logicalNot,"logicalOr",()=>K.logicalOr,"logicalXor",()=>K.logicalXor,"losses",()=>K.losses,"lowerBound",()=>K.lowerBound,"matMul",()=>K.matMul,"math",()=>h,"max",()=>K.max,"maxPool",()=>K.maxPool,"maxPool3d",()=>K.maxPool3d,"maxPoolWithArgmax",()=>K.maxPoolWithArgmax,"maximum",()=>K.maximum,"mean",()=>K.mean,"memory",()=>Y.memory,"meshgrid",()=>K.meshgrid,"min",()=>K.min,"minimum",()=>K.minimum,"mirrorPad",()=>K.mirrorPad,"mod",()=>K.mod,"moments",()=>K.moments,"movingAverage",()=>K.movingAverage,"mul",()=>K.mul,"multiRNNCell",()=>K.multiRNNCell,"multinomial",()=>K.multinomial,"neg",()=>K.neg,"nextFrame",()=>et.nextFrame,"norm",()=>K.norm,"notEqual",()=>K.notEqual,"oneHot",()=>K.oneHot,"ones",()=>K.ones,"onesLike",()=>K.onesLike,"op",()=>K.op,"outerProduct",()=>K.outerProduct,"pad",()=>K.pad,"pad1d",()=>K.pad1d,"pad2d",()=>K.pad2d,"pad3d",()=>K.pad3d,"pad4d",()=>K.pad4d,"pool",()=>K.pool,"pow",()=>K.pow,"prelu",()=>K.prelu,"print",()=>K.print,"prod",()=>K.prod,"profile",()=>Y.profile,"raggedGather",()=>K.raggedGather,"raggedRange",()=>K.raggedRange,"raggedTensorToTensor",()=>K.raggedTensorToTensor,"rand",()=>K.rand,"randomGamma",()=>K.randomGamma,"randomNormal",()=>K.randomNormal,"randomStandardNormal",()=>K.randomStandardNormal,"randomUniform",()=>K.randomUniform,"randomUniformInt",()=>K.randomUniformInt,"range",()=>K.range,"ready",()=>Y.ready,"real",()=>K.real,"reciprocal",()=>K.reciprocal,"registerBackend",()=>Y.registerBackend,"registerGradient",()=>J.registerGradient,"registerKernel",()=>J.registerKernel,"relu",()=>K.relu,"relu6",()=>K.relu6,"removeBackend",()=>Y.removeBackend,"reshape",()=>K.reshape,"reverse",()=>K.reverse,"reverse1d",()=>K.reverse1d,"reverse2d",()=>K.reverse2d,"reverse3d",()=>K.reverse3d,"reverse4d",()=>K.reverse4d,"rfft",()=>K.rfft,"round",()=>K.round,"rsqrt",()=>K.rsqrt,"scalar",()=>K.scalar,"scatterND",()=>K.scatterND,"scatter_util",()=>f,"searchSorted",()=>K.searchSorted,"selu",()=>K.selu,"separableConv2d",()=>K.separableConv2d,"serialization",()=>g,"setBackend",()=>Y.setBackend,"setPlatform",()=>Y.setPlatform,"setdiff1dAsync",()=>K.setdiff1dAsync,"sigmoid",()=>K.sigmoid,"sign",()=>K.sign,"signal",()=>K.signal,"sin",()=>K.sin,"sinh",()=>K.sinh,"slice",()=>K.slice,"slice1d",()=>K.slice1d,"slice2d",()=>K.slice2d,"slice3d",()=>K.slice3d,"slice4d",()=>K.slice4d,"slice_util",()=>m,"softmax",()=>K.softmax,"softplus",()=>K.softplus,"spaceToBatchND",()=>K.spaceToBatchND,"sparse",()=>K.sparse,"sparseToDense",()=>K.sparseToDense,"spectral",()=>K.spectral,"split",()=>K.split,"sqrt",()=>K.sqrt,"square",()=>K.square,"squaredDifference",()=>K.squaredDifference,"squeeze",()=>K.squeeze,"stack",()=>K.stack,"step",()=>K.step,"stridedSlice",()=>K.stridedSlice,"string",()=>K.string,"sub",()=>K.sub,"sum",()=>K.sum,"sumOutType",()=>j.sumOutType,"tan",()=>K.tan,"tanh",()=>K.tanh,"tensor",()=>K.tensor,"tensor1d",()=>K.tensor1d,"tensor2d",()=>K.tensor2d,"tensor3d",()=>K.tensor3d,"tensor4d",()=>K.tensor4d,"tensor5d",()=>K.tensor5d,"tensor6d",()=>K.tensor6d,"tensorScatterUpdate",()=>K.tensorScatterUpdate,"tensor_util",()=>y,"test_util",()=>R,"tidy",()=>Y.tidy,"tile",()=>K.tile,"time",()=>Y.time,"topk",()=>K.topk,"train",()=>Z.train,"transpose",()=>K.transpose,"truncatedNormal",()=>K.truncatedNormal,"unique",()=>K.unique,"unregisterGradient",()=>J.unregisterGradient,"unregisterKernel",()=>J.unregisterKernel,"unsortedSegmentSum",()=>K.unsortedSegmentSum,"unstack",()=>K.unstack,"upcastType",()=>j.upcastType,"upperBound",()=>K.upperBound,"util",()=>D,"valueAndGrad",()=>Q.valueAndGrad,"valueAndGrads",()=>Q.valueAndGrads,"variable",()=>K.variable,"variableGrads",()=>Q.variableGrads,"version_core",()=>F.version,"where",()=>K.where,"whereAsync",()=>K.whereAsync,"zeros",()=>K.zeros,"zerosLike",()=>K.zerosLike],6851)},12592,(e,t,r)=>{e.e,function(e,t,r){"use strict";let n={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class a{constructor(e,t){this.modelPath=t||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(e)}/model.json`}getPrefix(e){return"lite_mobilenet_v2"===e?`ssd${e}`:`ssd_${e}`}async load(){this.model=await t.loadGraphModel(this.modelPath);let e=r.zeros([1,300,300,3],"int32"),n=await this.model.executeAsync(e);await Promise.all(n.map(e=>e.data())),n.map(e=>e.dispose()),e.dispose()}async infer(e,t,n){let a=r.tidy(()=>(e instanceof r.Tensor||(e=r.browser.fromPixels(e)),r.expandDims(e))),s=a.shape[1],i=a.shape[2],o=await this.model.executeAsync(a),l=o[0].dataSync(),u=o[1].dataSync();a.dispose(),r.dispose(o);let[h,p]=this.calculateMaxScores(l,o[0].shape[1],o[0].shape[2]),d=r.getBackend();"webgl"===r.getBackend()&&r.setBackend("cpu");let c=r.tidy(()=>{let e=r.tensor2d(u,[o[1].shape[1],o[1].shape[3]]);return r.image.nonMaxSuppression(e,h,t,n,n)}),f=c.dataSync();return c.dispose(),d!==r.getBackend()&&r.setBackend(d),this.buildDetectedObjects(i,s,u,h,f,p)}buildDetectedObjects(e,t,r,a,s,i){let o=s.length,l=[];for(let u=0;u<o;u++){let o=[];for(let e=0;e<4;e++)o[e]=r[4*s[u]+e];let h=o[0]*t,p=o[1]*e,d=o[2]*t,c=o[3]*e;o[0]=p,o[1]=h,o[2]=c-p,o[3]=d-h,l.push({bbox:o,class:n[i[s[u]]+1].displayName,score:a[s[u]]})}return l}calculateMaxScores(e,t,r){let n=[],a=[];for(let s=0;s<t;s++){let t=5e-324,i=-1;for(let n=0;n<r;n++)e[s*r+n]>t&&(t=e[s*r+n],i=n);n[s]=t,a[s]=i}return[n,a]}async detect(e,t=20,r=.5){return this.infer(e,t,r)}dispose(){null!=this.model&&this.model.dispose()}}e.ObjectDetection=a,e.load=async function(e={}){if(null==r)throw Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");let t=e.base||"lite_mobilenet_v2",n=e.modelUrl;if(-1===["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(t))throw Error(`ObjectDetection constructed with invalid base model ${t}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);let s=new a(t,n);return await s.load(),s},e.version="2.2.3",Object.defineProperty(e,"__esModule",{value:!0})}(r,e.r(47493),e.r(6851))},50461,e=>{"use strict";let t,r,n,a;var s,i,o,l,u,h,p,d,c,f,m,g,y=e.i(43476),b=e.i(71645);let x=e=>{let t=e.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,t,r)=>r?r.toUpperCase():t.toLowerCase());return t.charAt(0).toUpperCase()+t.slice(1)},v=(...e)=>e.filter((e,t,r)=>!!e&&""!==e.trim()&&r.indexOf(e)===t).join(" ").trim();var w={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};let S=(0,b.forwardRef)(({color:e="currentColor",size:t=24,strokeWidth:r=2,absoluteStrokeWidth:n,className:a="",children:s,iconNode:i,...o},l)=>(0,b.createElement)("svg",{ref:l,...w,width:t,height:t,stroke:e,strokeWidth:n?24*Number(r)/Number(t):r,className:v("lucide",a),...!s&&!(e=>{for(let t in e)if(t.startsWith("aria-")||"role"===t||"title"===t)return!0})(o)&&{"aria-hidden":"true"},...o},[...i.map(([e,t])=>(0,b.createElement)(e,t)),...Array.isArray(s)?s:[s]])),N=(e,t)=>{let r=(0,b.forwardRef)(({className:r,...n},a)=>(0,b.createElement)(S,{ref:a,iconNode:t,className:v(`lucide-${x(e).replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()}`,`lucide-${e}`,r),...n}));return r.displayName=x(e),r},k=N("camera",[["path",{d:"M13.997 4a2 2 0 0 1 1.76 1.05l.486.9A2 2 0 0 0 18.003 7H20a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h1.997a2 2 0 0 0 1.759-1.048l.489-.904A2 2 0 0 1 10.004 4z",key:"18u6gg"}],["circle",{cx:"12",cy:"13",r:"3",key:"1vg3eu"}]]),I=N("square",[["rect",{width:"18",height:"18",x:"3",y:"3",rx:"2",key:"afitv7"}]]);var T=e.i(12592);e.i(70306);var C=e.i(75660),E=e.i(62836),$=e.i(83333),A=e.i(27e3);let R={kernelName:C.Abs,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,$.mul)(e,(0,A.step)((0,E.cast)(r,"float32"),-1))}}};var D=e.i(11857),F=e.i(95528),O=e.i(83654),_=e.i(39048),M=e.i(96724),L=e.i(76413);let z={kernelName:C.Acos,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>{let t=(0,M.square)((0,E.cast)(r,"float32")),n=(0,_.sqrt)((0,L.sub)((0,O.scalar)(1),t));return(0,F.neg)((0,D.div)(e,n))}}}},P={kernelName:C.Acosh,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>{let t=(0,_.sqrt)((0,L.sub)((0,M.square)((0,E.cast)(r,"float32")),1));return(0,D.div)(e,t)}}}};var B=e.i(42242),V=e.i(74647),W=e.i(33192);let U={kernelName:C.Add,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,a=B.assertAndGetBroadcastShape(r.shape,n.shape);return{a:()=>{let t=e,n=B.getReductionAxes(r.shape,a);return n.length>0&&(t=(0,W.sum)(t,n)),(0,V.reshape)(t,r.shape)},b:()=>{let t=e,r=B.getReductionAxes(n.shape,a);return r.length>0&&(t=(0,W.sum)(t,r)),(0,V.reshape)(t,n.shape)}}}},G={kernelName:C.AddN,saveAllInputs:!0,gradFunc:(e,t)=>{let r={};return t.forEach((t,n)=>{r[n]=()=>e.clone()}),r}};var q=e.i(17616);let H={kernelName:C.ArgMax,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,q.zerosLike)(r)}}},j={kernelName:C.ArgMin,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,q.zerosLike)(r)}}},K={kernelName:C.Asin,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,D.div)(e,(0,_.sqrt)((0,L.sub)((0,O.scalar)(1),(0,M.square)((0,E.cast)(r,"float32")))))}}};var X=e.i(19344);let Z={kernelName:C.Asinh,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>{let t=(0,_.sqrt)((0,X.add)((0,O.scalar)(1),(0,M.square)((0,E.cast)(r,"float32"))));return(0,D.div)(e,t)}}}},Y={kernelName:C.Atan2,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,a=(0,B.assertAndGetBroadcastShape)(r.shape,n.shape);return{a:()=>{let t=(0,X.add)((0,M.square)(r),(0,M.square)(n)),s=(0,$.mul)(e,(0,D.div)(n,t)),i=(0,B.getReductionAxes)(r.shape,a);return i.length>0&&(s=(0,W.sum)(s,i)),(0,V.reshape)(s,r.shape)},b:()=>{let t=(0,X.add)((0,M.square)(r),(0,M.square)(n)),s=(0,F.neg)((0,$.mul)(e,(0,D.div)(r,t))),i=(0,B.getReductionAxes)(n.shape,a);return i.length>0&&(s=(0,W.sum)(s,i)),(0,V.reshape)(s,n.shape)}}}},J={kernelName:C.Atan,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,D.div)(e,(0,X.add)((0,M.square)((0,E.cast)(r,"float32")),1))}}},Q={kernelName:C.Atanh,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,D.div)(e,(0,L.sub)((0,O.scalar)(1),(0,M.square)((0,E.cast)(r,"float32"))))}}};var ee=e.i(24452),et=e.i(59551),er=e.i(86879),en=e.i(19813),ea=e.i(33977);let es=(0,ea.op)({avgPool3dGrad_:function(e,t,r,n,a,s){let i=(0,et.convertToTensor)(e,"dy","avgPool3dGrad"),o=(0,et.convertToTensor)(t,"input","avgPool3dGrad"),l=i,u=o,h=!1;4===o.rank&&(h=!0,l=(0,V.reshape)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=(0,V.reshape)(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),er.assert(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),er.assert(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),(0,en.checkPadOnDimRoundingMode)("avgPool3dGrad",a,s);let p={dy:l,input:u},d=ee.ENGINE.runKernel(C.AvgPool3DGrad,p,{filterSize:r,strides:n,pad:a,dimRoundingMode:s});return h?(0,V.reshape)(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),ei={kernelName:C.AvgPool3D,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=r;return{x:()=>es(e,n,a,s,i,o)}}},eo=(0,ea.op)({avgPoolGrad_:function(e,t,r,n,a){let s=(0,et.convertToTensor)(e,"dy","avgPoolGrad"),i=(0,et.convertToTensor)(t,"input","avgPoolGrad");er.assert(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,l=s,u=!1;3===i.rank&&(u=!0,o=(0,V.reshape)(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=(0,V.reshape)(s,[1,s.shape[0],s.shape[1],s.shape[2]])),er.assert(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),er.assert(4===o.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let h={dy:l,input:o},p=ee.ENGINE.runKernel(C.AvgPoolGrad,h,{filterSize:r,strides:n,pad:a});return u?(0,V.reshape)(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),el={kernelName:C.AvgPool,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{filterSize:a,strides:s,pad:i}=r;return{x:()=>eo(e,n,a,s,i)}}};var eu=e.i(91555);let eh={kernelName:C.BatchMatMul,inputsToSave:["a","b"],gradFunc:(e,t,r)=>{let[n,a]=t,{transposeA:s,transposeB:i}=r;return s||i?!s&&i?{a:()=>(0,eu.matMul)(e,a,!1,!1),b:()=>(0,eu.matMul)(e,n,!0,!1)}:s&&!i?{a:()=>(0,eu.matMul)(a,e,!1,!0),b:()=>(0,eu.matMul)(n,e,!1,!1)}:{a:()=>(0,eu.matMul)(a,e,!0,!0),b:()=>(0,eu.matMul)(e,n,!0,!0)}:{a:()=>(0,eu.matMul)(e,a,!1,!0),b:()=>(0,eu.matMul)(n,e,!0,!1)}}};var ep=e.i(22947);let ed={kernelName:C.BatchToSpaceND,gradFunc:(e,t,r)=>{let{blockShape:n,crops:a}=r;return{x:()=>(0,ep.spaceToBatchND)(e,n,a)}}},ec={kernelName:C.BroadcastTo,gradFunc:(e,t,r)=>{let n=r.inputShape,a=r.shape,s=Array.from(a);for(let e=n.length-1;e>=0;e--)if(n[e]===a[e])s[e]=1;else if(1!==n[e])throw Error(`broadcastTo(): [${n}] cannot be broadcast to [${a}].`);let i=[];for(let e=0;e<s.length;e++)s[e]>1&&i.push(e);return{x:()=>(0,W.sum)(e,i,!0)}}},ef={kernelName:C.Cast,gradFunc:e=>({x:()=>e.clone()})},em={kernelName:C.Ceil,gradFunc:e=>({x:()=>(0,q.zerosLike)(e)})};var eg=e.i(67781),ey=e.i(85522),eb=e.i(87626),ex=e.i(10493);let ev={kernelName:C.ClipByValue,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{clipValueMin:a,clipValueMax:s}=r;return{x:()=>(0,ex.where)((0,eb.logicalAnd)((0,eg.greaterEqual)(n,a),(0,ey.lessEqual)(n,s)),e,(0,q.zerosLike)(e))}}},ew={kernelName:C.ComplexAbs,inputsToSave:["x"],gradFunc:R.gradFunc};var eS=e.i(49506);let eN={kernelName:C.Concat,saveAllInputs:!0,gradFunc:(e,t,r)=>{let n=t.map(e=>e.shape),{axis:a}=r,s=(0,er.parseAxisParam)(a,t[0].shape)[0],i=n.map(e=>e[s]);return(0,eS.split)(e,i,s).map(e=>()=>e)}};var ek=e.i(31837),eI=e.i(35032);let eT={kernelName:C.Conv2D,inputsToSave:["x","filter"],gradFunc:(e,t,r)=>{let[n,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=r;return er.assert(en.tupleValuesAreOne(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>(0,eI.conv2DBackpropInput)(n.shape,e,a,i,o,l),filter:()=>(0,ek.conv2DBackpropFilter)(n,e,a.shape,i,o,l)}}};var eC=e.i(97529);let eE={kernelName:C.Conv2DBackpropInput,inputsToSave:["dy","filter"],gradFunc:(e,t,r)=>{let[n,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=r;return{dy:()=>(0,eC.conv2d)(e,a,s,i,o,1,l),filter:()=>(0,ek.conv2DBackpropFilter)(e,n,a.shape,s,i,o,l)}}},e$=(0,ea.op)({conv3DBackpropFilter_:function(e,t,r,n,a){let s=e;4===e.rank&&(s=(0,V.reshape)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=(0,V.reshape)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),er.assert(5===s.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),er.assert(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),er.assert(5===r.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${r}.`),er.assert(s.shape[4]===r[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${r[3]}.`),er.assert(i.shape[4]===r[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${r[4]}).`);let o={x:s,dy:i};return ee.ENGINE.runKernel(C.Conv3DBackpropFilterV2,o,{strides:n,pad:a,filterShape:r})}});var eA=e.i(22525);let eR={kernelName:C.Conv3D,inputsToSave:["x","filter"],gradFunc:(e,t,r)=>{let{dilations:n,strides:a,pad:s}=r;er.assert((0,en.tupleValuesAreOne)(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[i,o]=t;return{x:()=>(0,eA.conv3DBackpropInput)(i.shape,e,o,a,s),filter:()=>e$(i,e,o.shape,a,s)}}};var eD=e.i(49729);let eF={kernelName:C.Cos,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,$.mul)((0,F.neg)((0,eD.sin)((0,E.cast)(r,"float32"))),e)}}};var eO=e.i(41001);let e_={kernelName:C.Cosh,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,$.mul)((0,eO.sinh)((0,E.cast)(r,"float32")),e)}}};var eM=e.i(15401),eL=e.i(60949),ez=e.i(90049);let eP={kernelName:C.Cumsum,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{axis:a,exclusive:s,reverse:i}=r;return{x:()=>{let t=(0,eM.getAxesPermutation)([a],n.rank),r=(0,eL.cumsum)(e,a,s,!i);return null!=t&&(r=(0,ez.transpose)(r,t)),r}}}};var eB=e.i(41589),eV=e.i(96996);let eW={kernelName:C.DepthwiseConv2dNative,inputsToSave:["x","filter"],gradFunc:(e,t,r)=>{let{dilations:n,strides:a,pad:s,dimRoundingMode:i}=r,o=null==n?[1,1]:n;er.assert(en.tupleValuesAreOne(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,u]=t;return er.assert(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),er.assert(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),er.assert(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),er.assert(en.eitherStridesOrDilationsAreOne(a,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`),en.checkPadOnDimRoundingMode("depthwiseConv2d",s,i),{x:()=>(0,eV.depthwiseConv2dNativeBackpropInput)(l.shape,e,u,a,s,o,i),filter:()=>(0,eB.depthwiseConv2dNativeBackpropFilter)(l,e,u.shape,a,s,o,i)}}},eU={kernelName:C.Dilation2D,inputsToSave:["x","filter"],gradFunc:(e,t,r)=>{let[n,a]=t,s={x:n,filter:a,dy:e},i={x:n,filter:a,dy:e};return{x:()=>ee.ENGINE.runKernel(C.Dilation2DBackpropInput,s,r),filter:()=>ee.ENGINE.runKernel(C.Dilation2DBackpropFilter,i,r)}}},eG={kernelName:C.Elu,outputsToSave:[!0],gradFunc:(e,t)=>{let[r]=t,n={dy:e,y:r};return{x:()=>ee.ENGINE.runKernel(C.EluGrad,n)}}};var eq=e.i(7970);let eH={kernelName:C.Erf,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t,n=(0,$.mul)((0,eq.exp)((0,F.neg)((0,M.square)(r))),2/Math.sqrt(Math.PI));return{x:()=>(0,$.mul)(e,n)}}},ej={kernelName:C.Exp,outputsToSave:[!0],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,$.mul)(e,r)}}},eK={kernelName:C.ExpandDims,inputsToSave:["input"],gradFunc:(e,t)=>{let[r]=t;return{input:()=>(0,V.reshape)(e,r.shape)}}},eX={kernelName:C.Expm1,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,$.mul)(e,(0,eq.exp)(r))}}},eZ={kernelName:C.Floor,gradFunc:e=>({x:()=>(0,q.zerosLike)(e)})},eY={kernelName:C.FloorDiv,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,a=(0,B.assertAndGetBroadcastShape)(r.shape,n.shape);return{a:()=>{let t=(0,D.div)(e,(0,E.cast)(n,"float32")),s=(0,B.getReductionAxes)(r.shape,a);return s.length>0?(0,V.reshape)((0,W.sum)(t,s),r.shape):t},b:()=>{let t=(0,$.mul)(e,(0,E.cast)(r,"float32")),s=(0,B.getReductionAxes)(n.shape,a);s.length>0&&(t=(0,V.reshape)((0,W.sum)(t,s),n.shape));let i=(0,M.square)(n);return(0,F.neg)((0,D.div)(t,(0,E.cast)(i,"float32")))}}}};var eJ=e.i(56367),eQ=e.i(44587);let e0={kernelName:C.FusedBatchNorm,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,r)=>{let{varianceEpsilon:n}=r,[a,s,i,o]=t,l=null==o?(0,O.scalar)(1):o,u=(0,B.getReductionAxes)(s.shape,a.shape),h=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)h.push(a.shape[e]);h.push(1)}let p=(0,L.sub)(a,s),d=(0,$.mul)(e,l),c=(0,eJ.rsqrt)((0,X.add)(i,(0,O.scalar)(n))),f=(0,$.mul)((0,$.mul)((0,$.mul)(c,c),c),(0,O.scalar)(-.5));return{x:()=>1===s.rank?(0,V.reshape)((0,$.mul)((0,$.mul)(e,(0,eQ.tile)((0,V.reshape)(c,[1,1,1,s.shape[0]]),h)),l),a.shape):(0,V.reshape)((0,$.mul)((0,$.mul)(e,c),l),a.shape),mean:()=>{let e=(0,$.mul)((0,$.mul)(c,(0,O.scalar)(-1)),d);return 1===s.rank&&(e=(0,W.sum)(e,u)),(0,V.reshape)(e,s.shape)},variance:()=>{let e=(0,$.mul)((0,$.mul)(f,p),d);return 1===s.rank&&(e=(0,W.sum)(e,u)),(0,V.reshape)(e,s.shape)},scale:()=>{let t=(0,$.mul)(p,c),r=(0,$.mul)(e,t);return 1===s.rank&&(r=(0,W.sum)(r,u)),(0,V.reshape)(r,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=(0,W.sum)(t,u)),(0,V.reshape)(t,s.shape)}}}};var e1=e.i(42130),e2=e.i(73934);let e3={kernelName:C.GatherV2,inputsToSave:["x","indices"],gradFunc:(e,t,r)=>{let[n,a]=t,{axis:s,batchDims:i}=r,o=(0,er.parseAxisParam)(s,n.shape)[0],l=(e,t,r)=>()=>{let n=e.shape,a=t.size,i=n.slice(0,o),l=i.length,u=n.slice(s,n.length).slice(1),h=u.length,p=e4(0,l),d=e4(l+1,l+1+h),c=e6([i,[a],u]),f=(0,V.reshape)(r,c),m=(0,V.reshape)(t,[a]),g=e6([[l],p,d]),y=(0,ez.transpose)(f,g),b=(0,e2.unsortedSegmentSum)(y,m,e.shape[o]),x=(0,eM.getUndoAxesPermutation)(g);return(0,ez.transpose)(b,x)};if(1!==i)return{x:l(n,a,e),indices:()=>a};{let t=n.shape[0],r=n.split(t,0);return{x:()=>(0,e1.stack)(r.map((t,r)=>l(t,a.slice(r,1),e.slice(r,1))())).reshape(n.shape),indices:()=>a}}}};function e4(e,t){let r=[];for(let n=e;n<t;++n)r.push(n);return r}function e6(e){let t=[];for(let r=0;r<e.length;++r)for(let n=0;n<e[r].length;++n)t.push(e[r][n]);return t}let e5={kernelName:C.GreaterEqual,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t;return{a:()=>(0,q.zerosLike)(r),b:()=>(0,q.zerosLike)(n)}}},e8={kernelName:C.Identity,gradFunc:e=>({x:()=>(0,E.cast)(e,"float32")})},e9={kernelName:C.IsFinite,gradFunc:e=>({x:()=>(0,q.zerosLike)(e)})},e7={kernelName:C.IsInf,gradFunc:e=>({x:()=>(0,q.zerosLike)(e)})},te={kernelName:C.IsNan,gradFunc:e=>({x:()=>(0,q.zerosLike)(e)})};var tt=e.i(60164);let tr={kernelName:C.LeakyRelu,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{alpha:a}=r,s=(0,tt.greater)(n,0);return{x:()=>(0,ex.where)(s,e,(0,$.mul)(e,a))}}},tn={kernelName:C.Log1p,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,D.div)(e,(0,X.add)(r,1))}}},ta={kernelName:C.Log,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,D.div)(e,(0,E.cast)(r,"float32"))}}},ts={kernelName:C.LogSoftmax,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,r)=>{let[n]=t,{axis:a}=r;return{logits:()=>{let t=(0,eq.exp)(n);return(0,L.sub)(e,(0,$.mul)((0,W.sum)(e,a,!0),t))}}}},ti=(0,ea.op)({localResponseNormalizationBackprop_:function(e,t,r,n=5,a=1,s=1,i=.5){return ee.ENGINE.runKernel(C.LRNGrad,{x:e,y:t,dy:r},{depthRadius:n,bias:a,alpha:s,beta:i})}}),to={kernelName:C.LRN,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,r)=>{let[n,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;return{x:()=>ti(n,a,e,s,i,o,l)}}};var tl=e.i(69578);function tu(e,t,r,n){return t.rank<r.rank&&(t=(0,V.reshape)(t,eM.expandShapeToKeepDim(t.shape,n))),e.rank<r.rank&&(e=(0,V.reshape)(e,eM.expandShapeToKeepDim(e.shape,n))),{x:()=>(0,$.mul)(e,(0,E.cast)((0,tl.equal)(r,t),e.dtype))}}let th={kernelName:C.Max,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,r)=>{let{reductionIndices:n}=r,a=t[0],s=t[1],i=er.parseAxisParam(n,a.shape),o=tu(e,s,a,i);return{x:()=>o.x()}}};var tp=e.i(84812);let td={kernelName:C.Maximum,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t;return{a:()=>(0,$.mul)(e,(0,E.cast)((0,eg.greaterEqual)(r,n),"float32")),b:()=>(0,$.mul)(e,(0,E.cast)((0,tp.less)(r,n),"float32"))}}},tc=(0,ea.op)({maxPool3dGrad_:function(e,t,r,n,a,s,i){let o=(0,et.convertToTensor)(e,"dy","maxPool3dGrad"),l=(0,et.convertToTensor)(t,"input","maxPool3dGrad"),u=(0,et.convertToTensor)(r,"output","maxPool3dGrad"),h=o,p=l,d=u,c=!1;4===l.rank&&(c=!0,h=(0,V.reshape)(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),p=(0,V.reshape)(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=(0,V.reshape)(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),er.assert(5===h.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`),er.assert(5===p.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),er.assert(5===d.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),(0,en.checkPadOnDimRoundingMode)("maxPool3dGrad",s,i);let f={dy:h,input:p,output:d},m=ee.ENGINE.runKernel(C.MaxPool3DGrad,f,{filterSize:n,strides:a,pad:s,dimRoundingMode:i});return c?(0,V.reshape)(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),tf={kernelName:C.MaxPool3D,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,r)=>{let[n,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;return{x:()=>tc(e,n,a,s,i,o,l)}}},tm=(0,ea.op)({maxPoolGrad_:function(e,t,r,n,a,s,i){let o=(0,et.convertToTensor)(e,"dy","maxPoolGrad"),l=(0,et.convertToTensor)(t,"input","maxPoolGrad"),u=(0,et.convertToTensor)(r,"output","maxPoolGrad");return er.assert(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),er.assert(4===o.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),er.assert(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),en.checkPadOnDimRoundingMode("maxPoolGrad",s,i),ee.ENGINE.runKernel(C.MaxPoolGrad,{dy:o,input:l,output:u},{filterSize:n,strides:a,pad:s,dimRoundingMode:i})}}),tg={kernelName:C.MaxPool,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,r)=>{let[n,a]=t,{filterSize:s,strides:i,pad:o}=r;return{x:()=>tm(e,n,a,s,i,o)}}};var ty=e.i(99451);let tb={kernelName:C.Mean,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{axis:a}=r,s=er.parseAxisParam(a,n.shape),i=(0,eM.computeOutAndReduceShapes)(n.shape,s)[1],o=er.sizeFromShape(i);return{x:()=>{let t=n.shape.slice();s.forEach(e=>{t[e]=1});let r=(0,V.reshape)(e,t);return(0,D.div)((0,$.mul)(r,(0,ty.ones)(n.shape,"float32")),o)}}}},tx={kernelName:C.Min,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,r)=>{let{axis:n}=r,[a,s]=t,i=er.parseAxisParam(n,a.shape),o=tu(e,s,a,i);return{x:()=>o.x()}}},tv={kernelName:C.Minimum,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t;return{a:()=>(0,$.mul)(e,(0,E.cast)((0,ey.lessEqual)(r,n),"float32")),b:()=>(0,$.mul)(e,(0,E.cast)((0,tt.greater)(r,n),"float32"))}}};var tw=e.i(3116);let tS={kernelName:C.MirrorPad,inputsToSave:["x"],gradFunc:(e,t,r)=>{let n=t[0],{paddings:a}=r,s=a.map(e=>e[0]);return{x:()=>(0,tw.slice)(e,s,n.shape)}}};var tN=e.i(56691);let tk={kernelName:C.Mod,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,a=(0,B.assertAndGetBroadcastShape)(r.shape,n.shape);return{a:()=>{let t=(0,B.getReductionAxes)(r.shape,a);return t.length>0?(0,V.reshape)((0,W.sum)(e,t),r.shape):e},b:()=>{let t=(0,$.mul)(e,(0,F.neg)((0,tN.floor)((0,D.div)(r,n)))),s=(0,B.getReductionAxes)(n.shape,a);return s.length>0?(0,V.reshape)((0,W.sum)(t,s),n.shape):t}}}},tI={kernelName:C.Multiply,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,a=(0,B.assertAndGetBroadcastShape)(r.shape,n.shape);return{a:()=>{let t=(0,$.mul)(e,(0,E.cast)(n,"float32")),s=(0,B.getReductionAxes)(r.shape,a);return s.length>0?(0,V.reshape)((0,W.sum)(t,s),r.shape):t},b:()=>{let t=(0,$.mul)(e,(0,E.cast)(r,"float32")),s=(0,B.getReductionAxes)(n.shape,a);return s.length>0?(0,V.reshape)((0,W.sum)(t,s),n.shape):t}}}},tT={kernelName:C.Neg,gradFunc:e=>({x:()=>(0,F.neg)(e)})};var tC=e.i(22012);let tE={kernelName:C.OneHot,inputsToSave:["indices"],gradFunc:(e,t)=>{let r=t[0];return{indices:()=>(0,tC.zeros)(r.shape,"float32")}}},t$={kernelName:C.OnesLike,gradFunc:e=>({x:()=>(0,q.zerosLike)(e)})};var tA=e.i(33236);let tR={kernelName:C.Pack,saveAllInputs:!0,gradFunc:(e,t,r)=>{let{axis:n}=r;return(0,tA.unstack)(e,n).map(e=>()=>e)}},tD={kernelName:C.PadV2,inputsToSave:["x"],gradFunc:(e,t,r)=>{let n=t[0],{paddings:a}=r,s=a.map(e=>e[0]);return{x:()=>(0,tw.slice)(e,s,n.shape)}}};var tF=e.i(98317),tO=e.i(16181);let t_={kernelName:C.Pow,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[r,n,a]=t,s=B.assertAndGetBroadcastShape(r.shape,n.shape);return{a:()=>{let t=(0,E.cast)(n,"float32"),a=(0,$.mul)(e,(0,$.mul)(t,(0,tO.pow)(r,(0,L.sub)(t,(0,O.scalar)(1))))),i=B.getReductionAxes(r.shape,s);return i.length>0&&(a=(0,W.sum)(a,i)),(0,V.reshape)(a,r.shape)},b:()=>{let t=(0,tt.greater)(r,0),i=(0,ex.where)(t,(0,tF.log)(r),(0,q.zerosLike)(r)),o=(0,$.mul)(e,(0,$.mul)(a,i)),l=B.getReductionAxes(n.shape,s);return l.length>0&&(o=(0,W.sum)(o,l)),(0,V.reshape)(o,n.shape)}}}},tM={kernelName:C.Prelu,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[r,n]=t,a=(0,tt.greater)(r,0);return{x:()=>(0,ex.where)(a,e,(0,$.mul)(e,n)),alpha:()=>{let t=(0,ex.where)(a,(0,q.zerosLike)(e),(0,$.mul)(e,r)),s=(0,B.getReductionAxes)(n.shape,e.shape);return s.length>0&&(t=(0,W.sum)(t,s)),(0,V.reshape)(t,n.shape)}}}};var tL=e.i(41667),tL=tL,tz=e.i(66506);let tP={kernelName:C.Prod,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{axis:a}=r,s=[];return s=null==a?n.shape.map((e,t)=>t):"number"==typeof a?[a]:a,{x:()=>(function(e,t,r){var n;let a,s,i,o,l,u=e.shape.length,h=u-r.length,p=tL.getAxesPermutation(r,u),d=e;null!=p&&(d=(0,ez.transpose)(e,p));let c=d.shape.slice(),f=c.splice(u-r.length,r.length).reduce((e,t)=>e*t,1);c.push(f);let m=(n=d.reshape(c),(a=n.shape.slice())[h]=1,s=(0,V.reshape)(t,a),i=(0,tz.cumprod)(n,h,!0,!1),o=(0,tz.cumprod)(n,h,!0,!0),l=(0,$.mul)(i,o),(0,$.mul)(s,l));if(m=m.reshape(d.shape),null!=p){let e=tL.getUndoAxesPermutation(p);m=(0,ez.transpose)(m,e)}return m})(n,e,s)}}},tB={kernelName:C.RealDiv,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,a=B.assertAndGetBroadcastShape(r.shape,n.shape);return{a:()=>{let t=(0,D.div)(e,(0,E.cast)(n,"float32")),s=B.getReductionAxes(r.shape,a);return s.length>0?(0,V.reshape)((0,W.sum)(t,s),r.shape):t},b:()=>{let t=(0,$.mul)(e,(0,E.cast)(r,"float32")),s=B.getReductionAxes(n.shape,a);s.length>0&&(t=(0,V.reshape)((0,W.sum)(t,s),n.shape));let i=(0,M.square)(n);return(0,F.neg)((0,D.div)(t,(0,E.cast)(i,"float32")))}}}},tV={kernelName:C.Reciprocal,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,D.div)(e,(0,F.neg)((0,M.square)(r)))}}},tW={kernelName:C.Relu6,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t,n=(0,$.mul)((0,ey.lessEqual)(r,6),(0,A.step)(r));return{x:()=>(0,$.mul)(e,(0,E.cast)(n,"float32"))}}},tU={kernelName:C.Relu,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,$.mul)(e,(0,E.cast)((0,A.step)(r),"float32"))}}},tG={kernelName:C.Reshape,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,V.reshape)(e,r.shape)}}},tq={kernelName:C.ResizeBilinear,inputsToSave:["images"],gradFunc:(e,t,r)=>{let[n]=t,a={dy:e,images:n};return{images:()=>ee.ENGINE.runKernel(C.ResizeBilinearGrad,a,r)}}},tH={kernelName:C.ResizeNearestNeighbor,inputsToSave:["images"],gradFunc:(e,t,r)=>{let[n]=t,a={dy:e,images:n};return{images:()=>ee.ENGINE.runKernel(C.ResizeNearestNeighborGrad,a,r)}}};var tj=e.i(2173);let tK={kernelName:C.Reverse,gradFunc:(e,t,r)=>{let{dims:n}=r,a=(0,er.parseAxisParam)(n,e.shape);return{x:()=>(0,tj.reverse)(e,a)}}},tX={kernelName:C.Round,gradFunc:e=>({x:()=>(0,q.zerosLike)(e)})},tZ={kernelName:C.Rsqrt,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,F.neg)((0,D.div)(e,(0,$.mul)((0,tO.pow)(r,1.5),2)))}}};var tY=e.i(92477);let tJ={kernelName:C.Select,inputsToSave:["condition"],gradFunc:(e,t)=>{let[r]=t;return{condition:()=>(0,E.cast)((0,q.zerosLike)(r),"float32"),t:()=>(0,$.mul)(e,(0,E.cast)(r,e.dtype)),e:()=>(0,$.mul)(e,(0,E.cast)((0,tY.logicalNot)(r),e.dtype))}}};var tQ=e.i(80109);let t0={kernelName:C.Selu,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>{let t=(0,tt.greater)(r,(0,O.scalar)(0)),n=(0,O.scalar)(tQ.SELU_SCALEALPHA),a=(0,O.scalar)(tQ.SELU_SCALE),s=(0,$.mul)(e,a),i=(0,$.mul)((0,$.mul)(e,n),(0,eq.exp)((0,E.cast)(r,"float32")));return(0,ex.where)(t,s,i)}}}},t1={kernelName:C.Sigmoid,outputsToSave:[!0],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,$.mul)(e,(0,$.mul)(r,(0,L.sub)((0,O.scalar)(1),r)))}}},t2={kernelName:C.Sign,gradFunc:e=>({x:()=>(0,q.zerosLike)(e)})};var t3=e.i(84296);let t4={kernelName:C.Sin,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,$.mul)((0,t3.cos)((0,E.cast)(r,"float32")),e)}}};var t6=e.i(33292);let t5={kernelName:C.Sinh,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,$.mul)((0,t6.cosh)((0,E.cast)(r,"float32")),e)}}};var t8=e.i(56877),t9=e.i(64791);let t7={kernelName:C.Slice,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{begin:a,size:s}=r,i=n.shape,[o,l]=(0,t9.parseSliceParams)(n,a,s),u=[];for(let t=0;t<e.rank;t++)u.push([o[t],i[t]-o[t]-l[t]]);return{x:()=>(0,t8.pad)(e,u)}}},re={kernelName:C.Softmax,outputsToSave:[!0],gradFunc:(e,t,r)=>{let[n]=t,{dim:a}=r,s=(0,$.mul)(e,n);return{logits:()=>(0,L.sub)(s,(0,$.mul)((0,W.sum)(s,[a],!0),n))}}};var rt=e.i(38015);let rr={kernelName:C.Softplus,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,$.mul)(e,(0,rt.sigmoid)(r))}}};var rn=e.i(75067);let ra={kernelName:C.SpaceToBatchND,gradFunc:(e,t,r)=>{let{blockShape:n,paddings:a}=r;return{x:()=>(0,rn.batchToSpaceND)(e,n,a)}}};var rs=e.i(48012);let ri={kernelName:C.SplitV,gradFunc:(e,t,r)=>{let{axis:n}=r;return{x:()=>(0,rs.concat)(e,n)}}},ro={kernelName:C.Sqrt,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,D.div)(e,(0,$.mul)((0,_.sqrt)((0,E.cast)(r,"float32")),2))}}},rl={kernelName:C.Square,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,$.mul)(e,(0,$.mul)((0,E.cast)(r,"float32"),2))}}},ru={kernelName:C.SquaredDifference,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,a=(0,O.scalar)(2);return{a:()=>(0,$.mul)(e,(0,$.mul)(a,(0,L.sub)(r,n))),b:()=>(0,$.mul)(e,(0,$.mul)(a,(0,L.sub)(n,r)))}}},rh={kernelName:C.Step,gradFunc:e=>({x:()=>(0,q.zerosLike)(e)})},rp={kernelName:C.Sub,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[r,n]=t,a=B.assertAndGetBroadcastShape(r.shape,n.shape);return{a:()=>{let t=e,n=B.getReductionAxes(r.shape,a);return n.length>0&&(t=(0,W.sum)(t,n)),(0,V.reshape)(t,r.shape)},b:()=>{let t=e,r=B.getReductionAxes(n.shape,a);return r.length>0&&(t=(0,W.sum)(t,r)),(0,V.reshape)((0,F.neg)(t),n.shape)}}}},rd={kernelName:C.Sum,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,a=n.shape.slice(),{axis:s}=r;(0,er.parseAxisParam)(s,n.shape).forEach(e=>{a[e]=1});let i=(0,V.reshape)(e,a),o=(0,$.mul)(i,(0,ty.ones)(n.shape,"float32"));return{x:()=>o}}},rc={kernelName:C.Tan,inputsToSave:["x"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,D.div)(e,(0,M.square)((0,t3.cos)(r)))}}},rf={kernelName:C.Tanh,outputsToSave:[!0],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(0,$.mul)((0,L.sub)((0,O.scalar)(1),(0,M.square)(r)),e)}}},rm={kernelName:C.Tile,inputsToSave:["x"],gradFunc:(e,t,r)=>{let[n]=t,{reps:a}=r;return{x:()=>{let t=(0,q.zerosLike)(n);if(1===n.rank)for(let r=0;r<a[0];++r)t=(0,X.add)(t,(0,tw.slice)(e,[r*n.shape[0]],[n.shape[0]]));else if(2===n.rank)for(let r=0;r<a[0];++r)for(let s=0;s<a[1];++s)t=(0,X.add)(t,(0,tw.slice)(e,[r*n.shape[0],s*n.shape[1]],[n.shape[0],n.shape[1]]));else if(3===n.rank)for(let r=0;r<a[0];++r)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)t=(0,X.add)(t,(0,tw.slice)(e,[r*n.shape[0],s*n.shape[1],i*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(4===n.rank)for(let r=0;r<a[0];++r)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)for(let o=0;o<a[3];++o)t=(0,X.add)(t,(0,tw.slice)(e,[r*n.shape[0],s*n.shape[1],i*n.shape[2],o*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return t}}}},rg={kernelName:C.Transpose,gradFunc:(e,t,r)=>{let{perm:n}=r,a=eM.getUndoAxesPermutation(n);return{x:()=>(0,ez.transpose)(e,a)}}},ry={kernelName:C.Unpack,gradFunc:(e,t,r)=>{let{axis:n}=r;return{value:()=>(0,e1.stack)(e,n)}}};var rb=e.i(82522),rx=e.i(64960),rv=e.i(11787);let rw={kernelName:C.UnsortedSegmentSum,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[r]=t;return{x:()=>(function(e,t){let r=(0,rv.maximum)(t,(0,q.zerosLike)(t)),n=(0,rx.gather)(e,r),a=(0,eg.greaterEqual)(t,(0,O.scalar)(0,"int32")),s=n.rank-a.rank;for(let e=0;e<s;++e)a=(0,rb.expandDims)(a,e+1);a=(0,eb.logicalAnd)(a,(0,ty.ones)(n.shape,"bool"));let i=(0,q.zerosLike)(n);return(0,ex.where)(a,n,i)})(e,r)}}},rS={kernelName:C.ZerosLike,gradFunc:e=>({x:()=>(0,q.zerosLike)(e)})};var rN=e.i(97969);for(let e of[R,z,P,U,G,H,j,K,Z,Y,J,Q,ei,el,eh,ed,ec,ef,em,ev,ew,eN,eE,eT,eR,eF,e_,eP,eW,eU,tB,eG,eH,ej,eK,eX,eY,eZ,e0,e3,e5,e8,e9,e7,te,tr,tn,ta,ts,to,th,th,td,tf,tg,tb,tx,tv,tS,tk,tI,tT,tE,t$,tR,tD,tD,t_,tM,tP,tV,tW,tU,tG,tq,tH,tK,tX,tZ,tJ,t0,t1,t2,t4,t5,t7,re,rr,ra,ra,ri,ri,ro,ru,rl,rh,rp,rd,rc,rf,rm,rg,ry,rw,rS])(0,rN.registerGradient)(e);var rk=e.i(8252),rI=e.i(86962);(0,rI.getGlobalTensorClass)().prototype.abs=function(){return this.throwIfDisposed(),(0,rk.abs)(this)};var rT=e.i(89684);(0,rI.getGlobalTensorClass)().prototype.acos=function(){return this.throwIfDisposed(),(0,rT.acos)(this)};var rC=e.i(74060);(0,rI.getGlobalTensorClass)().prototype.acosh=function(){return this.throwIfDisposed(),(0,rC.acosh)(this)},(0,rI.getGlobalTensorClass)().prototype.add=function(e){return this.throwIfDisposed(),(0,X.add)(this,e)};var rE=e.i(29451);(0,rI.getGlobalTensorClass)().prototype.all=function(e,t){return this.throwIfDisposed(),(0,rE.all)(this,e,t)};var r$=e.i(22108);(0,rI.getGlobalTensorClass)().prototype.any=function(e,t){return this.throwIfDisposed(),(0,r$.any)(this,e,t)};var rA=e.i(195);(0,rI.getGlobalTensorClass)().prototype.argMax=function(e){return this.throwIfDisposed(),(0,rA.argMax)(this,e)};var rR=e.i(36502);(0,rI.getGlobalTensorClass)().prototype.argMin=function(e){return this.throwIfDisposed(),(0,rR.argMin)(this,e)},(0,rI.getGlobalTensorClass)().prototype.asScalar=function(){return this.throwIfDisposed(),(0,er.assert)(1===this.size,()=>"The array must have only 1 element."),(0,V.reshape)(this,[])},(0,rI.getGlobalTensorClass)().prototype.asType=function(e){return this.throwIfDisposed(),(0,E.cast)(this,e)},(0,rI.getGlobalTensorClass)().prototype.as1D=function(){return this.throwIfDisposed(),(0,V.reshape)(this,[this.size])},(0,rI.getGlobalTensorClass)().prototype.as2D=function(e,t){return this.throwIfDisposed(),(0,V.reshape)(this,[e,t])},(0,rI.getGlobalTensorClass)().prototype.as3D=function(e,t,r){return this.throwIfDisposed(),(0,V.reshape)(this,[e,t,r])},(0,rI.getGlobalTensorClass)().prototype.as4D=function(e,t,r,n){return this.throwIfDisposed(),(0,V.reshape)(this,[e,t,r,n])},(0,rI.getGlobalTensorClass)().prototype.as5D=function(e,t,r,n,a){return this.throwIfDisposed(),(0,V.reshape)(this,[e,t,r,n,a])};var rD=e.i(91013);(0,rI.getGlobalTensorClass)().prototype.asin=function(){return this.throwIfDisposed(),(0,rD.asin)(this)};var rF=e.i(97662);(0,rI.getGlobalTensorClass)().prototype.asinh=function(){return this.throwIfDisposed(),(0,rF.asinh)(this)};var rO=e.i(91288);(0,rI.getGlobalTensorClass)().prototype.atan=function(){return this.throwIfDisposed(),(0,rO.atan)(this)};var r_=e.i(20961);(0,rI.getGlobalTensorClass)().prototype.atan2=function(e){return this.throwIfDisposed(),(0,r_.atan2)(this,e)};var rM=e.i(74984);(0,rI.getGlobalTensorClass)().prototype.atanh=function(){return this.throwIfDisposed(),(0,rM.atanh)(this)};var rL=e.i(15683);(0,rI.getGlobalTensorClass)().prototype.avgPool=function(e,t,r,n){return this.throwIfDisposed(),(0,rL.avgPool)(this,e,t,r,n)},(0,rI.getGlobalTensorClass)().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),(0,rn.batchToSpaceND)(this,e,t)};var rz=e.i(40453);(0,rI.getGlobalTensorClass)().prototype.batchNorm=function(e,t,r,n,a){return this.throwIfDisposed(),(0,rz.batchNorm)(this,e,t,r,n,a)};var rP=e.i(61376);(0,rI.getGlobalTensorClass)().prototype.broadcastTo=function(e){return this.throwIfDisposed(),(0,rP.broadcastTo)(this,e)},(0,rI.getGlobalTensorClass)().prototype.cast=function(e){return this.throwIfDisposed(),(0,E.cast)(this,e)};var rB=e.i(29903);(0,rI.getGlobalTensorClass)().prototype.ceil=function(){return this.throwIfDisposed(),(0,rB.ceil)(this)};var rV=e.i(36889);(0,rI.getGlobalTensorClass)().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),(0,rV.clipByValue)(this,e,t)},(0,rI.getGlobalTensorClass)().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof rI.Tensor&&(e=[e]),(0,rs.concat)([this,...e],t)};var rW=e.i(18293);(0,rI.getGlobalTensorClass)().prototype.conv1d=function(e,t,r,n,a,s){return this.throwIfDisposed(),(0,rW.conv1d)(this,e,t,r,n,a,s)};var rU=e.i(87286);(0,rI.getGlobalTensorClass)().prototype.conv2dTranspose=function(e,t,r,n,a){return this.throwIfDisposed(),(0,rU.conv2dTranspose)(this,e,t,r,n,a)},(0,rI.getGlobalTensorClass)().prototype.conv2d=function(e,t,r,n,a,s){return this.throwIfDisposed(),(0,eC.conv2d)(this,e,t,r,n,a,s)},(0,rI.getGlobalTensorClass)().prototype.cos=function(){return this.throwIfDisposed(),(0,t3.cos)(this)},(0,rI.getGlobalTensorClass)().prototype.cosh=function(){return this.throwIfDisposed(),(0,t6.cosh)(this)},(0,rI.getGlobalTensorClass)().prototype.cumprod=function(e,t,r){return this.throwIfDisposed(),(0,tz.cumprod)(this,e,t,r)},(0,rI.getGlobalTensorClass)().prototype.cumsum=function(e,t,r){return this.throwIfDisposed(),(0,eL.cumsum)(this,e,t,r)};var rG=e.i(80201);(0,rI.getGlobalTensorClass)().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),(0,rG.depthToSpace)(this,e,t)};var rq=e.i(53849);(0,rI.getGlobalTensorClass)().prototype.depthwiseConv2d=function(e,t,r,n,a,s){return this.throwIfDisposed(),(0,rq.depthwiseConv2d)(this,e,t,r,n,a,s)};var rH=e.i(87338);(0,rI.getGlobalTensorClass)().prototype.dilation2d=function(e,t,r,n,a){return this.throwIfDisposed(),(0,rH.dilation2d)(this,e,t,r,n,a)};var rj=e.i(83218);(0,rI.getGlobalTensorClass)().prototype.divNoNan=function(e){return this.throwIfDisposed(),(0,rj.divNoNan)(this,e)},(0,rI.getGlobalTensorClass)().prototype.div=function(e){return this.throwIfDisposed(),(0,D.div)(this,e)};var rK=e.i(32537);(0,rI.getGlobalTensorClass)().prototype.dot=function(e){return this.throwIfDisposed(),(0,rK.dot)(this,e)};var rX=e.i(21704);(0,rI.getGlobalTensorClass)().prototype.elu=function(){return this.throwIfDisposed(),(0,rX.elu)(this)},(0,rI.getGlobalTensorClass)().prototype.equal=function(e){return this.throwIfDisposed(),(0,tl.equal)(this,e)};var rZ=e.i(95772);(0,rI.getGlobalTensorClass)().prototype.erf=function(){return this.throwIfDisposed(),(0,rZ.erf)(this)};var rY=e.i(30448);(0,rI.getGlobalTensorClass)().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),(0,rY.euclideanNorm)(this,e,t)},(0,rI.getGlobalTensorClass)().prototype.exp=function(){return this.throwIfDisposed(),(0,eq.exp)(this)},(0,rI.getGlobalTensorClass)().prototype.expandDims=function(e){return this.throwIfDisposed(),(0,rb.expandDims)(this,e)};var rJ=e.i(54160);(0,rI.getGlobalTensorClass)().prototype.expm1=function(){return this.throwIfDisposed(),(0,rJ.expm1)(this)};var rQ=e.i(85280);(0,rI.getGlobalTensorClass)().prototype.fft=function(){return this.throwIfDisposed(),(0,rQ.fft)(this)},(0,rI.getGlobalTensorClass)().prototype.flatten=function(){return this.throwIfDisposed(),(0,V.reshape)(this,[this.size])},(0,rI.getGlobalTensorClass)().prototype.floor=function(){return this.throwIfDisposed(),(0,tN.floor)(this)};var r0=e.i(99359);(0,rI.getGlobalTensorClass)().prototype.floorDiv=function(e){return this.throwIfDisposed(),(0,r0.floorDiv)(this,e)},(0,rI.getGlobalTensorClass)().prototype.gather=function(e,t,r){return this.throwIfDisposed(),(0,rx.gather)(this,e,t,r)},(0,rI.getGlobalTensorClass)().prototype.greaterEqual=function(e){return this.throwIfDisposed(),(0,eg.greaterEqual)(this,e)},(0,rI.getGlobalTensorClass)().prototype.greater=function(e){return this.throwIfDisposed(),(0,tt.greater)(this,e)};var r1=e.i(5247);(0,rI.getGlobalTensorClass)().prototype.ifft=function(){return this.throwIfDisposed(),(0,r1.ifft)(this)};var r2=e.i(92700);(0,rI.getGlobalTensorClass)().prototype.irfft=function(){return this.throwIfDisposed(),(0,r2.irfft)(this)};var r3=e.i(80507);(0,rI.getGlobalTensorClass)().prototype.isFinite=function(){return this.throwIfDisposed(),(0,r3.isFinite)(this)};var r4=e.i(73560);(0,rI.getGlobalTensorClass)().prototype.isInf=function(){return this.throwIfDisposed(),(0,r4.isInf)(this)};var r6=e.i(95596);(0,rI.getGlobalTensorClass)().prototype.isNaN=function(){return this.throwIfDisposed(),(0,r6.isNaN)(this)};var r5=e.i(14545);(0,rI.getGlobalTensorClass)().prototype.leakyRelu=function(e){return this.throwIfDisposed(),(0,r5.leakyRelu)(this,e)},(0,rI.getGlobalTensorClass)().prototype.lessEqual=function(e){return this.throwIfDisposed(),(0,ey.lessEqual)(this,e)},(0,rI.getGlobalTensorClass)().prototype.less=function(e){return this.throwIfDisposed(),(0,tp.less)(this,e)};var r8=e.i(98657);(0,rI.getGlobalTensorClass)().prototype.localResponseNormalization=function(e,t,r,n){return this.throwIfDisposed(),(0,r8.localResponseNormalization)(this,e,t,r,n)};var r9=e.i(76428);(0,rI.getGlobalTensorClass)().prototype.logSigmoid=function(){return this.throwIfDisposed(),(0,r9.logSigmoid)(this)};var r7=e.i(75869);(0,rI.getGlobalTensorClass)().prototype.logSoftmax=function(e){return this.throwIfDisposed(),(0,r7.logSoftmax)(this,e)};var ne=e.i(11585);(0,rI.getGlobalTensorClass)().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),(0,ne.logSumExp)(this,e,t)},(0,rI.getGlobalTensorClass)().prototype.log=function(){return this.throwIfDisposed(),(0,tF.log)(this)};var nt=e.i(91075);(0,rI.getGlobalTensorClass)().prototype.log1p=function(){return this.throwIfDisposed(),(0,nt.log1p)(this)},(0,rI.getGlobalTensorClass)().prototype.logicalAnd=function(e){return this.throwIfDisposed(),(0,eb.logicalAnd)(this,e)},(0,rI.getGlobalTensorClass)().prototype.logicalNot=function(){return this.throwIfDisposed(),(0,tY.logicalNot)(this)};var nr=e.i(97612);(0,rI.getGlobalTensorClass)().prototype.logicalOr=function(e){return this.throwIfDisposed(),(0,nr.logicalOr)(this,e)};var nn=e.i(66213);(0,rI.getGlobalTensorClass)().prototype.logicalXor=function(e){return this.throwIfDisposed(),(0,nn.logicalXor)(this,e)},(0,rI.getGlobalTensorClass)().prototype.matMul=function(e,t,r){return this.throwIfDisposed(),(0,eu.matMul)(this,e,t,r)};var na=e.i(67289);(0,rI.getGlobalTensorClass)().prototype.maxPool=function(e,t,r,n){return this.throwIfDisposed(),(0,na.maxPool)(this,e,t,r,n)};var ns=e.i(94829);(0,rI.getGlobalTensorClass)().prototype.max=function(e,t){return this.throwIfDisposed(),(0,ns.max)(this,e,t)},(0,rI.getGlobalTensorClass)().prototype.maximum=function(e){return this.throwIfDisposed(),(0,rv.maximum)(this,e)};var ni=e.i(41807);(0,rI.getGlobalTensorClass)().prototype.mean=function(e,t){return this.throwIfDisposed(),(0,ni.mean)(this,e,t)};var no=e.i(40296);(0,rI.getGlobalTensorClass)().prototype.min=function(e,t){return this.throwIfDisposed(),(0,no.min)(this,e,t)};var nl=e.i(36467);(0,rI.getGlobalTensorClass)().prototype.minimum=function(e){return this.throwIfDisposed(),(0,nl.minimum)(this,e)};var nu=e.i(19318);(0,rI.getGlobalTensorClass)().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),(0,nu.mirrorPad)(this,e,t)};var nh=e.i(46554);(0,rI.getGlobalTensorClass)().prototype.mod=function(e){return this.throwIfDisposed(),(0,nh.mod)(this,e)},(0,rI.getGlobalTensorClass)().prototype.mul=function(e){return this.throwIfDisposed(),(0,$.mul)(this,e)},(0,rI.getGlobalTensorClass)().prototype.neg=function(){return this.throwIfDisposed(),(0,F.neg)(this)};var np=e.i(99269);(0,rI.getGlobalTensorClass)().prototype.norm=function(e,t,r){return this.throwIfDisposed(),(0,np.norm)(this,e,t,r)};var nd=e.i(18355);(0,rI.getGlobalTensorClass)().prototype.notEqual=function(e){return this.throwIfDisposed(),(0,nd.notEqual)(this,e)};var nc=e.i(90889);(0,rI.getGlobalTensorClass)().prototype.oneHot=function(e,t=1,r=0){return this.throwIfDisposed(),(0,nc.oneHot)(this,e,t,r)};var nf=e.i(46768);(0,rI.getGlobalTensorClass)().prototype.onesLike=function(){return this.throwIfDisposed(),(0,nf.onesLike)(this)},(0,rI.getGlobalTensorClass)().prototype.pad=function(e,t){return this.throwIfDisposed(),(0,t8.pad)(this,e,t)};var nm=e.i(94125);(0,rI.getGlobalTensorClass)().prototype.pool=function(e,t,r,n,a,s){return this.throwIfDisposed(),(0,nm.pool)(this,e,t,r,n,a,s)},(0,rI.getGlobalTensorClass)().prototype.pow=function(e){return this.throwIfDisposed(),(0,tO.pow)(this,e)};var ng=e.i(90506);(0,rI.getGlobalTensorClass)().prototype.prelu=function(e){return this.throwIfDisposed(),(0,ng.prelu)(this,e)};var ny=e.i(95558);(0,rI.getGlobalTensorClass)().prototype.prod=function(e,t){return this.throwIfDisposed(),(0,ny.prod)(this,e,t)};var nb=e.i(80781);(0,rI.getGlobalTensorClass)().prototype.reciprocal=function(){return this.throwIfDisposed(),(0,nb.reciprocal)(this)};var nx=e.i(60752);(0,rI.getGlobalTensorClass)().prototype.relu=function(){return this.throwIfDisposed(),(0,nx.relu)(this)};var nv=e.i(17016);(0,rI.getGlobalTensorClass)().prototype.relu6=function(){return this.throwIfDisposed(),(0,nv.relu6)(this)},(0,rI.getGlobalTensorClass)().prototype.reshapeAs=function(e){return this.throwIfDisposed(),(0,V.reshape)(this,e.shape)},(0,rI.getGlobalTensorClass)().prototype.reshape=function(e){return this.throwIfDisposed(),(0,V.reshape)(this,e)};var nw=e.i(41423);(0,rI.getGlobalTensorClass)().prototype.resizeBilinear=function(e,t,r){return this.throwIfDisposed(),(0,nw.resizeBilinear)(this,e,t,r)};var nS=e.i(466);(0,rI.getGlobalTensorClass)().prototype.resizeNearestNeighbor=function(e,t,r){return this.throwIfDisposed(),(0,nS.resizeNearestNeighbor)(this,e,t,r)},(0,rI.getGlobalTensorClass)().prototype.reverse=function(e){return this.throwIfDisposed(),(0,tj.reverse)(this,e)};var nN=e.i(2182);(0,rI.getGlobalTensorClass)().prototype.rfft=function(){return this.throwIfDisposed(),(0,nN.rfft)(this)};var nk=e.i(53175);(0,rI.getGlobalTensorClass)().prototype.round=function(){return this.throwIfDisposed(),(0,nk.round)(this)},(0,rI.getGlobalTensorClass)().prototype.rsqrt=function(){return this.throwIfDisposed(),(0,eJ.rsqrt)(this)};var nI=e.i(82669);(0,rI.getGlobalTensorClass)().prototype.selu=function(){return this.throwIfDisposed(),(0,nI.selu)(this)};var nT=e.i(81982);(0,rI.getGlobalTensorClass)().prototype.separableConv2d=function(e,t,r,n,a,s){return this.throwIfDisposed(),(0,nT.separableConv2d)(this,e,t,r,n,a,s)},(0,rI.getGlobalTensorClass)().prototype.sigmoid=function(){return this.throwIfDisposed(),(0,rt.sigmoid)(this)};var nC=e.i(4509);(0,rI.getGlobalTensorClass)().prototype.sign=function(){return this.throwIfDisposed(),(0,nC.sign)(this)},(0,rI.getGlobalTensorClass)().prototype.sin=function(){return this.throwIfDisposed(),(0,eD.sin)(this)},(0,rI.getGlobalTensorClass)().prototype.sinh=function(){return this.throwIfDisposed(),(0,eO.sinh)(this)},(0,rI.getGlobalTensorClass)().prototype.slice=function(e,t){return this.throwIfDisposed(),(0,tw.slice)(this,e,t)};var nE=e.i(41721);(0,rI.getGlobalTensorClass)().prototype.softmax=function(e){return this.throwIfDisposed(),(0,nE.softmax)(this,e)};var n$=e.i(81008);(0,rI.getGlobalTensorClass)().prototype.softplus=function(){return this.throwIfDisposed(),(0,n$.softplus)(this)},(0,rI.getGlobalTensorClass)().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),(0,ep.spaceToBatchND)(this,e,t)},(0,rI.getGlobalTensorClass)().prototype.split=function(e,t){return this.throwIfDisposed(),(0,eS.split)(this,e,t)},(0,rI.getGlobalTensorClass)().prototype.sqrt=function(){return this.throwIfDisposed(),(0,_.sqrt)(this)},(0,rI.getGlobalTensorClass)().prototype.square=function(){return this.throwIfDisposed(),(0,M.square)(this)};var nA=e.i(70804);(0,rI.getGlobalTensorClass)().prototype.squaredDifference=function(e){return this.throwIfDisposed(),(0,nA.squaredDifference)(this,e)};var nR=e.i(3975);(0,rI.getGlobalTensorClass)().prototype.squeeze=function(e){return this.throwIfDisposed(),(0,nR.squeeze)(this,e)},(0,rI.getGlobalTensorClass)().prototype.stack=function(e,t){this.throwIfDisposed();let r=e instanceof rI.Tensor?[this,e]:[this,...e];return(0,e1.stack)(r,t)},(0,rI.getGlobalTensorClass)().prototype.step=function(e){return this.throwIfDisposed(),(0,A.step)(this,e)};var nD=e.i(25273);(0,rI.getGlobalTensorClass)().prototype.stridedSlice=function(e,t,r,n,a,s,i,o){return this.throwIfDisposed(),(0,nD.stridedSlice)(this,e,t,r,n,a,s,i,o)},(0,rI.getGlobalTensorClass)().prototype.sub=function(e){return this.throwIfDisposed(),(0,L.sub)(this,e)},(0,rI.getGlobalTensorClass)().prototype.sum=function(e,t){return this.throwIfDisposed(),(0,W.sum)(this,e,t)};var nF=e.i(84580);(0,rI.getGlobalTensorClass)().prototype.tan=function(){return this.throwIfDisposed(),(0,nF.tan)(this)};var nO=e.i(61197);(0,rI.getGlobalTensorClass)().prototype.tanh=function(){return this.throwIfDisposed(),(0,nO.tanh)(this)},(0,rI.getGlobalTensorClass)().prototype.tile=function(e){return this.throwIfDisposed(),(0,eQ.tile)(this,e)},(0,rI.getGlobalTensorClass)().prototype.toBool=function(){return this.throwIfDisposed(),(0,E.cast)(this,"bool")},(0,rI.getGlobalTensorClass)().prototype.toFloat=function(){return this.throwIfDisposed(),(0,E.cast)(this,"float32")},(0,rI.getGlobalTensorClass)().prototype.toInt=function(){return this.throwIfDisposed(),(0,E.cast)(this,"int32")};var n_=e.i(40939);(0,rI.getGlobalTensorClass)().prototype.topk=function(e,t){return this.throwIfDisposed(),(0,n_.topk)(this,e,t)},(0,rI.getGlobalTensorClass)().prototype.transpose=function(e){return this.throwIfDisposed(),(0,ez.transpose)(this,e)};var nM=e.i(20691);(0,rI.getGlobalTensorClass)().prototype.unique=function(e){return this.throwIfDisposed(),(0,nM.unique)(this,e)},(0,rI.getGlobalTensorClass)().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),(0,e2.unsortedSegmentSum)(this,e,t)},(0,rI.getGlobalTensorClass)().prototype.unstack=function(e){return this.throwIfDisposed(),(0,tA.unstack)(this,e)},(0,rI.getGlobalTensorClass)().prototype.where=function(e,t){return this.throwIfDisposed(),(0,ex.where)(e,this,t)},(0,rI.getGlobalTensorClass)().prototype.zerosLike=function(){return this.throwIfDisposed(),(0,q.zerosLike)(this)};var nL=e.i(29064),nz=e.i(17372),nP=e.i(89132);class nB extends Error{constructor(e){super(e),Object.setPrototypeOf(this,nB.prototype)}}class nV extends Error{constructor(e){super(e),Object.setPrototypeOf(this,nV.prototype)}}class nW extends Error{constructor(e){super(e),Object.setPrototypeOf(this,nW.prototype)}}class nU extends Error{constructor(e){super(e),Object.setPrototypeOf(this,nU.prototype)}}class nG extends Error{constructor(e){super(e),Object.setPrototypeOf(this,nG.prototype)}}class nq{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function nH(e,t){if(Array.isArray(e)){let r=[];for(let n=0;n<t;n++)r=r.concat(e);return r}{let r=Array(t);return r.fill(e),r}}function nj(e,t){if(!e)throw new nG(t)}function nK(e,t){let r=0;for(let n of e)n===t&&r++;return r}function nX(e){return 1===e.length?e[0]:e}function nZ(e){return Array.isArray(e)?e:[e]}function nY(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function nJ(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let nQ={};function n0(e){if(null==e)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function n1(e,t={},r={},n="object",a=!1){if("string"==typeof e){let a;if(e in r)a=r[e];else if(e in nQ)a=nQ[e];else if(null==(a=t[e]))throw new nW(`Unknown ${n}: ${e}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{let s,i;if(null==e.className||null==e.config)throw new nW(`${n}: Improper config format: ${JSON.stringify(e)}.
'className' and 'config' must set.`);let o=e.className;if(o in r?[s,i]=r[o]:o in nQ?[s,i]=nQ.className:o in t&&([s,i]=t[o]),null==s)throw new nW(`Unknown ${n}: ${o}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=i){let t={};for(let e of Object.keys(nQ))t[e]=nQ[e];for(let e of Object.keys(r))t[e]=r[e];e.config.customObjects=t;let n=Object.assign({},nQ);for(let e of Object.keys(r))nQ[e]=r[e];!function e(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach(t=>e(t));else for(let r of Object.keys(t)){let n=t[r];null!=n&&"object"==typeof n&&(Array.isArray(n)||"ndarray"!==n.type||"number"!=typeof n.value?e(n):t[r]=n.value)}}(e.config);let o=i(s,e.config,r,a);return nQ=Object.assign({},n),o}{let t=Object.assign({},nQ);for(let e of Object.keys(r))nQ[e]=r[e];let n=new s(e.config);return nQ=Object.assign({},t),n}}}function n2(e,t){return -1*(e<t?-1:+(e>t))}function n3(e){if(null==e)return e;let t=[];for(let r of e)-1===t.indexOf(r)&&t.push(r);return t}function n4(e,t,r){if(null!=r&&0>e.indexOf(r))throw new nW(`${r} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function n6(e,t,r=0,n=1/0){return nj(r>=0),nj(n>=r),Array.isArray(e)&&e.length>=r&&e.length<=n&&e.every(e=>typeof e===t)}function n5(e,t){Array.isArray(e)?(nP.util.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((e,r)=>n5(e,`element ${r+1} of ${t}`))):nP.util.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${function e(t){return null===t?"null":Array.isArray(t)?"["+t.map(t=>e(t)).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}(e)}.`)}function n8(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var n9=e.i(86862),n9=n9;let n7=0,ae={};function at(e=""){return e in ae||(ae[e]=0),ae[e]+=1,e+ae[e].toString()}var n9=n9;let ar=["channelsFirst","channelsLast"],an=["nearest","bilinear"],aa=["valid","same","causal"],as=["max","avg"],ai=["sum","mul","concat","ave"],ao=new Map;function al(e){n4(ar,"DataFormat",e)}function au(e){n4(aa,"PaddingMode",e)}function ah(e){n4(as,"PoolMode",e)}let ap=[];function ad(e,t){ap.push(e);try{let e=t();return ap.pop(),e}catch(e){throw ap.pop(),e}}function ac(e){if(!ag(e))throw Error("Not a valid tensor name: '"+e+"'");return(0===ap.length?"":ap.join("/")+"/")+e}function af(e){if(!ag(e))throw Error("Not a valid tensor name: '"+e+"'");ao.has(e)||ao.set(e,0);let t=ao.get(e);if(ao.set(e,ao.get(e)+1),!(t>0))return e;{let r=`${e}_${t}`;return ao.set(r,1),r}}let am=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function ag(e){return!!e.match(am)}var ay=e.i(15466),ab=e.i(31445),ax=e.i(79362),n9=n9,av=e.i(2510),aw=e.i(70402),aS=e.i(58063),aN=e.i(13741),ak=e.i(23582),aI=e.i(42088),aT=e.i(52064),aC=e.i(28489),aE=e.i(10423),a$=e.i(39316),aA=e.i(85474),aA=aA,aR=e.i(16738),aD=e.i(40855);function aF(e,t,r){null==t&&(t=0),null==r&&(r=e.length);let n=1;for(let a=t;a<r;++a)n*=e[a];return n}function aO(e){if(0===e.length)return NaN;let t=1/0;for(let r=0;r<e.length;r++){let n=e[r];n<t&&(t=n)}return t}function a_(e){if(0===e.length)return NaN;let t=-1/0;for(let r=0;r<e.length;r++){let n=e[r];n>t&&(t=n)}return t}function aM(e,t){if(t<e)throw new nW(`end (${t}) < begin (${e}) is forbidden.`);let r=[];for(let n=e;n<t;++n)r.push(n);return r}function aL(){return null==t&&(t=(0,nz.backend)().epsilon()),t}function az(){return"channelsLast"}function aP(e,t){return E.cast(e,t)}function aB(e,t=-1){let r=e.shape.slice();return t<0&&(t=r.length+t+1),r.splice(t,0,1),V.reshape(e,r)}function aV(e,t,r){return(0,nz.tidy)(()=>{switch(e.rank){case 1:return aw.slice1d(e,t,r);case 2:return aS.slice2d(e,[t,0],[r,e.shape[1]]);case 3:return aN.slice3d(e,[t,0,0],[r,e.shape[1],e.shape[2]]);case 4:return ak.slice4d(e,[t,0,0,0],[r,e.shape[1],e.shape[2],e.shape[3]]);case 5:return tw.slice(e,[t,0,0,0,0],[r,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return tw.slice(e,[t,0,0,0,0,0],[r,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new nW(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function aW(e,t,r){return(0,nz.tidy)(()=>{switch(e.rank){case 1:return aw.slice1d(e,t,r);case 2:return aS.slice2d(e,[0,t],[e.shape[0],r]);case 3:return aN.slice3d(e,[0,0,t],[e.shape[0],e.shape[1],r]);case 4:return ak.slice4d(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],r]);default:throw new nW(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function aU(e,t,r,n){return(0,nz.tidy)(()=>{switch(e.rank){case 1:return aw.slice1d(e,t,r);case 2:switch(n){case 1:return aV(e,t,r);case 2:return aW(e,t,r);default:throw new nW(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return aV(e,t,r);case 2:return aN.slice3d(e,[0,t,0],[e.shape[0],r,e.shape[2]]);case 3:return aW(e,t,r);default:throw new nW(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return aV(e,t,r);case 2:return ak.slice4d(e,[0,t,0,0],[e.shape[0],r,e.shape[2],e.shape[3]]);case 3:return ak.slice4d(e,[0,0,t,0],[e.shape[0],e.shape[1],r,e.shape[3]]);case 4:return aW(e,t,r);default:throw new nW(`The axis is not within the rank of the tensor ${n}`)}default:throw new nW(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function aG(e,t=-1){let r;return t<0&&(t=0!==(r=e[0].rank)?r:0),t===e[0].rank&&(t=-1),rs.concat(e,t)}function aq(e,t){switch(e.rank){case 1:return aI.concat1d([e,t]);case 2:return aT.concat2d([e,t],0);case 3:return aC.concat3d([e,t],0);case 4:return aE.concat4d([e,t],0);default:throw new nW(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function aH(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new nW(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return eQ.tile(e,t)}function aj(e,t=0,r=1,n,a){return a$.randomNormal(e,t,r,n,a)}function aK(e,t,r,n){if(e.rank<2||t.rank<2)throw new nU(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new nU(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank)return aA.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:n?aY(e.rank,n,az()):null,activation:r});{let a=e.shape.slice(),s=a.pop();e=V.reshape(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],h=Array.from({length:t.rank},(e,r)=>0===r?t.rank-2:r<=t.rank-2?r-1:r);t=V.reshape(ez.transpose(t,h),[l,-1]);let p=[...a,...u];return V.reshape(aA.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:n?aY(e.rank,n,az()):null,activation:r}),p)}}function aX(e,t,r){return(0,nz.tidy)(()=>(t=Array.isArray(t)?(0,aD.tensor1d)(t,"int32"):E.cast(t,"int32"),rx.gather(e,t,r)))}function aZ(e){return $.mul(e,e)}function aY(e,t,r){let n=t.shape;if(1!==t.rank&&t.rank!==e)throw new nW(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===r)if(1===n.length)return V.reshape(t,[1,n[0],1,1,1]);else return V.reshape(t,[1,n[3],n[0],n[1],n[2]]);else if("channelsLast"===r)if(1===n.length)return V.reshape(t,[1,1,1,1,n[0]]);else return V.reshape(t,[1].concat(n))}else if(4===e){if("channelsFirst"===r)if(1===n.length)return V.reshape(t,[1,n[0],1,1]);else return V.reshape(t,[1,n[2],n[0],n[1]]);else if("channelsLast"===r)if(1===n.length)return V.reshape(t,[1,1,1,n[0]]);else return V.reshape(t,[1].concat(n))}else if(3===e){if("channelsFirst"===r)if(1===n.length)return V.reshape(t,[1,n[0],1]);else return V.reshape(t,[1,n[1],n[0]]);else if("channelsLast"===r)if(1===n.length)return V.reshape(t,[1,1,n[0]]);else return V.reshape(t,[1].concat(n))}else if(e<3)return t;throw new nW(`Unsupported input rank by biasAdd: ${t.rank}`)}function aJ(e,t,r){return(0,nz.tidy)(()=>(null==r&&(r=az()),al(r),X.add(e,aY(e.rank,t,r))))}function aQ(e,t,r,n){return(0,nz.tidy)(()=>aR.dropout(e,t,r,n))}function a0(e,t,r=!1){return r?e():t()}let a1=["fanIn","fanOut","fanAvg"],a2=["normal","uniform","truncatedNormal"];class a3 extends n9.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class a4 extends a3{apply(e,t){return(0,tC.zeros)(e,t)}}a4.className="Zeros",n9.registerClass(a4);class a6 extends a3{apply(e,t){return(0,ty.ones)(e,t)}}a6.className="Ones",n9.registerClass(a6);class a5 extends a3{constructor(e){if(super(),"object"!=typeof e)throw new nW(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new nW(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return(0,nz.tidy)(()=>(0,$.mul)((0,O.scalar)(this.value),(0,ty.ones)(e,t)))}getConfig(){return{value:this.value}}}a5.className="Constant",n9.registerClass(a5);class a8 extends a3{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return(0,ax.randomUniform)(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}a8.className="RandomUniform",n9.registerClass(a8);class a9 extends a3{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new nU(`randomNormal does not support dType ${t}.`);return aj(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}a9.className="RandomNormal",n9.registerClass(a9);class a7 extends a3{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new nU(`truncatedNormal does not support dType ${t}.`);return(0,av.truncatedNormal)(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}a7.className="TruncatedNormal",n9.registerClass(a7);class se extends a3{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return(0,nz.tidy)(()=>{if(2===e.length&&e[0]===e[1])return(0,$.mul)(this.gain,(0,ay.eye)(e[0]));throw new nW("Identity matrix initializer can only be used for 2D square matrices.")})}getConfig(){return{gain:this.gain}}}se.className="Identity",n9.registerClass(se);class st extends a3{constructor(e){if(super(),e.scale<0)throw new nW(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,n4(a1,"FanMode",this.mode),this.distribution=null==e.distribution?"normal":e.distribution,n4(a2,"Distribution",this.distribution),this.seed=e.seed}apply(e,t){let r=function(e,t="channelsLast"){let r,n;if(al(t),2===e.length)r=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){let t=aF(e,2);r=e[1]*t,n=e[0]*t}else if("channelsLast"===t){let t=aF(e,0,e.length-2);r=e[e.length-2]*t,n=e[e.length-1]*t}}else{let t=aF(e);r=Math.sqrt(t),n=Math.sqrt(t)}return[r,n]}(e),n=r[0],a=r[1],s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,n):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(n+a)/2),"normal"===this.distribution){let r=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new nU(`${this.getClassName()} does not support dType ${t}.`);return(0,av.truncatedNormal)(e,0,r,t,this.seed)}{let r=Math.sqrt(3*s);return(0,ax.randomUniform)(e,-r,r,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}st.className="VarianceScaling",n9.registerClass(st);class sr extends st{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return st.className}}sr.className="GlorotUniform",n9.registerClass(sr);class sn extends st{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return st.className}}sn.className="GlorotNormal",n9.registerClass(sn);class sa extends st{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return st.className}}sa.className="HeNormal",n9.registerClass(sa);class ss extends st{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return st.className}}ss.className="HeUniform",n9.registerClass(ss);class si extends st{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return st.className}}si.className="LeCunNormal",n9.registerClass(si);class so extends st{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return st.className}}so.className="LeCunUniform",n9.registerClass(so);class sl extends a3{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return(0,nz.tidy)(()=>{if(e.length<2)throw new nU("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw TypeError(`Unsupported data type ${t}.`);let r=nP.util.sizeFromShape(e.slice(0,-1)),n=e[e.length-1],a=r*n;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);let s=aj([Math.max(n,r),Math.min(n,r)],0,1,t,this.seed),i=ab.linalg.qr(s,!1),o=i[0],l=i[1].flatten().stridedSlice([0],[Math.min(n,r)*Math.min(n,r)],[Math.min(n,r)+1]);return o=(0,$.mul)(o,l.sign()),r<n&&(o=o.transpose()),(0,$.mul)((0,O.scalar)(this.gain),o.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}sl.className="Orthogonal",n9.registerClass(sl);let su={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function sh(e,t={}){return n1(e,n9.SerializationMap.getMap().classNameMap,t,"initializer")}function sp(e){if("string"==typeof e){let t=e in su?su[e]:e;if("GlorotNormal"===t)return new sn;{if("GlorotUniform"===t)return new sr;if("HeNormal"===t)return new sa;if("HeUniform"===t)return new ss;if("LeCunNormal"===t)return new si;if("LeCunUniform"===t)return new so;let e={};return e.className=t,e.config={},sh(e)}}return e instanceof a3?e:sh(e)}function sd(e){return Array.isArray(e)&&Array.isArray(e[0])}function sc(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function sf(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new nW(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function sm(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))return e;if(1===e.length)return e[0];throw new nW(`Expected exactly 1 Shape; got ${e.length}`)}function sg(e){let t=0;for(let r of e)0===r.shape.length?t+=1:t+=r.shape.reduce((e,t)=>e*t);return t}var sy=e.i(80765);let sb="Variable";class sx{constructor(e,t="float32",r=sb,n=!0,a=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=n7++,r=null==r?sb:r,this.originalName=ac(r),this.name=af(this.originalName),this.trainable_=n,this.constraint=a,this.val=sy.variable(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function sv(e){return e.map(e=>e.read())}function sw(e){e.forEach(e=>{e[0].write(e[1])})}class sS{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class sN{constructor(e,t,r,n,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=r,this.inputs=n,this.callArgs=a,this.outputTensorIndex=i,this.id=n7++,null!=s&&(this.originalName=ac(s),this.name=af(this.originalName)),this.rank=t.length}}let sk=0;class sI{constructor(e,t){for(const r of(this.callArgs=t,this.id=sk++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes,e.inboundLayers))null!=r&&r.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let sT=0;class sC extends n9.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=sT++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=nY(e)+"_"+at(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),t=[r].concat(e.inputShape)}this.batchInputShape=t;let r=e.dtype;null==r&&(r=e.inputDType),null==r&&(r="float32"),this.dtype=r}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new nV(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new nW(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return nX(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return nX(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new nB(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new nB(`Layer ${this.name} is not connected, no input to return.`);return nX(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new nB(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new nB(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return nX(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=nZ(e);if(null==this.inputSpec||0===this.inputSpec.length)return;let r=nZ(this.inputSpec);if(t.length!==r.length)throw new nW(`Layer ${this.name} expects ${r.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let e=0;e<t.length;e++){let n=t[e],a=r[e];if(null==a)continue;let s=n.rank;if(null!=a.ndim&&s!==a.ndim)throw new nW(`Input ${e} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new nW(`Input ${e} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new nW(`Input ${e} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&n.dtype!==a.dtype)throw new nW(`Input ${e} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${n.dtype}.`);if(a.axes){let t=n.shape;for(let r in a.axes){let n=Number(r),s=a.axes[r],i=n>=0?t[n]:t[t.length+n];if(null!=s&&-1===[s,null].indexOf(i))throw new nW(`Input ${e} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${s} but got shape ${t}.`)}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){let r=a.shape[t],s=n.shape[t];if(null!=r&&null!=s&&r!==s)throw new nW(`Input ${e} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${n.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let r=nZ(e),n=function(e){let t=!0;for(let r of nZ(e))if(!(r instanceof sN)){t=!1;break}return t}(e),a=function(e){let t=!0;for(let r of nZ(e))if(r instanceof sN){t=!1;break}return t}(e);if(n===a)throw new nW("Arguments to apply() must be all SymbolicTensors or all Tensors");return ad(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let t=[];for(let r of nZ(e))t.push(r.shape);this.build(nX(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let n=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,n);let a=nZ(n),s=[];for(let e of a)-1!==r.indexOf(e)&&(e=e.clone()),s.push(e);if(n=nX(s),null!=this.activityRegularizer)throw new nU("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return n}{let r,n=function(e){e=nZ(e);let t=[];for(let r of e)t.push(r.shape);return nX(t)}(e),a=this.computeOutputShape(n),s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),r=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((r,n)=>new sN(s,r,this,nZ(e),t,this.name,n)):new sN(s,a,this,nZ(e),t,this.name),this.addInboundNode(e,r,null,null,n,a,t),this._refCount++,null!=this.activityRegularizer)throw new nU("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}})}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((r,n)=>{null!=r&&null!=e[n]&&e[n]!==r&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new nB(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let r=JSON.stringify(t.outputShapes);-1===e.indexOf(r)&&e.push(r)}if(1===e.length){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new nB(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new nV(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return sg(this.weights)}build(e){this.built=!0}getWeights(e=!1){return sv(e?this.trainableWeights:this.weights)}setWeights(e){(0,nz.tidy)(()=>{let t=this.weights;if(t.length!==e.length)throw new nW(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;let r=[],n=sv(t);for(let a=0;a<n.length;++a){let s=n[a],i=t[a],o=e[a];if(!nP.util.arraysEqual(s.shape,o.shape))throw new nW(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);r.push([i,o])}sw(r)})}addWeight(e,t,r,n,a,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new nW(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(n=null!=o?o():sp("zeros"));let l=n.apply(t,r),u=new sx(l,r,e,s,i);return l.dispose(),null!=a&&this.addLoss(()=>a.apply(u.read())),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=nZ(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t)if(Array.isArray(t))t.forEach(e=>{if(null!=e)throw TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,r){if(!this.supportsMasking)return;let n=this.computeMask(e,r),a=nZ(t),s=nZ(n);if(a.length!==s.length)throw Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let e=0;e<a.length;e++)a[e].kerasMask=s[e]}addInboundNode(e,t,r,n,a,s,i=null){let o=nZ(e);t=nZ(t),r=nZ(r),n=nZ(n),a=sc(a),s=sc(s);let l=[],u=[],h=[];for(let e of o)l.push(e.sourceLayer),u.push(e.nodeIndex),h.push(e.tensorIndex);new sI({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:h,inputTensors:o,outputTensors:t,inputMasks:r,outputMasks:n,inputShapes:a,outputShapes:s},i);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){let e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}class sE extends sC{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:at("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new nW("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t)if(null==e.inputShape)throw new nW("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");else t=[e.batchSize].concat(e.inputShape);else if(null!=e.batchSize)throw new nW("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=t,this.dtype=r,this.inputSpec=[{shape:t}];const n=new sN(this.dtype,this.batchInputShape,this,[],{},this.name);n.nodeIndex=0,n.tensorIndex=0,new sI({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[n],outputTensors:[n],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new nW(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function s$(e){if(null==e.batchShape&&null==e.shape)throw Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new nW("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let r=e.dtype;return null==r&&(r="float32"),new sE({batchInputShape:t,name:e.name,dtype:r,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}sE.className="InputLayer",n9.registerClass(sE);class sA{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof sA)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,r){if(null==this.id2Value[e.id])this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return(0,E.cast)(t,e.dtype)}catch(r){throw new nW(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=r&&(this.id2Mask[e.id]=r);else throw new nW(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof sN)if(null!=this.id2Value[e.id])return this.id2Value[e.id];else throw new nW(`Nonexistent key: ${e.name}`);{let t=this.name2Id[e];if(null==t)throw new nW(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof sN)if(null!=this.id2Value[e.id])return this.id2Mask[e.id];else throw new nW(`Nonexistent key: ${e.name}`);{let t=this.name2Id[e];if(null==t)throw new nW(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&(0,nz.dispose)(this.id2Mask)}}let sR=new nq,sD=new nq;function sF(e,t,r,n){let a,s=null!=r&&r.training,i=Array.isArray(e),o=i?e:[e],l=o.map(e=>e.name),u=[],h=t.names();for(let e of l)-1!==h.indexOf(e)?u.push(t.getValue(e)):u.push(null);null!=n&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);let p=l.join(",")+"|"+t.names().sort().join(","),d=sR.get(p);if(null==d){let e=function(e,t){nP.util.assert(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let r=[],n={};if(1===e.length){let a=sO(e[0],t);r=a.sorted,n=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:e,recipientMap:i}=sO(s,t);for(let t of e)a.has(t.name)||(r.push(t),a.add(t.name));for(let e in i)null==n[e]&&(n[e]=new Set),i[e].forEach(t=>n[e].add(t))}}return{sorted:r,recipientCounts:function(e){let t={};for(let r in e)t[r]=e[r].size;return t}(n)}}(o,t);d=e.sorted,a=e.recipientCounts,sR.put(p,d),sD.put(p,a)}a={},s||Object.assign(a,sD.get(p));let c=new sA(t);for(let e=0;e<d.length;++e){if(null!=n){let e=(0,nz.memory)().numTensors;e>n.maxNumTensors&&(n.maxNumTensors=e),e<n.minNumTensors&&(n.minNumTensors=e)}let i=d[e],o=i.sourceLayer;if(o instanceof sE)continue;let h=[],p=[],f=[],m=!1;for(let e of i.inputs){let r=c.getValue(e),n=c.getMask(e);h.push(r),p.push(n),null!=n&&(m=!0),!s&&(a[e.name]--,0!==a[e.name]||t.hasKey(e)||-1!==l.indexOf(e.name)||r.isDisposed||!0===e.sourceLayer.stateful||f.push(r))}m&&((r=r||{}).mask=p[0]);let g=nZ(o.apply(h,r)),y=null;o.supportsMasking&&(y=o.computeMask(h,p));let b=function(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let r=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(let n of e.sourceLayer.inboundNodes[t].outputTensors)if(n.id===e.id){r=t;break}t=e.sourceLayer.getOutputAt(r)}return t}(i),x=Array.isArray(b)?b:[b];for(let e=0;e<x.length;++e){c.hasKey(x[e])||c.add(x[e],g[e],Array.isArray(y)?y[0]:y);let t=l.indexOf(x[e].name);-1!==t&&(u[t]=g[e])}s||(0,nz.dispose)(f)}return c.disposeMasks(),i?u:u[0]}function sO(e,t){let r=new Set,n=[],a={};for(let e of t.names())r.add(e);let s=[],i=[];for(s.push(e);s.length>0;){let e=s[s.length-1];if(r.has(e.name)){s.pop();continue}let t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),n.push(e),r.add(e.name),t&&i.pop();else for(let t of(i.push(s.length-1),e.inputs))null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),r.has(t.name)||s.push(t)}return{sorted:n,recipientMap:a}}(0,nL.env)().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function(e){null!=sR&&sR.setMaxEntries(e),null!=sD&&sD.setMaxEntries(e)});var n9=n9;function s_(e,t){return(0,nz.tidy)(()=>_.sqrt(W.sum($.mul(e,e),t,!0)))}class sM extends n9.Serializable{getConfig(){return{}}}class sL extends sM{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,nz.tidy)(()=>{let t=s_(e,this.axis),r=rV.clipByValue(t,0,this.maxValue);return $.mul(e,D.div(r,X.add(aL(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}sL.className="MaxNorm",n9.registerClass(sL);class sz extends sM{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,nz.tidy)(()=>D.div(e,X.add(aL(),s_(e,this.axis))))}getConfig(){return{axis:this.axis}}}sz.className="UnitNorm",n9.registerClass(sz);class sP extends sM{apply(e){return nx.relu(e)}}sP.className="NonNeg",n9.registerClass(sP);class sB extends sM{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,nz.tidy)(()=>{let t=s_(e,this.axis),r=X.add($.mul(this.rate,rV.clipByValue(t,this.minValue,this.maxValue)),$.mul(1-this.rate,t));return $.mul(e,D.div(r,X.add(aL(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}sB.className="MinMaxNorm",n9.registerClass(sB);let sV={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function sW(e,t={}){return n1(e,n9.SerializationMap.getMap().classNameMap,t,"constraint")}function sU(e){return null==e?null:"string"==typeof e?sW({className:e in sV?sV[e]:e,config:{}}):e instanceof sM?e:sW(e)}function sG(e){return new sL(e)}function sq(e){return new sz(e)}function sH(){return new sP}function sj(e){return new sB(e)}function sK(){return new a4}function sX(){return new a6}function sZ(e){return new a5(e)}function sY(e){return new a8(e)}function sJ(e){return new a9(e)}function sQ(e){return new a7(e)}function s0(e){return new se(e)}function s1(e){return new st(e)}function s2(e){return new sr(e)}function s3(e){return new sn(e)}function s4(e){return new sa(e)}function s6(e){return new ss(e)}function s5(e){return new si(e)}function s8(e){return new so(e)}function s9(e){return new sl(e)}e.s(["maxNorm",()=>sG,"minMaxNorm",()=>sj,"nonNeg",()=>sH,"unitNorm",()=>sq],60755),e.i(60755),e.s(["constant",()=>sZ,"glorotNormal",()=>s3,"glorotUniform",()=>s2,"heNormal",()=>s4,"heUniform",()=>s6,"identity",()=>s0,"leCunNormal",()=>s5,"leCunUniform",()=>s8,"ones",()=>sX,"orthogonal",()=>s9,"randomNormal",()=>sJ,"randomUniform",()=>sY,"truncatedNormal",()=>sQ,"varianceScaling",()=>s1,"zeros",()=>sK],2993),e.i(2993);var s7=e.i(58318);async function ie(e){if(null==e)return;let t=[],r=[],n=[];for(let a in e){let s=e[a];"number"!=typeof s&&(t.push(s.data()),r.push(a),n.push(s))}if(t.length>0){let a=await Promise.all(t);for(let t=0;t<a.length;++t)e[r[t]]=a[t][0];(0,nz.dispose)(n)}}function it(e){if(null!=e)for(let t in e){let r=e[t];"number"!=typeof r&&r.dispose()}}(s=p||(p={}))[s.SILENT=0]="SILENT",s[s.VERBOSE=1]="VERBOSE";class ir{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class ia{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){for(let r of(null==t&&(t={}),this.callbacks))await r.onEpochBegin(e,t)}async onEpochEnd(e,t){for(let r of(null==t&&(t={}),this.callbacks))await r.onEpochEnd(e,t)}async onBatchBegin(e,t){for(let r of(null==t&&(t={}),this.callbacks))await r.onBatchBegin(e,t)}async onBatchEnd(e,t){for(let r of(null==t&&(t={}),this.callbacks))await r.onBatchEnd(e,t)}async onTrainBegin(e){for(let t of(null==e&&(e={}),this.callbacks))await t.onTrainBegin(e)}async onTrainEnd(e){for(let t of(null==e&&(e={}),this.callbacks))await t.onTrainEnd(e)}}class is extends ir{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});let r=null==t.size?0:t.size;for(let e in this.seen+=r,t){let n=t[e];if("number"==typeof n)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+n*r;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;let a=(0,nz.tidy)(()=>(0,X.add)(this.totals[e],(0,$.mul)(n,r)));this.totals[e]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(let e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?t[e]=this.totals[e]/this.seen:(0,nz.tidy)(()=>{let r=(0,$.mul)((0,D.div)(1,this.seen),this.totals[e]);t[e]=r,this.totals[e].dispose(),(0,nz.keep)(t[e])}))}}class ii extends ir{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){for(let r in null==t&&(t={}),this.epoch.push(e),t)null==this.history[r]&&(this.history[r]=[]),this.history[r].push(t[r])}async syncData(){let e=[],t=[],r=[];for(let n in this.history){let a=this.history[n];for(let s=0;s<a.length;++s)if("number"!=typeof a[s]){let i=a[s];e.push(i.data()),t.push(n),r.push(s)}}let n=await Promise.all(e);for(let e=0;e<n.length;++e)this.history[t[e]][r[e]].dispose(),this.history[t[e]][r[e]]=n[e][0]}}class io extends ir{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||s7.nextFrame,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");nP.util.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,r){let n,a=null!=r?r():nP.util.now();return(...s)=>{let i=null!=r?r():nP.util.now();return i-a<t?n:(a=i,n=e(...s))}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,r){let n=[];null!=this.yield&&(await ie(r),n.push(this.yield(e,t,r))),n.push(this.nextFrameFunc()),await Promise.all(n)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await ie(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let r=[];null!=this.epochEnd&&(await ie(t),r.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(e,t){null!=this.batchBegin&&(await ie(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let r=[];null!=this.batchEnd&&(await ie(t),r.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?r.push(this.nextFrameFunc()):nP.util.isNumber(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(r)}async onTrainBegin(e){null!=this.trainBegin&&(await ie(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await ie(e),await this.trainEnd(e))}}function il(e,t){return(null==e&&(e={}),e instanceof ir)?[e]:Array.isArray(e)&&e[0]instanceof ir?e:nZ(e).map(e=>new io(e,t))}class iu{static registerCallbackConstructor(e,t){nP.util.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),iu.checkForDuplicate(t),null==iu.constructors[e]&&(iu.constructors[e]=[]),iu.constructors[e].push(t)}static checkForDuplicate(e){for(let t in iu.constructors)iu.constructors[+t].forEach(t=>{if(t===e)throw new nW("Duplicate callback constructor.")})}static clear(){iu.constructors={}}static createCallbacks(e){let t=[];for(let r in iu.constructors){let n=+r;e>=n&&t.push(...iu.constructors[n])}return t.map(e=>new e)}}function ih(e,t,r,n,a,s,i,o,l){let u=new ii,h=[new is,...iu.createCallbacks(t)];null!=e&&h.push(...e),h.push(u);let p=new ia(h);return p.setParams({epochs:r,initialEpoch:n,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:p,history:u}}iu.constructors={};var ip=e.i(95253),id=e.i(18985),n9=n9,n9=n9;function ic(e,t={},r=!1){return n1(e,n9.SerializationMap.getMap().classNameMap,t,"layer",r)}var im=e.i(27553);function ig(e,t){return(0,nz.tidy)(()=>{"float32"!==e.dtype&&(e=E.cast(e,"float32"));let r=W.sum(aZ(e),t,!0),n=im.fill(r.shape,aL()),a=_.sqrt(rv.maximum(r,n));return D.div(e,a)})}function iy(e,t){return(0,nz.tidy)(()=>ni.mean(aZ(L.sub(t,e)),-1))}function ib(e,t){return(0,nz.tidy)(()=>ni.mean(rk.abs(L.sub(t,e)),-1))}function ix(e,t){return(0,nz.tidy)(()=>{let r=L.sub(e,t),n=rV.clipByValue(rk.abs(e),aL(),Number.MAX_VALUE),a=rk.abs(D.div(r,n));return $.mul(100,ni.mean(a,-1))})}function iv(e,t,r=!1){return(0,nz.tidy)(()=>{if(r)t=nE.softmax(t);else{let e=W.sum(t,t.shape.length-1,!0);t=D.div(t,e)}return t=rV.clipByValue(t,aL(),1-aL()),F.neg(W.sum($.mul(E.cast(e,"float32"),tF.log(t)),t.shape.length-1))})}function iw(e,t,r=!1){return(0,nz.tidy)(()=>{let n,a=E.cast(tN.floor((n=[aF(e.shape)],V.reshape(e,n))),"int32"),s=(t=rV.clipByValue(t,aL(),1-aL())).shape;return iv(V.reshape(nc.oneHot(a,s[s.length-1]),s),t,r)})}function iS(e,t){return(0,nz.tidy)(()=>{let r;return r=rV.clipByValue(t,aL(),1-aL()),r=tF.log(D.div(r,L.sub(1,r))),ni.mean(function(e,t){if(!nP.util.arraysEqual(e.shape,t.shape))throw new nW(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return(0,nz.tidy)(()=>{let r=nx.relu(t),n=F.neg(rk.abs(t));return X.add(L.sub(r,$.mul(t,e)),nt.log1p(eq.exp(n)))})}(e,r),-1)})}function iN(e,t){return(0,nz.tidy)(()=>{let r=ig(e,-1),n=ig(t,-1),a=$.mul(r,n);return F.neg(W.sum(a,-1))})}let ik={meanSquaredError:iy,meanAbsoluteError:ib,meanAbsolutePercentageError:ix,meanSquaredLogarithmicError:function(e,t){return(0,nz.tidy)(()=>{let r=rV.clipByValue(t,aL(),Number.MAX_VALUE),n=tF.log(X.add(1,r)),a=rV.clipByValue(e,aL(),Number.MAX_VALUE),s=tF.log(X.add(1,a));return ni.mean(aZ(L.sub(n,s)),-1)})},squaredHinge:function(e,t){return(0,nz.tidy)(()=>{let r=rv.maximum(0,L.sub(1,$.mul(e,t)));return ni.mean(aZ(r),-1)})},hinge:function(e,t){return(0,nz.tidy)(()=>{let r=rv.maximum(0,L.sub(1,$.mul(e,t)));return ni.mean(r,-1)})},categoricalHinge:function(e,t){return(0,nz.tidy)(()=>{let r=W.sum($.mul(e,t),-1),n=ns.max($.mul(L.sub(1,e),t),-1);return rv.maximum(0,X.add(1,L.sub(n,r)))})},logcosh:function(e,t){return(0,nz.tidy)(()=>{let r=Math.log(2),n=L.sub(t,e),a=L.sub(X.add(n,n$.softplus($.mul(-2,n))),r);return ni.mean(a,-1)})},categoricalCrossentropy:iv,sparseCategoricalCrossentropy:iw,binaryCrossentropy:iS,kullbackLeiblerDivergence:function(e,t){return(0,nz.tidy)(()=>{let r=rV.clipByValue(e,aL(),1),n=rV.clipByValue(t,aL(),1);return W.sum($.mul(e,tF.log(D.div(r,n))),-1)})},poisson:function(e,t){return(0,nz.tidy)(()=>{let r=tF.log(X.add(aL(),t));return ni.mean(L.sub(t,$.mul(e,r)),-1)})},cosineProximity:iN};function iI(e){if("string"!=typeof e)return e;{if(e in ik)return ik[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new nW(t)}}function iT(e,t){return(0,nz.tidy)(()=>{let r=$.mul(.5,nf.onesLike(t)),n=aP(tt.greater(t,r),e.dtype);return ni.mean(tl.equal(e,n),-1)})}function iC(e,t){return(0,nz.tidy)(()=>aP(tl.equal(rA.argMax(e,-1),rA.argMax(t,-1)),"float32"))}function iE(e,t){return(0,nz.tidy)(()=>E.cast(W.sum(eb.logicalAnd(tl.equal(e,1),tl.equal(t,1))),"float32"))}function i$(e,t){return(0,nz.tidy)(()=>{let r=iE(e,t),n=(0,nz.tidy)(()=>E.cast(W.sum(eb.logicalAnd(tl.equal(e,0),tl.equal(t,1))),"float32")),a=X.add(r,n);return E.cast(ex.where(tt.greater(a,0),D.div(r,a),0),"float32")})}function iA(e,t){return iS(e,t)}function iR(e,t){return e.rank===t.rank&&(e=nR.squeeze(e,[e.rank-1])),(t=rA.argMax(t,-1)).dtype!==e.dtype&&(t=E.cast(t,e.dtype)),E.cast(tl.equal(e,t),"float32")}let iD={binaryAccuracy:iT,categoricalAccuracy:iC,precision:i$,categoricalCrossentropy:iv,sparseCategoricalCrossentropy:iw,mse:iy,MSE:iy,mae:ib,MAE:ib,mape:ix,MAPE:ix,cosine:iN};function iF(e){if(nj(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(let r of Object.keys(ik))if(ik[r]===e){t=r;break}if(void 0!==t)return t;for(let r of Object.keys(iD))if(iD[r]===e){t=r;break}return void 0!==t?t:e.name}}var iO=e.i(79975);function i_(e,t,r=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!function e(t){if(null===t)return!0;if("object"==typeof t)if(Object.getPrototypeOf(t)===Object.prototype){for(let r of Object.keys(t))if("string"!=typeof r||!e(t[r]))return!1;return!0}else{if(!Array.isArray(t))return!1;for(let r of t)if(!e(r))return!1;return!0}{let e=typeof t;return"string"===e||"number"===e||"boolean"===e}}(e))throw Error("User-defined metadata is expected to be a JSON object, but is not.");if(r){let r=JSON.stringify(e);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function iM(e,t,r=console.log){let n="";for(let r=0;r<e.length;++r)r>0&&(n=n.slice(0,n.length-1)+" "),n+=e[r],n=n.slice(0,t[r]),n+=" ".repeat(t[r]-n.length);r(n)}function iL(e,t,r){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof r}function iz(e,t){if(null===e)return null;if("string"==typeof e)return nJ(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let r=[],n=e.length;for(let a=0;a<n;++a){let n=e[a];iL(t,a,n)?r.push(n):r.push(iz(n,t))}return r}{let t={};for(let r of Object.keys(e)){let n=e[r];if("name"===r&&"string"==typeof n)t[r]=n;else{let e=nJ(r);t[e]=iz(n,e)}}return t}}let iP="4.22.0";class iB extends sC{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=at(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],n3(this.inputs).length!==this.inputs.length)throw new nW(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(e=>e.name)}`);for(const e of(n3(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(e=>e.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[],this.outputs)){const t=e.sourceLayer,r=e.nodeIndex,n=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(r),this.outputLayersTensorIndices.push(n)}for(const e of this.inputs){const t=e.sourceLayer,r=e.nodeIndex,n=e.tensorIndex;nj(0===r,"input layer has >1 nodes"),nj(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(r),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let t=0;t<this.inputLayers.length;t++){const r=this.inputLayers[t];if(!(r instanceof sE))throw TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${t} (0-based) originates from layer type ${r.getClassName()}.`);this.inputNames.push(r.name),this.feedInputShapes.push(r.batchInputShape),this.feedInputNames.push(r.name)}for(const e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);const t={},r={},n={},a={},s={},i=[],o=(e,t,r,n,a,l)=>{(null==n||null==a||null==l)&&(n=e.sourceLayer,a=e.nodeIndex,l=e.tensorIndex);let u=n.inboundNodes[a];if(-1!==r.indexOf(u))throw new nV(`The tensor ${e.name} at layer "${n.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(iB.nodeKey(n,a)),n.id in s||(s[n.id]=Object.keys(s).length),-1===r.indexOf(u)&&r.push(u);let h=u.inboundLayers.length;for(let e=0;e<h;e++)o(u.inputTensors[e],t,r,u.inboundLayers[e],u.nodeIndices[e],u.tensorIndices[e]);for(t.push(u);r.indexOf(u)>=0;)r.splice(r.indexOf(u),1);i.push(u)},l=[],u=[];for(const e of this.outputs)o(e,l,u);for(const e of i.slice().reverse()){r[e.id]=e,e.id in t||(t[e.id]=0);let s=t[e.id];s=Math.max(s,null==n[e.outboundLayer.id]?0:n[e.outboundLayer.id]),n[e.outboundLayer.id]=s,a[e.outboundLayer.id]=e.outboundLayer,t[e.id]=s;for(let n=0;n<e.inboundLayers.length;n++){const a=e.inboundLayers[n],i=e.nodeIndices[n],o=a.inboundNodes[i],l=null==t[o.id]?0:t[o.id];t[o.id]=Math.max(s+1,l),r[o.id]=o}}const h={};for(const e in t){const n=t[e];n in h||(h[n]=[]),h[n].push(r[e])}const p={};for(const e in n){const t=n[e];t in p||(p[t]=[]),p[t].push(a[e])}let d=Object.keys(p).map(e=>parseInt(e,10)).sort(n2);for(const e of(this.layers=[],d)){const t=p[e];for(const e of(t.sort((e,t)=>{let r=s[e.id],n=s[t.id];return r<n?-1:+(r>n)}),t))e instanceof iB&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=p,d=Object.keys(h).map(e=>parseInt(e,10)).sort(n2);const c=this.inputs.slice(),f=[];for(const e of d)for(const t of h[e]){const e=t.outboundLayer;if(null!=e){for(const r of t.inputTensors)if(-1===c.indexOf(r))throw new nV(`Graph disconnected: cannot obtain value for tensor ${r} at layer "${e.name}". The following previous layers were accessed without issue: ${f}`);for(const e of t.outputTensors)c.push(e);f.push(e.name)}}this.nodesByDepth=h;const m=this.layers.map(e=>e.name);for(const e of m){const t=m.filter(t=>t===e).length;if(1!==t)throw new nV(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new sI({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new nW("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let r={},n=0,a=(e=>{let t=Object.keys(e);if(0===t.length)return!1;let r=t[0].split("/");return!isNaN(parseInt(r[r.length-1],10))})(e);for(let t of(a&&this.parseWeights(e),this.layers))for(let[e,s]of t.weights.entries()){let t=a?`${s.name.split("/").slice(0,-1).join("/")+"/"}${e}`:s.originalName;if(null!=r[t])throw new nW(`Duplicate weight name: ${t}`);r[t]=s,n++}let s=[];for(let n in e){let a=n;if(null==r[n]){let e=n.split("/");a=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=r[a])s.push([r[a],e[n]]);else if(t)throw new nW(`Provided weight data has no target variable: ${n}`);delete r[a]}if(t){let e=[];for(let t in r)e.push(t);if(e.length>0)throw new nW(`${e.length} of ${n} weights are not set: ${e}`)}sw(s)}parseWeights(e){for(let t in Object.keys(e)){let r=t.split("/"),n=["vars","layer_checkpoint_dependencies"],a=r.map(e=>e.startsWith("_")?e.slice(1):e).filter(e=>!n.includes(e)).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${iP}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let r=function e(t,r){if(null==t)return null;if("string"==typeof t)return nY(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){let n=[],a=t.length;for(let s=0;s<a;++s){let a=t[s];iL(r,s,a)?n.push(a):n.push(e(a,r))}return n}{let r={};for(let n of Object.keys(t)){let a=t[n],s=nY(n);("name"===n||"className"===n)&&"string"==typeof a?r[s]=a:r[s]=e(a,n)}return r}}(this.updatedConfig());return t?JSON.stringify(r):r}call(e,t){return(0,nz.tidy)(()=>{e=nZ(e);let r=new sA;for(let t=0;t<this.inputs.length;++t)r.add(this.inputs[t],e[t]);return sF(this.outputs,r,t)})}computeMask(e,t){return(0,nz.tidy)(()=>{let r;return e=nZ(e),r=null==t?nH(null,e.length):nZ(t),this.runInternalGraph(e,r)[1]})}computeOutputShape(e){let t=sc(e);if(t.length!==this.inputLayers.length)throw new nW(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let e=0;e<t.length;e++){let n=this.inputLayers[e],a=t[e];r[n.name+"_0_0"]=a}let n=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(n2);if(n.length>1)for(let e of n)for(let t of this.nodesByDepth[e]){let e=t.outboundLayer;if(-1!==this.inputLayers.map(e=>e.id).indexOf(e.id))continue;let n=[];for(let e=0;e<t.inboundLayers.length;e++){let a=t.inboundLayers[e],s=t.nodeIndices[e],i=t.tensorIndices[e],o=r[`${a.name}_${s}_${i}`];n.push(o)}let a=sc(e.computeOutputShape(nX(n))),s=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++)r[`${e.name}_${s}_${t}`]=a[t]}let a=[],s=[];for(let e=0;e<this.outputLayers.length;e++){let t=this.outputLayers[e],r=this.outputLayersNodeIndices[e],n=this.outputLayersTensorIndices[e],a=`${t.name}_${r}_${n}`;s.push(a)}for(let e=0;e<s.length;e++){let t=s[e];nj(t in r),a.push(r[t])}return nX(a)}runInternalGraph(e,t){null==t&&(t=nH(null,e.length));let r={};for(let n=0;n<this.inputs.length;++n){let a=this.inputs[n],s=e[n],i=t[n];r[a.id]=[s,i]}for(let e of Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(n2))for(let t of this.nodesByDepth[e]){let e=t.outboundLayer,n=t.inputTensors,a=t.outputTensors,s=[];for(let e of n)e.id in r&&s.push(r[e.id]);if(s.length===n.length){let n,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===s.length){let[t,r]=s[0];null==u.mask&&(u.mask=r),o=nZ(e.call(t,u)),l=nZ(e.computeMask(t,r)),n=[t],i=[r]}else n=s.map(e=>e[0]),i=s.map(e=>e[1]),null==u.mask&&(u.mask=i),o=nZ(e.call(n,u)),l=nZ(e.computeMask(n,i));if(e.activityRegularizer)throw new nU("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){let t=a[e],n=o[e],s=l[e];r[t.id]=[n,s]}}}let n=[],a=[],s=[];for(let e of this.outputs){nj(e.id in r,`Could not compute output ${e.name} : ${e.id}`);let[t,i]=r[e.id];s.push(t.shape),n.push(t),a.push(i)}return[n,a,s]}buildNodeConversionMap(e){let t,r={};for(let e of this.layers){t=+(e instanceof iB);for(let n=0;n<e.inboundNodes.length;n++){let a=iB.nodeKey(e,n);this.containerNodes.has(a)&&(r[a]=t,t+=1)}}return r}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new nW("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(let t of this.layers)if(t.name===e)return t;throw new nW(`No such layer: ${e}`)}findLayer(e){if(!(this.layers.length<=e))return this.layers[e];throw new nW(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`)}calculateLosses(){return(0,nz.tidy)(()=>{let e=[];for(let t of this.layers)for(let r=0;r<t.inboundNodes.length;++r){let n=iB.nodeKey(t,r);this.containerNodes.has(n)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),r=[];for(let e of this.layers){let n=e.getClassName(),a=e.getConfig(),s=[];for(let r=0;r<e.inboundNodes.length;r++){let n=e.inboundNodes[r],a=iB.nodeKey(e,r),i={};if(this.containerNodes.has(a)){if(n.callArgs)try{JSON.stringify(n.callArgs),i=n.callArgs}catch(t){console.warn(`Layer ${e.name} was passed non-serializable keyword arguments: ${n.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(n.inboundLayers.length>0){let e=[];for(let r=0;r<n.inboundLayers.length;r++){let a=n.inboundLayers[r],s=n.nodeIndices[r],o=n.tensorIndices[r],l=t[iB.nodeKey(a,s)];null==l&&(l=0),e.push([a.name,l,o,i])}s.push(e)}}}let i={};i.name=e.name,i.className=n,i.config=a,i.inboundNodes=s,r.push(i)}e.layers=r;let n=[];for(let e=0;e<this.inputLayers.length;e++){let r=this.inputLayers[e],a=this.inputLayersNodeIndices[e],s=iB.nodeKey(r,a);if(!this.containerNodes.has(s))continue;let i=t[s];null==i&&(i=0);let o=this.inputLayersTensorIndices[e];n.push([r.name,i,o])}e.inputLayers=n;let a=[];for(let e=0;e<this.outputLayers.length;e++){let r=this.outputLayers[e],n=this.outputLayersNodeIndices[e],s=iB.nodeKey(r,n);if(!this.containerNodes.has(s))continue;let i=t[s];null==i&&(i=0);let o=this.outputLayersTensorIndices[e];a.push([r.name,i,o])}return e.outputLayers=a,e}static fromConfig(e,t,r={},n=!1){let a={},s={};function i(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}let o=t.name,l=t.layers;for(let e of l)!function(e){let r=e.name,s=ic(e,null!=t.customObjects?t.customObjects:{});s.setFastWeightInitDuringBuild(n),a[r]=s,e.inboundNodes.forEach(e=>{if(!(e instanceof Array))throw new nW(`Corrupted configuration, expected array for nodeData: ${e}`);i(s,e)})}(e);for(;!function(e){if(null==e)throw new nW(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}(s);)for(let e of l){let t=a[e.name];if(t.name in s){let e=s[t.name];for(let r of(delete s[t.name],e))!function(e,t){let r,n=[];for(let s of t){let o=s[0],l=s[1],u=s[2];if(r=null==s[3]?{}:s[3],!(o in a))return void i(e,t);let h=a[o];if(h.inboundNodes.length<=l)return void i(e,t);let p=h.inboundNodes[l];n.push(p.outputTensors[u])}n.length>0&&e.apply(nX(n),r)}(t,r)}}let u=[],h=[];for(let e of t.inputLayers){let t=e[0],r=e[1],n=e[2];nj(t in a);let s=a[t].inboundNodes[r].outputTensors;u.push(s[n])}for(let e of t.outputLayers){let t=e[0],r=e[1],n=e[2];nj(t in a);let s=a[t].inboundNodes[r].outputTensors;h.push(s[n])}return new e({inputs:u,outputs:h,name:o})}get stateful(){if(this._stateful)throw new nW("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){(0,nz.tidy)(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}var iV=e.i(39705);function iW(e,t){var r="classWeight";let n=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>null);if(1===n)if(Array.isArray(e)&&1===e.length)return e;else if("object"==typeof e&&t[0]in e)return[e[t[0]]];else return[e];if(Array.isArray(e)){if(e.length!==n)throw Error(`Provided ${r} is an array of ${e.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){let r=[];return t.forEach(t=>{t in e?r.push(e[t]):r.push(null)}),r}throw Error(`The model has multiple (${n}) outputs, so ${r} must be either an array with ${n} elements or an object with ${t} keys. Provided ${r} not understood: ${JSON.stringify(e)}`)}async function iU(e,t,r,n){if(null!=t||null!=n)throw Error("Support sampleWeight is not implemented yet");if(null==r)return null;{let t=(0,nz.tidy)(()=>{if(1===e.shape.length)return(0,iV.clone)(e);if(2===e.shape.length)if(e.shape[1]>1)return(0,rA.argMax)(e,1);else if(1===e.shape[1])return(0,V.reshape)(e,[e.shape[0]]);else throw Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`);throw Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),n=Array.from(await t.data());(0,nz.dispose)(t);let a=[];return n.forEach(e=>{if(null==r[e])throw Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(r[e])}),(0,aD.tensor1d)(a,"float32")}}function iG(e,t){let r,n;r=t.xs,n=t.ys,nP.util.assert(null!=r&&null!=n,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let a=iq("input",e.inputNames,r),s=iq("output",e.outputNames,n),i=a[0].shape[0];nP.util.assert(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),nP.util.assert(s.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${s.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let t=0;t<a.length;t++)nP.util.assert(a[t].shape[0]===i,()=>`Batch size mismatch: input ${e.inputNames[t]} has ${a[t].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);for(let t=0;t<s.length;t++)nP.util.assert(s[t].shape[0]===i,()=>`Batch size mismatch: output ${e.outputNames[t]} has ${s[t].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);return{xs:a,ys:s}}function iq(e,t,r){if(r instanceof rI.Tensor)return[r];if(Array.isArray(r))return nP.util.assert(r.length===t.length,()=>`Received an array of ${r.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),r;{let n=[];for(let a of t){if(null==r[a])throw new nW(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);n.push(r[a])}return n}}async function iH(e,t,r){let n=null!=r.batchesPerEpoch;if(nP.util.assert(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),nP.util.assert(null!=r,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),nP.util.assert(null!=r.epochs&&r.epochs>0&&Number.isInteger(r.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${r.epochs}`),nP.util.assert(!n||r.batchesPerEpoch>0&&Number.isInteger(r.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${r.batchesPerEpoch}`),nP.util.assert(null==r.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{var a,s;let i,o,l,u,h=null!=r.validationData;if(h)if(ij(r.validationData))nP.util.assert(null==r.validationBatches||r.validationBatches>0&&Number.isInteger(r.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${r.validationBatches}`);else{let e=function(e){if(3===e.length)throw new nU("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(r.validationData);o=e.xs,l=e.ys}let p=e.makeTrainFunction(),d=e.getDedupedMetricsNames();u=h?d.slice().concat(d.map(e=>"val_"+e)):d.slice();let c=il(r.callbacks,r.yieldEvery),f=null==r.verbose?1:r.verbose,{callbackList:m,history:g}=ih(c,f,r.epochs,null,null,(a=t,s=r,i=null,null!=s.batchesPerEpoch?i=s.batchesPerEpoch:Number.isFinite(a.size)&&(i=a.size),i),null,h,u);m.setModel(e),e.history=g,await m.onTrainBegin(),e.stopTraining_=!1;let y=null==r.initialEpoch?0:r.initialEpoch,b=await t.iterator();for(;y<r.epochs;){let a={};await m.onEpochBegin(y);let s=0,i=0;for(n||(b=await t.iterator());!n||s<r.batchesPerEpoch;){let t=await b.next();if(n&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${r.batchesPerEpoch}, but your dataset iterator ran out of data after ${s} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${r.batchesPerEpoch*r.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){let{xs:n,ys:a}=iG(e,t.value),o={};o.batch=i,o.size=n[0].shape[0],await m.onBatchBegin(i,o);let l=[];if(null!=r.classWeight){let t=iW(r.classWeight,e.outputNames);for(let e=0;e<t.length;++e)l.push(await iU(a[e],null,t[e]))}let u=n.concat(a).concat(l),h=p(u);nz.dispose(u);for(let e=0;e<d.length;++e){let t=d[e],r=h[e];o[t]=r,nz.keep(r)}await m.onBatchEnd(i,o),it(o),i++,s++}if(n?s>=r.batchesPerEpoch:t.done){if(h){let t;t=ij(r.validationData)?nZ(await e.evaluateDataset(r.validationData,{batches:r.validationBatches})):nZ(e.evaluate(o,l,{batchSize:null==r.validationBatchSize?32:r.validationBatchSize,verbose:0}));for(let r=0;r<e.metricsNames.length;++r)a[`val_${e.metricsNames[r]}`]=t[r]}break}if(e.stopTraining_)break}if(await m.onEpochEnd(y,a),y++,e.stopTraining_)break}return await m.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function ij(e){return"function"==typeof e.iterator}async function iK(e,t,r){let n=null!=(r=r||{}).batches,a=e.testFunction,s=[];if(r.verbose>0)throw new nU("Verbose mode is not implemented yet.");nP.util.assert(!n||r.batches>0&&Number.isInteger(r.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(r.batches)}`);let i="function"==typeof t.next?t:await t.iterator(),o=0,l=0;for(;!n||l<r.batches;){let t=await i.next();if(s=nz.tidy(()=>{if(t.value){let{xs:r,ys:n}=iG(e,t.value),i=r.concat(n),u=nz.tidy(()=>a(i));if(nz.dispose(i),0===l)for(let e=0;e<u.length;++e)s.push((0,O.scalar)(0));let h=i[0].shape[0];for(let e=0;e<u.length;++e){let t=u[e],r=s[e];s[e]=nz.tidy(()=>X.add(s[e],$.mul(h,t))),l>0&&nz.dispose(r)}nz.dispose(u),o+=h,++l}return s}),t.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${r.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let e=0;e<s.length;++e){let t=s[e];s[e]=D.div(s[e],o),nz.dispose(t)}return nX(s)}function iX(e){nP.util.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function iZ(e,t,r){return null==e?[null]:Array.isArray(e)?e.map(e=>aV(e,t,r-t)):aV(e,t,r-t)}function iY(e,t){return nz.tidy(()=>null==e?null:Array.isArray(e)?e.map(e=>iY(e,t)):aX(e,"int32"===t.dtype?t:E.cast(t,"int32")))}function iJ(e,t){let r=[],n=0,a=null;for(;n<e;)(a=n+t)>=e&&(a=e),r.push([n,a]),n=a;return r}function iQ(e){let t=[];e instanceof rI.Tensor&&(e=[e]);for(let r=0;r<e.length;++r){let n=e[r];if(1===n.rank)t.push(aB(n,1));else if(0===n.rank)throw Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");else t.push(n)}return t}function i0(e,t){if(null==e)return;let r=[];if(t instanceof rI.Tensor)r.push(t.id);else if(Array.isArray(t))t.forEach(e=>r.push(e.id));else if(null!=t)for(let e in t){let n=t[e];r.push(n.id)}let n=[];if(e instanceof rI.Tensor)-1===r.indexOf(e.id)&&n.push(e);else if(Array.isArray(e))e.forEach(e=>{-1===r.indexOf(e.id)&&n.push(e)});else if(null!=e)for(let t in e){let a=e[t];-1===r.indexOf(a.id)&&n.push(a)}n.forEach(e=>{e.isDisposed||e.dispose()})}function i1(e){return Array.isArray(e)}function i2(e){return!(e instanceof rI.Tensor)&&!i1(e)}function i3(e,t,r,n=!0,a=""){let s;if(null==t||0===t.length){if(null!=e){let t=!1;if(i1(e)&&e.length>0)t=!0;else if(i2(e)){for(let r in e)if(e.hasOwnProperty(r)){t=!0;break}}else t=!0;if(t)throw new nW(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(null==e)return t.map(e=>null);if(i2(e))for(let r of(s=[],t)){if(null==e[r])throw new nW(`No data provided for "${r}". Need data for each key in: ${t}`);s.push(e[r])}else if(i1(e)){if(e.length!==t.length)throw new nW(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(t.length>1)throw new nW(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=iQ(s),null!=r)for(let e=0;e<t.length;++e){if(null==r[e])continue;let i=s[e];if(i.shape.length!==r[e].length)throw new nW(`Error when checking ${a}: expected ${t[e]} to have ${r[e].length} dimension(s). but got array with shape ${i.shape}`);for(let t=0;t<r[e].length;++t){if(0===t&&!n)continue;let s=i.shape[t],o=r[e][t];if(null!=o&&o>=0&&s!==o)throw new nW(`${a} expected a batch of elements where each example has shape [${r[e].slice(1,r[e].length)}] (i.e.,tensor shape [*,${r[e].slice(1,r[e].length)}]) but the ${a} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return s}function i4(e,t,r,n=!0,a=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new nW(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new nW(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(null!=r)for(let e=0;e<t.length;++e){if(null==r[e])continue;let i=s[e];if(i.shape.length!==r[e].length)throw new nW(`Error when checking ${a}: expected ${t[e]} to have ${r[e].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let s=0;s<r[e].length;++s){if(0===s&&!n)continue;let o=i.shape[s],l=r[e][s];if(null!=l&&l!==o)throw new nW(`Error when checking ${a}: expected ${t[e]} to have shape ${JSON.stringify(r[e])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}class i6 extends iB{constructor(e){super(e),this.isTraining=!1}summary(e,t,r=console.log){if(!this.built)throw new nW("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,r,n=console.log){var a;let s,i=function(e){let t=!0,r=[],n=[];for(let t in e.nodesByDepth)r.push(e.nodesByDepth[t]);for(let e of r){if(e.length>1||1===e.length&&e[0].inboundLayers.length>1){t=!1;break}n.push(...e)}if(t)for(let r of e.layers){let e=!1;for(let a of r.inboundNodes)if(-1!==n.indexOf(a))if(e){t=!1;break}else e=!0;if(!t)break}return t}(e),o=["Layer (type)","Input Shape","Output shape","Param #"];if(i?(t=t||90,r=r||[.32,.61,.89,1]):(t=t||115,r=r||[.24,.48,.7,.8,1]),r[r.length-1]<=1&&(r=r.map(e=>Math.floor(t*e))),!i)for(let t in o.push("Receives inputs"),s=[],e.nodesByDepth)s.push(...e.nodesByDepth[t]);n("_".repeat(t)),iM(o,r,n),n("=".repeat(t));let l=e.layers;for(let e=0;e<l.length;++e)i?function(e,t,r){let n,a;try{a=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(e){a="multiple"}try{n=JSON.stringify(e.outputShape)}catch(e){n="multiple"}let s=e.name,i=e.getClassName();iM([`${s} (${i})`,a,n,e.countParams().toString()],t,r)}(l[e],r,n):function(e,t,r,n){let a,s;try{s=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(e){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(e){a="multiple"}let i=[];for(let t of e.inboundNodes)if(null==r||!(r.length>0)||-1!==r.indexOf(t))for(let e=0;e<t.inboundLayers.length;++e){let r=t.inboundLayers[e].name,n=t.nodeIndices[e],a=t.tensorIndices[e];i.push(`${r}[${n}][${a}]`)}let o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];iM([`${o} (${l})`,s,a,e.countParams().toString(),u],t,n);for(let e=1;e<i.length;++e)iM(["","","","",i[e]],t,n)}(l[e],r,s,n),n((e===l.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let u=null!=(a=e).collectedTrainableWeights?sg(a.collectedTrainableWeights):sg(a.trainableWeights),h=sg(e.nonTrainableWeights);n(`Total params: ${u+h}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${h}`),n("_".repeat(t))}(this,e,t,r)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){let t={Adagrad:()=>iO.train.adagrad(.01),Adadelta:()=>iO.train.adadelta(1,.95,aL()),Adam:()=>iO.train.adam(.001,.9,.999,aL()),Adamax:()=>iO.train.adamax(.002,.9,.999,aL(),0),RMSProp:()=>iO.train.rmsprop(.001,.9,0,aL()),SGD:()=>iO.train.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new nW(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof id.Optimizer))throw new nW("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new nW(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(e=>iI(e))}else{let r=iI(e.loss);this.outputs.forEach(e=>{t.push(r)})}else{for(let t in e.loss=e.loss,e.loss)if(-1===this.outputNames.indexOf(t))throw new nW(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(let r of this.outputNames)null==e.loss[r]&&console.warn(`Output "${r}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${r} during training`),t.push(iI(e.loss[r]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){let t=this.internalOutputShapes[e],r=this.outputNames[e];this.feedOutputNames.push(r),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}let r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ad("loss",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==r.indexOf(e))continue;let t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}});let n=function(e,t){let r;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>[]);if("string"==typeof e||"function"==typeof e)r=[e];else if(Array.isArray(e)||"object"==typeof e)r=e;else throw TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(r))return t.map(e=>r);{let e=[];for(let n of t){let t=r.hasOwnProperty(n)?r[n]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,r)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([r,e])};ad("metric",()=>{for(let e=0;e<this.outputs.length;++e){if(-1===r.indexOf(e))(t=>{let r,n,s;for(let i of t){let t;if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){let t,a=this.internalOutputShapes[e];1===a[a.length-1]||this.lossFunctions[e]===iS?-1!==["accuracy","acc"].indexOf(i)?n=iT:-1!==["crossentropy","ce"].indexOf(i)&&(n=iA):this.lossFunctions[e]===iw?-1!==["accuracy","acc"].indexOf(i)?n=iR:-1!==["crossentropy","ce"].indexOf(i)&&(n=iw):-1!==["accuracy","acc"].indexOf(i)?n=iC:-1!==["crossentropy","ce"].indexOf(i)&&(n=iv),-1!==["accuracy","acc"].indexOf(i)?t="acc":-1!==["crossentropy","ce"].indexOf(i)&&(t="ce"),s=n,r=""+t}else s=function(e){if("string"==typeof e&&e in iD)return iD[e];if("string"!=typeof e&&null!=e)return e;throw new nW(`Unknown metric ${e}`)}(i),r=""+iF(i);ad(r,()=>{t=s}),a(e,r,t)}})(n[e])}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,r={}){let n=null==r.batchSize?32:r.batchSize;iX(n);let a=this.standardizeUserDataXY(e,t,!0,n);try{let e=a[0].concat(a[1]);this.makeTestFunction();let t=this.testFunction,s=this.testLoop(t,e,n,r.verbose,r.steps);return nX(s)}finally{i0(a[0],e),i0(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),iK(this,e,t)}checkNumSamples(e,t,r,n="steps"){let a;if(null!=r){if(a=null,null!=t)throw new nW(`If ${n} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(null!=e)a=Array.isArray(e)?e[0].shape[0]:e.shape[0];else throw new nW(`Either the input data should have a defined shape, or ${n} shoud be specified.`);return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new nW("`outputs` is an empty Array, which is not allowed.");let r=Array.isArray(t),n=r?t:[t],a=this.retrieveSymbolicTensors(n),s=new sA;if(e instanceof rI.Tensor&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new nW(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(let t of this.inputs){let r=e[t.name];if(null==r)throw new nW(`No value is provided for the model's input ${t.name}`);s.add(t,r)}let i=sF(a,s);return r?i:i[0]}retrieveSymbolicTensors(e){let t=nH(null,e.length),r=e.length;for(let n of this.layers){let a=Array.isArray(n.output)?n.output:[n.output],s=a.map(e=>e.name);for(let n=0;n<e.length;++n){let i=s.indexOf(e[n]);if(-1!==i&&(t[n]=a[i],r--),0===r)break}if(0===r)break}if(r>0){let r=[];throw t.forEach((t,n)=>{null==t&&r.push(e[n])}),new nW(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,r=!1){return nz.tidy(()=>{let n=this.checkNumSamples(e);if(r)throw new nU("Verbose predictLoop() is not implemented yet.");let a=iJ(n,t),s=this.outputs.map(e=>[]);for(let t=0;t<a.length;++t)nz.tidy(()=>{let r=iZ(e,a[t][0],a[t][1]),n=[];if(Array.isArray(r))for(let e=0;e<r.length;++e)n.push({key:this.inputs[e],value:r[e]});else n.push({key:this.inputs[0],value:r});let s=new sA(n);return sF(this.outputs,s)}).forEach((e,t)=>s[t].push(e));return nX(s.map(e=>rs.concat(e,0)))})}predict(e,t={}){let r=iQ(e);i4(r,this.inputNames,this.feedInputShapes,!1);try{let e=null==t.batchSize?32:t.batchSize;return iX(e),this.predictLoop(r,e)}finally{i0(r,e)}}predictOnBatch(e){i4(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,r=!0,n){if(null==this.optimizer_)throw new nV("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let e=0;e<this.feedOutputShapes.length;++e){let t=this.feedOutputShapes[e];this.feedLossFns[e]===iw?a.push(t.slice(0,t.length-1).concat([1])):a.push(t)}e=i3(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=i3(t,this.feedOutputNames,a,!1,"target");var s=e,i=t;let o=n3(s.map(e=>e.shape[0]));o.sort();let l=n3(i.map(e=>e.shape[0]));if(l.sort(),o.length>1)throw new nW(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(s.map(e=>e.shape))}`);if(l.length>1)throw new nW(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(i.map(e=>e.shape))}`);if(o.length>0&&l.length>0&&!nP.util.arraysEqual(o,l))throw new nW(`Input Tensors should have the same number of samples as target Tensors. Found ${o[0]} input sample(s) and ${l[0]} target sample(s).`);if(!function(e,t,r){let n=[iy,iS,iv];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=r[a];if(null!=i){if(i===iv&&1===s.shape[s.shape.length-1])throw new nW(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==n.indexOf(i)){let e=s.shape.slice(1),t=o.slice(1);for(let r=0;r<e.length;++r){let n=e[r],a=t[r];if(null!=a&&n!==a)throw new nW(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!=0)throw new nW(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,r,n,a=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,a,s);if(null!=r)throw Error("sample weight is not supported yet.");let l=null;if(null!=n){let e=iW(n,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await iU(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,r,n=0,a){return nz.tidy(()=>{let s=this.checkNumSamples(t,r,a,"steps"),i=[];if(n>0)throw new nU("Verbose mode is not implemented yet.");if(null!=a)throw new nU("steps mode in testLoop() is not implemented yet");{let n=iJ(s,r),a=(0,aD.tensor1d)(aM(0,s));for(let r=0;r<n.length;++r){let s=n[r][0],o=n[r][1],l=e(iY(t,aV(a,s,o-s)));if(0===r)for(let e=0;e<l.length;++e)i.push((0,O.scalar)(0));for(let e=0;e<l.length;++e){let t=l[e];i[e]=X.add(i[e],$.mul(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=D.div(i[e],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let r=0;r<e.length;++r){let n=e[r],a=n;if(nK(e,n)>1){let t=nK(e.slice(0,r),n);a+=`_${t}`}t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],r=e.slice(0,this.inputs.length),n=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=()=>{let e,i=[];for(let e=0;e<this.inputs.length;++e)i.push({key:this.inputs[e],value:r[e]});let o=new sA(i),l=sF(this.outputs,o,{training:!0});for(let r=0;r<this.lossFunctions.length;++r){var u,h;let s=(0,this.lossFunctions[r])(n[r],l[r]);null!=a[r]&&(u=s,h=a[r],s=(0,$.mul)(u,h));let i=ni.mean(s);t.push(i),e=0===r?s:X.add(e,s)}for(let e=0;e<this.metricsTensors.length;++e){let r;if(this.outputs.length>1&&e<this.outputs.length)r=t[e];else{let t=this.metricsTensors[e][0],a=this.metricsTensors[e][1];r=ni.mean(t(n[a],l[a]))}nz.keep(r),s.push(r)}return e=ni.mean(e),this.calculateLosses().forEach(t=>{e=X.add(e,t)}),e},o=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(i,!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>nz.tidy(()=>{let t,r=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:n[e]});let i=new sA(s),o=sF(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){let n=this.lossFunctions[e],s=ni.mean(n(a[e],o[e]));t=0===e?s:X.add(t,s),r.push(t)}for(let e=0;e<this.metricsTensors.length;++e){let t=this.metricsTensors[e][0],n=this.metricsTensors[e][1],s=ni.mean(t(a[n],o[n]));r.push(s)}return r})}async fit(e,t,r={}){let n,a,s,i,o,l,u,h,p;if(this.isTraining)throw Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{let d,c,f,m=null==r.batchSize?32:r.batchSize;iX(m);let g=await this.standardizeUserData(e,t,r.sampleWeight,r.classWeight,!1,m);n=g[0],a=g[1],p=g[2];let y=!1;if(null!=r.validationData&&r.validationData.length>0){if(y=!0,2===r.validationData.length)o=r.validationData[0],l=r.validationData[1];else if(3===r.validationData.length)throw new nU("validationData including sample weights is not supported yet.");else throw new nW(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);let e=await this.standardizeUserData(o,l,null,null,!0,m);u=e[0],h=e[1],d=u.concat(h)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){y=!0;let e=Math.floor(n[0].shape[0]*(1-r.validationSplit)),t=n[0].shape[0];u=iZ(n,e,t),s=n,n=iZ(n,0,e),h=iZ(a,e,t),i=a,a=iZ(a,0,e),d=u.concat(h)}else null!=r.validationSteps&&(y=!0);let b=n.concat(a).concat(p);this.checkTrainableWeightsConsistency();let x=this.makeTrainFunction(),v=this.getDedupedMetricsNames();y?(this.makeTestFunction(),c=this.testFunction,f=v.slice().concat(v.map(e=>"val_"+e))):(c=null,d=[],f=v.slice());let w=il(r.callbacks,r.yieldEvery);return await this.fitLoop(x,b,v,m,r.epochs,r.verbose,w,c,d,r.shuffle,f,r.initialEpoch,null,null)}finally{this.isTraining=!1,i0(n,e),i0(a,t),i0(s,e),i0(i,t),i0(u,o),i0(h,l),null!=p&&nz.dispose(p)}}async fitLoop(e,t,r,n,a,s,i,o,l,u,h,p,d,c){let f;null==n&&(n=32),null==a&&(a=1),null==u&&(u=!0),null==p&&(p=0);let m=!1;if(null!=o&&null!=l&&(m=!0),null!=c&&(m=!0,null==d))throw new nW("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=this.checkNumSamples(t,n,d,"steps_per_epoch");null!=g&&(f=aM(0,g)),null==s&&(s=1);let{callbackList:y,history:b}=ih(i,s,a,p,g,d,n,m,h);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let s=p;s<a;++s){await y.onEpochBegin(s);let a={};if(null!=d)throw new nU("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new nU("batch shuffling is not implemneted yet");u&&nP.util.shuffle(f);let s=(0,aD.tensor1d)(f),i=iJ(g,n);for(let u=0;u<i.length;++u){let h={};if(await y.onBatchBegin(u,h),nz.tidy(()=>{let p=i[u][0],d=i[u][1],c=aV(s,p,d-p);h.batch=u,h.size=d-p;let f=e(iY(t,c));for(let e=0;e<r.length;++e){let t=r[e],n=f[e];h[t]=n,nz.keep(n)}if(u===i.length-1&&m){let e=this.testLoop(o,l,n);for(let t=0;t<r.length;++t){let n=r[t],s=e[t];nz.keep(s),a["val_"+n]=s}}}),await y.onBatchEnd(u,h),it(h),this.stopTraining_)break}s.dispose()}if(await y.onEpochEnd(s,a),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return iH(this,e,t)}async trainOnBatch(e,t){let r=await this.standardizeUserData(e,t),n=r[0],a=r[1],s=this.makeTrainFunction()(n.concat(a)),i=[];for(let e of s){let t=await e.data();i.push(t[0])}return nz.dispose(s),i0(r[0],e),i0(r[1],t),nX(i)}getNamedWeights(e){let t=[],r=null!=e&&e.trainableOnly,n=r?this.trainableWeights:this.weights,a=this.getWeights(r);for(let e=0;e<n.length;++e)(!r||n[e].trainable)&&t.push({name:n[e].originalName,tensor:a[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let t=nz.memory().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-nz.memory().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=nY(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if("string"!=typeof e)throw Error("Serialization of non-string loss is not supported.");e=this.loss.map(e=>nY(e))}else{let t=Object.keys(this.loss);e={};let r=this.loss;for(let n of t)if("string"==typeof r[n])e[n]=nY(r[n]);else throw Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[nY(iF(this.metrics))];{if(Array.isArray(this.metrics))return this.metrics.map(e=>nY(iF(e)));let e={};for(let t in this.metrics)e[t]=nY(iF(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){let t,r;if(null!=e.weighted_metrics)throw Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw Error("Loading sample_weight_mode is not supported yet.");let n=ic(iz(e.optimizer_config));if("string"==typeof e.loss)t=nJ(e.loss);else if(Array.isArray(e.loss))t=e.loss.map(e=>nJ(e));else if(null!=e.loss)for(let r in t={},e.loss)t[r]=nJ(e.loss[r]);if(Array.isArray(e.metrics))r=e.metrics.map(e=>nJ(e));else if(null!=e.metrics)for(let t in r={},e.metrics)r[t]=nJ(e.metrics[t]);this.compile({loss:t,metrics:r,optimizer:n})}async save(e,t){if("string"==typeof e){let t=ip.io.getSaveHandlers(e);if(0===t.length)throw new nW(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new nW(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new nW("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let r=await ip.io.encodeWeights(this.getNamedWeights(t)),n={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${iP}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){n.trainingConfig=this.getTrainingConfig();let{data:e,specs:t}=await ip.io.encodeWeights(await this.optimizer.getWeights(),"optimizer");r.specs.push(...t),r.data=ip.io.concatenateArrayBuffers([r.data,e])}return null!=this.userDefinedMetadata&&(i_(this.userDefinedMetadata,this.name,!0),n.userDefinedMetadata=this.userDefinedMetadata),n.weightData=r.data,n.weightSpecs=r.specs,e.save(n)}setUserDefinedMetadata(e){i_(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}i6.className="Model",n9.registerClass(i6);class i5 extends i6{}i5.className="Functional",n9.registerClass(i5);var n9=n9;async function i8(e,t){"modelTopology"in e||(e={modelTopology:e});let r=e.modelTopology;null!=r.model_config&&(r=r.model_config);let n=ic(iz(r),t);if(null!=e.weightsManifest){let t=await ip.io.loadWeights(e.weightsManifest,e.pathPrefix,n.weights.map(e=>e.originalName)),r={};for(let e of n.weights)r[e.originalName]=t[e.originalName];n.loadWeights(r),(0,nz.dispose)(t)}return n}class i9 extends i6{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:at("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new nW(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t,r=e instanceof i9||e instanceof i6;if(r){if(1!==(t=e).outputs.length)throw new nW("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==t.inputs.length)throw new nW("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new nW("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let t=s$({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(r)this.outputs=t.outputs,this.inputs=t.inputs;else{if(1!==e.inboundNodes.length)throw new nW(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new nW("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=function e(t,r,n){if((null==r||null!=n&&n>0)&&(r=t.sourceLayer,n=t.nodeIndex),0===r.inboundNodes.length)return[t];{let t=r.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{let r=[];for(let n=0;n<t.inboundLayers.length;n++)for(let a of e(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]))-1===r.indexOf(a)&&r.push(a);return r}}}(this.outputs[0])}this.inboundNodes=[],new sI({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:nH(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{let t=e.apply(this.outputs[0]);if(Array.isArray(t))throw TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(sm(e),0===this.inputs.length||0===this.outputs.length)throw TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new i6({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,r=console.log){this.built||this.build(),super.summary(e,t,r)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,r={}){if(!this.built)throw new nV("The model needs to be compiled before being used.");return this.model.evaluate(e,t,r)}async evaluateDataset(e,t){if(!this.built)throw new nV("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,r={}){if(!this.built)throw new nV("The model needs to be compiled before being used.");return this.model.fit(e,t,r)}async fitDataset(e,t){if(!this.built)throw new nV("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,r={},n=!1){let a,s={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new nW("Legacy serialization format not supported yet.");a=t}else nP.util.assert(null!=t.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=t.layers,delete t.layers,s=t;let i=new e(s);if(!(i instanceof i9))throw new nU(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let e of a){let t=ic(e,void 0,n);n&&t.setFastWeightInitDuringBuild(!0),i.add(t)}return i}set stopTraining(e){if(null==this.model)throw new nW("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new nW("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let r={};r.className=t.getClassName(),r.config=t.getConfig(),e.push(r)}return{name:this.name,layers:e}}}function i7(e){return s$(e)}i9.className="Sequential",n9.registerClass(i9);var n9=n9,n9=n9;class oe extends n9.Serializable{getConfig(){return{}}}class ot extends oe{apply(e,t=1){return function(e,t=1){if(1!==t)throw new nU(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return rX.elu(e)}(e,t)}}ot.className="elu",n9.registerClass(ot);class or extends oe{apply(e){return nI.selu(e)}}or.className="selu",n9.registerClass(or);class on extends oe{apply(e){return nx.relu(e)}}on.className="relu",n9.registerClass(on);class oa extends oe{apply(e){return(0,nz.tidy)(()=>nl.minimum(6,nx.relu(e)))}}oa.className="relu6",n9.registerClass(oa);class os extends oe{apply(e){return e}}os.className="linear",n9.registerClass(os);class oi extends oe{apply(e){return rt.sigmoid(e)}}oi.className="sigmoid",n9.registerClass(oi);class oo extends oe{apply(e){return(0,nz.tidy)(()=>{let t=X.add(.5,$.mul(.2,e));return rV.clipByValue(t,0,1)})}}oo.className="hardSigmoid",n9.registerClass(oo);class ol extends oe{apply(e){return n$.softplus(e)}}ol.className="softplus",n9.registerClass(ol);class ou extends oe{apply(e){return(0,nz.tidy)(()=>D.div(e,X.add(rk.abs(e),1)))}}ou.className="softsign",n9.registerClass(ou);class oh extends oe{apply(e){return nO.tanh(e)}}oh.className="tanh",n9.registerClass(oh);class op extends oe{apply(e,t=-1){return nE.softmax(e,t)}}op.className="softmax",n9.registerClass(op);class od extends oe{apply(e,t=-1){return r7.logSoftmax(e,t)}}od.className="logSoftmax",n9.registerClass(od);class oc extends oe{apply(e){return(0,nz.tidy)(()=>nz.tidy(()=>{let t=Math.sqrt(2),r=$.mul(.5,X.add(1,rZ.erf(D.div(e,t))));return $.mul(e,r)}))}}oc.className="gelu",n9.registerClass(oc);class of extends oe{apply(e){return(0,nz.tidy)(()=>$.mul(.5,$.mul(e,X.add(1,nO.tanh($.mul(_.sqrt(D.div(2,Math.PI)),X.add(e,$.mul(.044715,tO.pow(e,3)))))))))}}of.className="gelu_new",n9.registerClass(of);class om extends oe{apply(e){return(0,nz.tidy)(()=>$.mul(e,nO.tanh(n$.softplus(e))))}}om.className="mish",n9.registerClass(om);class og extends oe{apply(e,t=1){return(0,nz.tidy)(()=>$.mul(rt.sigmoid($.mul(e,t)),e))}}function oy(e){return e.getClassName()}function ob(e,t={}){return n1(e,n9.SerializationMap.getMap().classNameMap,t,"activation")}function ox(e){if(null==e){let e={};return e.className="linear",e.config={},ob(e)}if("string"==typeof e){let t={};return t.className=e,t.config={},ob(t)}return e instanceof oe?e:ob(e)}og.className="swish",n9.registerClass(og);var n9=n9;function ov(e){if(null!=e&&"object"!=typeof e)throw Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}class ow extends n9.Serializable{}class oS extends ow{constructor(e){super(),ov(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return(0,nz.tidy)(()=>{let t=(0,tC.zeros)([1]);return this.hasL1&&(t=(0,X.add)(t,(0,W.sum)($.mul(this.l1,(0,rk.abs)(e))))),this.hasL2&&(t=(0,X.add)(t,(0,W.sum)($.mul(this.l2,aZ(e))))),V.reshape(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}oS.className="L1L2",n9.registerClass(oS);let oN={l1l2:"L1L2"};function ok(e,t={}){return n1(e,n9.SerializationMap.getMap().classNameMap,t,"regularizer")}function oI(e){return null==e?null:"string"==typeof e?ok({className:e in oN?oN[e]:e,config:{}}):e instanceof ow?e:ok(e)}class oT extends sC{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=sf(e);let r=(0,nx.relu)(e);return null!=this.maxValue&&(r=(0,rV.clipByValue)(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue};return Object.assign(e,super.getConfig()),e}}oT.className="ReLU",n9.registerClass(oT);class oC extends sC{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let r=sf(e);return(0,r5.leakyRelu)(r,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha};return Object.assign(e,super.getConfig()),e}}oC.className="LeakyReLU",n9.registerClass(oC);class oE extends sC{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=sp(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=oI(e.alphaRegularizer),this.alphaConstraint=sU(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if("number"==typeof e.sharedAxes)this.sharedAxes=[e.sharedAxes];else throw new nW(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){let t=(e=sm(e)).slice(1);if(null!=this.sharedAxes)for(let e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let r={};if(null!=this.sharedAxes)for(let t=1;t<e.length;++t)r[t]=e[t];this.inputSpec=[new sS({ndim:e.length,axes:r})],this.built=!0}call(e,t){return e=sf(e),(0,ng.prelu)(e,this.alpha.read())}getConfig(){let e={alphaInitializer:n0(this.alphaInitializer),alphaRegularizer:n0(this.alphaRegularizer),alphaConstraint:n0(this.alphaConstraint),sharedAxes:this.sharedAxes};return Object.assign(e,super.getConfig()),e}}oE.className="PReLU",n9.registerClass(oE);class o$ extends sC{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new nU(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let r=sf(e);return(0,rX.elu)(r)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha};return Object.assign(e,super.getConfig()),e}}o$.className="ELU",n9.registerClass(o$);class oA extends sC{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){let r=sf(e);return(0,$.mul)(r,(0,E.cast)((0,tt.greater)(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta};return Object.assign(e,super.getConfig()),e}}oA.className="ThresholdedReLU",n9.registerClass(oA);class oR extends sC{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=new op().apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return(0,nz.tidy)(()=>{let r=sf(e),n=t.mask;if(null!=n){let e=(0,$.mul)((0,L.sub)((0,ty.ones)(r.shape),(0,E.cast)(n,r.dtype)),(0,O.scalar)(-1e9));r=(0,X.add)(r,e)}if(this.axis instanceof Array)if(this.axis.length>1)return(0,eq.exp)((0,L.sub)(r,(0,ne.logSumExp)(r,this.axis,!0)));else return this.softmax(r,this.axis[0]);return this.softmax(r,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis};return Object.assign(e,super.getConfig()),e}}oR.className="Softmax",n9.registerClass(oR);var oD=e.i(98378),aA=aA,oF=e.i(73271),n9=n9;function oO(e,t,r){if("number"==typeof e)return nH(e,t);if(e.length!==t)throw new nW(`The ${r} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let n=0;n<t;++n){let a=e[n];if(a!==parseInt(a.toString(),10))throw new nW(`The ${r} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function o_(e,t,r,n,a=1){return null==e?e:Math.floor((("same"===r?e:e-(t+(t-1)*(a-1))+1)+n-1)/n)}function oM(e,t,r,n){if(null==e)return null;if("valid"===n)e=e*t+a_([r-t,0]);else if("same"===n)e*=t;else throw new nW(`Unsupport padding mode: ${n}.`);return e}function oL(e,t){return(0,nz.tidy)(()=>(al(t),"channelsFirst"===t)?ez.transpose(e,[0,2,3,1]):e)}function oz(e,t){return(0,nz.tidy)(()=>(al(t),"channelsFirst"===t)?ez.transpose(e,[0,2,3,4,1]):e)}function oP(e,t,r,n=[1,1],a="valid",s,i,o=null){return(0,nz.tidy)(()=>{if(null==s&&(s=az()),al(s),3!==e.rank&&4!==e.rank)throw new nW(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new nW(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=oL(e,s);if("causal"===a)throw new nU("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=aA.conv2d({x:l,filter:t,strides:n,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:r,activation:o}),"channelsFirst"===s&&(l=ez.transpose(l,[0,3,1,2])),l})}class oB extends sC{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",oB.verifyArgs(t),this.rank=e,n5(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new nU(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=oO(t.kernelSize,e,"kernelSize"),this.strides=oO(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,au(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,al(this.dataFormat),this.activation=ox(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=sp(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=sU(t.biasConstraint),this.biasRegularizer=oI(t.biasRegularizer),this.activityRegularizer=oI(t.activityRegularizer),this.dilationRate=oO(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new nW(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new nW(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new nW(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(nj("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!n6(e.kernelSize,"number",1,3))throw new nW(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:oy(this.activation),useBias:this.useBias,biasInitializer:n0(this.biasInitializer),biasRegularizer:n0(this.biasRegularizer),activityRegularizer:n0(this.activityRegularizer),biasConstraint:n0(this.biasConstraint)};return Object.assign(e,super.getConfig()),e}}class oV extends oB{constructor(e,t){super(e,t),this.kernel=null,oV.verifyArgs(t),this.filters=t.filters,n5(this.filters,"filters"),this.kernelInitializer=sp(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=sU(t.kernelConstraint),this.kernelRegularizer=oI(t.kernelRegularizer)}build(e){e=sm(e);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new nW(`The channel dimension of the input should be defined. Found ${e[t]}`);let r=e[t],n=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",n,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:r}}],this.built=!0}call(e,t){return(0,nz.tidy)(()=>{let t;e=sf(e);let r=null==this.bias?null:this.bias.read(),n=n8(this.activation.getClassName());if(null!=n&&2===this.rank)t=oP(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,n);else{if(1===this.rank)t=function(e,t,r,n=1,a="valid",s,i=1){return(0,nz.tidy)(()=>{if(null==s&&(s=az()),al(s),3!==e.shape.length)throw new nW(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new nW(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=r&&1!==r.shape.length)throw new nW(`The bias for a conv1dWithBias operation should be 1, but is ${r.shape.length} instead`);if("channelsFirst"===s&&(e=ez.transpose(e,[0,2,1])),"causal"===a)throw new nU("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=rW.conv1d(e,t,n,"same"===a?"same":"valid","NWC",i);return null!=r&&(o=aJ(o,r)),o})}(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=oP(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(3===this.rank)t=function(e,t,r,n=[1,1,1],a="valid",s,i){return(0,nz.tidy)(()=>{if(null==s&&(s=az()),al(s),4!==e.rank&&5!==e.rank)throw new nW(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new nW(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=oz(e,s);if("causal"===a)throw new nU("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=oF.conv3d(o,t,n,"same"===a?"same":"valid","NDHWC",i),null!=r&&(o=aJ(o,r)),"channelsFirst"===s&&(o=ez.transpose(o,[0,4,1,2,3])),o})}(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new nU("convolutions greater than 3D are not implemented yet.");null!=this.activation&&(t=this.activation.apply(t))}return t})}computeOutputShape(e){e=sm(e);let t=[],r="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<r.length;++e){let n=o_(r[e],this.kernelSize[e],this.padding,this.strides[e],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[e]);t.push(n)}let n=[e[0]];return"channelsLast"===this.dataFormat?(n=n.concat(t)).push(this.filters):(n.push(this.filters),n=n.concat(t)),n}getConfig(){let e={filters:this.filters,kernelInitializer:n0(this.kernelInitializer),kernelRegularizer:n0(this.kernelRegularizer),kernelConstraint:n0(this.kernelConstraint)};return Object.assign(e,super.getConfig()),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new nW(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class oW extends oV{constructor(e){super(2,e),oW.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!n6(e.kernelSize,"number",1,2))throw new nW(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}oW.className="Conv2D",n9.registerClass(oW);class oU extends oV{constructor(e){super(3,e),oU.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!(Array.isArray(e.kernelSize)&&(1===e.kernelSize.length||3===e.kernelSize.length)))throw new nW(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}oU.className="Conv3D",n9.registerClass(oU);class oG extends oW{constructor(e){if(super(e),this.inputSpec=[new sS({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new nW(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=sm(e)).length)throw new nW("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new nW("The channel dimension of the inputs should be defined. Found `None`.");let r=e[t],n=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",n,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new sS({ndim:4,axes:{[t]:r}})],this.built=!0}call(e,t){return nz.tidy(()=>{let t,r,n=sf(e);if(4!==n.shape.length)throw new nW(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let a=n.shape,s=a[0];"channelsFirst"===this.dataFormat?(t=2,r=3):(t=1,r=2);let i=a[t],o=a[r],l=this.kernelSize[0],u=this.kernelSize[1],h=this.strides[0],p=this.strides[1],d=[s,oM(i,h,l,this.padding),oM(o,p,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(n=ez.transpose(n,[0,2,3,1]));let c=rU.conv2dTranspose(n,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(c=ez.transpose(c,[0,3,1,2])),null!=this.bias&&(c=aJ(c,this.bias.read(),this.dataFormat)),null!=this.activation&&(c=this.activation.apply(c)),c})}computeOutputShape(e){let t,r,n,a=(e=sm(e)).slice();"channelsFirst"===this.dataFormat?(t=1,r=2,n=3):(t=3,r=1,n=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return a[t]=this.filters,a[r]=oM(a[r],o,s,this.padding),a[n]=oM(a[n],l,i,this.padding),a}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}}oG.className="Conv2DTranspose",n9.registerClass(oG);class oq extends oU{constructor(e){if(super(e),this.inputSpec=[new sS({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new nW(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=sm(e)).length)throw new nW("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new nW("The channel dimension of the inputs should be defined. Found `None`.");let r=e[t],n=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",n,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new sS({ndim:5,axes:{[t]:r}})],this.built=!0}call(e,t){return nz.tidy(()=>{let t,r,n,a=sf(e);if(5!==a.shape.length)throw new nW(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${a.shape.length}`);let s=a.shape,i=s[0];"channelsFirst"===this.dataFormat?(n=2,t=3,r=4):(n=1,t=2,r=3);let o=s[n],l=s[t],u=s[r],h=this.kernelSize[0],p=this.kernelSize[1],d=this.kernelSize[2],c=this.strides[0],f=this.strides[1],m=this.strides[2],g=[i,oM(o,c,h,this.padding),oM(l,f,p,this.padding),oM(u,m,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(a=ez.transpose(a,[0,2,3,4,1]));let y=oD.conv3dTranspose(a,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=ez.transpose(y,[0,4,1,2,3])),null!==this.bias&&(y=aJ(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y})}computeOutputShape(e){let t,r,n,a,s=(e=sm(e)).slice();"channelsFirst"===this.dataFormat?(t=1,r=2,n=3,a=4):(t=4,r=1,n=2,a=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],h=this.strides[1],p=this.strides[2];return s[t]=this.filters,s[r]=oM(s[r],u,i,this.padding),s[n]=oM(s[n],h,o,this.padding),s[a]=oM(s[a],p,l,this.padding),s}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}}oq.className="Conv3DTranspose",n9.registerClass(oq);class oH extends oV{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new nW("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new nW("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new nW(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=sp(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=oI(t.depthwiseRegularizer),this.depthwiseConstraint=sU(t.depthwiseConstraint),this.pointwiseInitializer=sp(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=oI(t.pointwiseRegularizer),this.pointwiseConstraint=sU(t.pointwiseConstraint)}build(e){if((e=sm(e)).length<this.rank+2)throw new nW(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new nW(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let r=e[t],n=this.kernelSize.concat([r,this.depthMultiplier]),a=[];for(let e=0;e<this.rank;++e)a.push(1);a.push(r*this.depthMultiplier,this.filters),this.depthwiseKernel=this.addWeight("depthwise_kernel",n,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.inputSpec=[new sS({ndim:this.rank+2,axes:{[t]:r}})],this.built=!0}call(e,t){return(0,nz.tidy)(()=>{let t;if(e=sf(e),1===this.rank)throw new nU("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=ez.transpose(e,[0,2,3,1])),t=nT.separableConv2d(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=aJ(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=ez.transpose(t,[0,3,1,2])),t})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=n0(this.depthwiseInitializer),e.pointwiseInitializer=n0(this.pointwiseInitializer),e.depthwiseRegularizer=n0(this.depthwiseRegularizer),e.pointwiseRegularizer=n0(this.pointwiseRegularizer),e.depthwiseConstraint=n0(this.depthwiseConstraint),e.pointwiseConstraint=n0(this.pointwiseConstraint),e}}oH.className="SeparableConv";class oj extends oH{constructor(e){super(2,e)}}oj.className="SeparableConv2D",n9.registerClass(oj);class oK extends oV{constructor(e){super(1,e),oK.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!n6(e.kernelSize,"number",1,1))throw new nW(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}oK.className="Conv1D",n9.registerClass(oK);class oX extends sC{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return(0,nz.tidy)(()=>{if(e=sf(e),"channelsLast"===this.dataFormat){let t=aU(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return aU(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let t=aU(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return aU(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat};return Object.assign(e,super.getConfig()),e}}oX.className="Cropping2D",n9.registerClass(oX);class oZ extends sC{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,al(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,n4(an,"InterpolationFormat",this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){let t=null==e[2]?null:this.size[0]*e[2],r=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,r]}{let t=null==e[1]?null:this.size[0]*e[1],r=null==e[2]?null:this.size[1]*e[2];return[e[0],t,r,e[3]]}}call(e,t){return nz.tidy(()=>{let t=sf(e),r=t.shape;if("channelsFirst"===this.dataFormat){t=ez.transpose(t,[0,2,3,1]);let e=this.size[0]*r[2],n=this.size[1]*r[3],a="nearest"===this.interpolation?ab.image.resizeNearestNeighbor(t,[e,n]):ab.image.resizeBilinear(t,[e,n]);return ez.transpose(a,[0,3,1,2])}{let e=this.size[0]*r[1],n=this.size[1]*r[2];return"nearest"===this.interpolation?ab.image.resizeNearestNeighbor(t,[e,n]):ab.image.resizeBilinear(t,[e,n])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation};return Object.assign(e,super.getConfig()),e}}oZ.className="UpSampling2D",n9.registerClass(oZ);var n9=n9;class oY extends oB{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=sp(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=sU(e.depthwiseConstraint),this.depthwiseRegularizer=oI(e.depthwiseRegularizer)}build(e){if((e=sm(e)).length<4)throw new nW(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new nW(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let r=e[t],n=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",n,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,nz.tidy)(()=>{let t=function(e,t,r=[1,1],n="valid",a,s){return(0,nz.tidy)(()=>{null==a&&(a=az()),al(a);let s=oL(e,a);if(4!==e.rank)throw new nW(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new nW(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return s=rq.depthwiseConv2d(s,t,r,"same"===n?"same":"valid","NHWC",null),"channelsFirst"===a&&(s=ez.transpose(s,[0,3,1,2])),s})}(e=sf(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,0);return this.useBias&&(t=aJ(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t})}computeOutputShape(e){e=sm(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],r="channelsFirst"===this.dataFormat?e[3]:e[2],n="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=o_(t,this.kernelSize[0],this.padding,this.strides[0]),s=o_(r,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],n,a,s]:[e[0],a,s,n]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=n0(this.depthwiseInitializer),e.depthwiseRegularizer=n0(this.depthwiseRegularizer),e.depthwiseConstraint=n0(this.depthwiseRegularizer),e}}oY.className="DepthwiseConv2D",n9.registerClass(oY);var n9=n9,n9=n9;function oJ(e,t,r,n){if(Array.isArray(e)){if(null!=t||null!=r)throw new nW("When inputs is an array, neither initialState or constants should be provided");null!=n&&(r=e.slice(e.length-n,e.length),e=e.slice(0,e.length-n)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:r=a(r)}}function oQ(e,t,r,n=!1,a,s,i=!1,o=!1){return nz.tidy(()=>{let l,u,h,p=t.shape.length;if(p<3)throw new nW(`Input should be at least 3D, but is ${p}D.`);let d=[1,0].concat(aM(2,p));if(t=ez.transpose(t,d),null!=s)throw new nU("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&((a=E.cast(E.cast(a,"bool"),"float32")).rank===p-1&&(a=rb.expandDims(a,-1)),a=ez.transpose(a,d)),n&&(t=tj.reverse(t,0),null!=a&&(a=tj.reverse(a,0)));let c=[],f=r,m=t.shape[0],g=tA.unstack(t);null!=a&&(u=tA.unstack(a));for(let t=0;t<m;++t){let r=g[t],n=nz.tidy(()=>e(r,f));if(null==a)l=n[0],f=n[1];else{let e=nz.tidy(()=>{let e=u[t],r=L.sub(nf.onesLike(e),e);return{output:X.add($.mul(n[0],e),$.mul(f[0],r)),newStates:f.map((t,a)=>X.add($.mul(n[1][a],e),$.mul(t,r)))}});l=e.output,f=e.newStates}o&&c.push(l)}return o&&(h=e1.stack(c,1)),[l,h,f]})}class o0 extends sC{constructor(e){let t;if(super(e),null==e.cell)throw new nW("cell property is missing for the constructor of RNN.");if(null==(t=Array.isArray(e.cell)?new o9({cells:e.cell}):e.cell).stateSize)throw new nW("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new sS({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?aM(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(e=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){let t;sd(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);let n=r[0];if(t=this.returnSequences?[e[0],e[1],n]:[e[0],n],!this.returnState)return t;{let n=[];for(let t of r)n.push([e[0],t]);return[t].concat(n)}}computeMask(e,t){return nz.tidy(()=>{Array.isArray(t)&&(t=t[0]);let e=this.returnSequences?t:null;return this.returnState?[e].concat(this.states.map(e=>null)):e})}get states(){if(null!=this.states_)return this.states_;{let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let r=0;r<e;++r)t.push(null);return t}}set states(e){this.states_=e}build(e){let t;if(null!=this.numConstants)throw new nU("Constants support is not implemented in RNN yet.");sd(e)&&(e=e[0]);let r=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new sS({shape:[r,null,...n]});let a=[e[0]].concat(e.slice(2));if(this.cell.build(a),t=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!nP.util.arraysEqual(this.stateSpec.map(e=>e.shape[e.shape.length-1]),t))throw new nW(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=t.map(e=>new sS({shape:[null,e]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){(0,nz.tidy)(()=>{if(!this.stateful)throw new nB("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape[0];if(null==r)throw new nW("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>tC.zeros([r,e])):this.states_=[tC.zeros([r,this.cell.stateSize])];else if(null==e)nz.dispose(this.states_),null!=this.keptStates&&(nz.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>tC.zeros([r,e])):this.states_[0]=tC.zeros([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new nW(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):nz.dispose(this.states_);for(let t=0;t<this.states_.length;++t){let n=e[t],a=[r,Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize];if(!nP.util.arraysEqual(n.shape,a))throw new nW(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map(e=>nz.keep(e.clone()))})}apply(e,t){let r=null==t?null:t.initialState,n=null==t?null:t.constants;null==t&&(t={});let a=oJ(e,r,n,this.numConstants);e=a.inputs,r=a.initialState,n=a.constants;let s=[],i=[];if(null!=r){for(let e of(t.initialState=r,s=s.concat(r),this.stateSpec=[],r))this.stateSpec.push(new sS({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=n&&(t.constants=n,s=s.concat(n),this.numConstants=n.length),!(s[0]instanceof sN))return super.apply(e,t);{let r=[e].concat(s),n=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=n;let o=super.apply(r,t);return this.inputSpec=a,o}}call(e,t){return(0,nz.tidy)(()=>{let r=null==t?null:t.mask,n=null==t?null:t.training,a=null==t?null:t.initialState;e=sf(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));let s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new nW(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:n},o=oQ((e,t)=>{let r=this.cell.call([e].concat(t),i);return[r[0],r.slice(1)]},e,a,this.goBackwards,r,null,this.unroll,this.returnSequences),l=o[0],u=o[1],h=o[2];this.stateful&&this.resetStates(h,n);let p=this.returnSequences?u:l;return this.returnState?[p].concat(h):p})}getInitialState(e){return(0,nz.tidy)(()=>{let t=tC.zeros(e.shape);return(t=aB(t=W.sum(t,[1,2])),Array.isArray(this.cell.stateSize))?this.cell.stateSize.map(e=>e>1?aH(t,[1,e]):t):this.cell.stateSize>1?[aH(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===o0.className&&(t.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),t)}static fromConfig(e,t,r={}){let n=ic(t.cell,r);return new e(Object.assign(t,{cell:n}))}}o0.className="RNN",n9.registerClass(o0);class o1 extends sC{}class o2 extends o1{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,n5(this.units,"units"),this.activation=ox(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=sp(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sp(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sp(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=oI(e.kernelRegularizer),this.recurrentRegularizer=oI(e.recurrentRegularizer),this.biasRegularizer=oI(e.biasRegularizer),this.kernelConstraint=sU(e.kernelConstraint),this.recurrentConstraint=sU(e.recurrentConstraint),this.biasConstraint=sU(e.biasConstraint),this.dropout=aO([1,a_([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=aO([1,a_([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=sm(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,nz.tidy)(()=>{let r;if(2!==e.length)throw new nW(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let a=null!=t.training&&t.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=o7({ones:()=>nf.onesLike(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=o7({ones:()=>nf.onesLike(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask;r=null!=s?aK($.mul(e,s),this.kernel.read()):aK(e,this.kernel.read()),null!=this.bias&&(r=aJ(r,this.bias.read())),null!=i&&(n=$.mul(n,i));let o=X.add(r,aK(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:oy(this.activation),useBias:this.useBias,kernelInitializer:n0(this.kernelInitializer),recurrentInitializer:n0(this.recurrentInitializer),biasInitializer:n0(this.biasInitializer),kernelRegularizer:n0(this.kernelRegularizer),recurrentRegularizer:n0(this.recurrentRegularizer),biasRegularizer:n0(this.biasRegularizer),activityRegularizer:n0(this.activityRegularizer),kernelConstraint:n0(this.kernelConstraint),recurrentConstraint:n0(this.recurrentConstraint),biasConstraint:n0(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}o2.className="SimpleRNNCell",n9.registerClass(o2);class o3 extends o0{constructor(e){e.cell=new o2(e),super(e)}call(e,t){return(0,nz.tidy)(()=>{null!=this.cell.dropoutMask&&(nz.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(nz.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let r=null==t?null:t.mask,n=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:r,training:n,initialState:a})})}static fromConfig(e,t){return new e(t)}}o3.className="SimpleRNN",n9.registerClass(o3);class o4 extends o1{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new nW("GRUCell does not support reset_after parameter set to true.");this.units=e.units,n5(this.units,"units"),this.activation=ox(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ox(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=sp(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sp(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sp(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=oI(e.kernelRegularizer),this.recurrentRegularizer=oI(e.recurrentRegularizer),this.biasRegularizer=oI(e.biasRegularizer),this.kernelConstraint=sU(e.kernelConstraint),this.recurrentConstraint=sU(e.recurrentConstraint),this.biasConstraint=sU(e.biasConstraint),this.dropout=aO([1,a_([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=aO([1,a_([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){let t=(e=sm(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,nz.tidy)(()=>{let r,n,a;if(2!==e.length)throw new nW(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let s=null!=t.training&&t.training,i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=o7({ones:()=>nf.onesLike(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=o7({ones:()=>nf.onesLike(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=$.mul(e,o[0]));let u=aK(e,this.kernel.read());this.useBias&&(u=aJ(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=$.mul(i,l[0]));let h=this.recurrentKernel.read(),[p,d]=eS.split(h,[2*this.units,this.units],h.rank-1),c=aK(i,p),[f,m,g]=eS.split(u,3,u.rank-1),[y,b]=eS.split(c,2,c.rank-1);r=this.recurrentActivation.apply(X.add(f,y)),n=this.recurrentActivation.apply(X.add(m,b));let x=aK($.mul(n,i),d);a=this.activation.apply(X.add(g,x));let v=X.add($.mul(r,i),$.mul(X.add(1,F.neg(r)),a));return[v,v]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:oy(this.activation),recurrentActivation:oy(this.recurrentActivation),useBias:this.useBias,kernelInitializer:n0(this.kernelInitializer),recurrentInitializer:n0(this.recurrentInitializer),biasInitializer:n0(this.biasInitializer),kernelRegularizer:n0(this.kernelRegularizer),recurrentRegularizer:n0(this.recurrentRegularizer),biasRegularizer:n0(this.biasRegularizer),activityRegularizer:n0(this.activityRegularizer),kernelConstraint:n0(this.kernelConstraint),recurrentConstraint:n0(this.recurrentConstraint),biasConstraint:n0(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}o4.className="GRUCell",n9.registerClass(o4);class o6 extends o0{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new o4(e),super(e)}call(e,t){return(0,nz.tidy)(()=>{null!=this.cell.dropoutMask&&(nz.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(nz.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let r=null==t?null:t.mask,n=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:r,training:n,initialState:a})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}o6.className="GRU",n9.registerClass(o6);class o5 extends o1{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,n5(this.units,"units"),this.activation=ox(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ox(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=sp(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sp(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sp(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=oI(e.kernelRegularizer),this.recurrentRegularizer=oI(e.recurrentRegularizer),this.biasRegularizer=oI(e.biasRegularizer),this.kernelConstraint=sU(e.kernelConstraint),this.recurrentConstraint=sU(e.recurrentConstraint),this.biasConstraint=sU(e.biasConstraint),this.dropout=aO([1,a_([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=aO([1,a_([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;let r,n=(e=sm(e))[e.length-1];if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let e=this.biasInitializer,n=this.units;r=new((t=class extends a3{apply(t,r){let a=e.apply([n]),s=new a6().apply([n]),i=e.apply([2*n]);return aq(aq(a,s),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return(0,nz.tidy)(()=>{let r,n,a,s,i=null!=t.training&&t.training;if(3!==e.length)throw new nW(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1],l=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=o7({ones:()=>nf.onesLike(e),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=o7({ones:()=>nf.onesLike(o),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));let u=this.dropoutMask,h=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=$.mul(e,u[0]));let p=aK(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=$.mul(o,h[0])),p=X.add(p,aK(o,this.recurrentKernel.read())),this.useBias&&(p=aJ(p,this.bias.read()));let[d,c,f,m]=eS.split(p,4,p.rank-1);r=this.recurrentActivation.apply(d),n=this.recurrentActivation.apply(c),a=X.add($.mul(n,l),$.mul(r,this.activation.apply(f))),s=this.recurrentActivation.apply(m);let g=$.mul(s,this.activation.apply(a));return[g,g,a]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:oy(this.activation),recurrentActivation:oy(this.recurrentActivation),useBias:this.useBias,kernelInitializer:n0(this.kernelInitializer),recurrentInitializer:n0(this.recurrentInitializer),biasInitializer:n0(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:n0(this.kernelRegularizer),recurrentRegularizer:n0(this.recurrentRegularizer),biasRegularizer:n0(this.biasRegularizer),activityRegularizer:n0(this.activityRegularizer),kernelConstraint:n0(this.kernelConstraint),recurrentConstraint:n0(this.recurrentConstraint),biasConstraint:n0(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}o5.className="LSTMCell",n9.registerClass(o5);class o8 extends o0{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new o5(e),super(e)}call(e,t){return(0,nz.tidy)(()=>{null!=this.cell.dropoutMask&&(nz.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(nz.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let r=null==t?null:t.mask,n=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:r,training:n,initialState:a})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}o8.className="LSTM",n9.registerClass(o8);class o9 extends o1{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return(0,nz.tidy)(()=>{let r,n=e.slice(1),a=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?a.push(n.splice(0,e.stateSize.length)):a.push(n.splice(0,1));a.reverse();let s=[];for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=a[i],r=0===i?[e[0]].concat(n):[r[0]].concat(n),r=o.call(r,t),s.push(r.slice(1))}for(let e of(n=[],s.slice().reverse()))n.push(...e);return[r[0]].concat(n)})}build(e){let t;sd(e)&&(e=e[0]),this.cells.forEach((r,n)=>{ad(`RNNCell_${n}`,()=>{r.build(e),t=Array.isArray(r.stateSize)?r.stateSize[0]:r.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=this.cells.map(e=>({className:e.getClassName(),config:e.getConfig()}));return Object.assign(Object.assign({},e),{cells:t})}static fromConfig(e,t,r={}){let n=[];for(let e of t.cells)n.push(ic(e,r));return new e({cells:n})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return sv(e)}setWeights(e){let t=[];for(let r of this.cells){let n=r.weights.length,a=e.splice(n);for(let e=0;e<r.weights.length;++e)t.push([r.weights[e],a[e]])}sw(t)}}function o7(e){let{ones:t,rate:r,training:n=!1,count:a=1,dropoutFunc:s}=e,i=()=>null!=s?s(t(),r):aQ(t(),r),o=()=>a0(i,t,n);return!a||a<=1?nz.keep(o().clone()):Array(a).fill(void 0).map(o).map(e=>nz.keep(e.clone()))}o9.className="StackedRNNCells",n9.registerClass(o9);var le=function(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&0>t.indexOf(n)&&(r[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols)for(var a=0,n=Object.getOwnPropertySymbols(e);a<n.length;a++)0>t.indexOf(n[a])&&Object.prototype.propertyIsEnumerable.call(e,n[a])&&(r[n[a]]=e[n[a]]);return r};class lt extends o0{constructor(e){if(e.unroll)throw new nU("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new nU("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new sS({ndim:5})]}call(e,t){return nz.tidy(()=>{if(null!=this.cell.dropoutMask&&(nz.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(nz.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new nW("ConvRNN2D cell does not support constants");let r=null==t?null:t.mask,n=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:r,training:n,initialState:a})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...[,,].fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return nz.tidy(()=>{let{stateSize:t}=this.cell,r=e.shape,n=this.computeSingleOutputShape(r),a=[n[0],...n.slice(2)],s=tC.zeros(a);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){nz.tidy(()=>{if(!this.stateful)throw new nB("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape,n=this.computeSingleOutputShape(r),a=[n[0],...n.slice(2)];if(null==r[0])throw new nW("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>tC.zeros(a)):this.states_=[tC.zeros(a)];else if(null==e)nz.dispose(this.states_),null!=this.keptStates&&(nz.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>tC.zeros(a)):this.states_[0]=tC.zeros(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new nW(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):nz.dispose(this.states_);for(let t=0;t<this.states_.length;++t){let r=e[t];if(!nP.util.arraysEqual(r.shape,a))throw new nW(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map(e=>nz.keep(e.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:r,kernelSize:n,padding:a,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],h=o_(l,n[0],a,s[0],i[0]),p=o_(u,n[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[r,h,p]:[h,p,r]]}}lt.className="ConvRNN2D";class lr extends o5{constructor(e){const{filters:t,kernelSize:r,strides:n,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,n5(this.filters,"filters"),this.kernelSize=oO(r,2,"kernelSize"),this.kernelSize.forEach(e=>n5(e,"kernelSize")),this.strides=oO(n||1,2,"strides"),this.strides.forEach(e=>n5(e,"strides")),this.padding=a||"valid",au(this.padding),this.dataFormat=s||"channelsLast",al(this.dataFormat),this.dilationRate=oO(i||1,2,"dilationRate"),this.dilationRate.forEach(e=>n5(e,"dilationRate"))}build(e){var t;e=sm(e);let r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new nW(`The channel dimension of the input should be defined. Found ${e[r]}`);let n=e[r],a=this.kernelSize.concat([n,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){let r=this.biasInitializer,n=this.filters;e=new((t=class extends a3{apply(e,t){return aG([r.apply([n]),ty.ones([n]),r.apply([2*n])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return nz.tidy(()=>{if(3!==e.length)throw new nW(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=t.training||!1,n=e[0],a=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=o7({ones:()=>nf.onesLike(n),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,o=(e,t,r)=>t&&t[r]?$.mul(t[r],e):e,l=o(n,i,0),u=o(n,i,1),h=o(n,i,2),p=o(n,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=o7({ones:()=>nf.onesLike(a),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));let d=this.recurrentDropoutMask,c=o(a,d,0),f=o(a,d,1),m=o(a,d,2),g=o(a,d,3),[y,b,x,v]=eS.split(this.kernel.read(),4,3),[w,S,N,k]=this.useBias?eS.split(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,S,this.padding),h=this.inputConv(h,x,N,this.padding),p=this.inputConv(p,v,k,this.padding);let[I,T,C,E]=eS.split(this.recurrentKernel.read(),4,3);c=this.recurrentConv(c,I),f=this.recurrentConv(f,T),m=this.recurrentConv(m,C),g=this.recurrentConv(g,E);let A=this.recurrentActivation.apply(X.add(l,c)),R=this.recurrentActivation.apply(X.add(u,f)),D=X.add($.mul(R,s),$.mul(A,this.activation.apply(X.add(h,m)))),F=$.mul(this.recurrentActivation.apply(X.add(p,g)),this.activation.apply(D));return[F,F,D]})}getConfig(){let e=super.getConfig(),{units:t}=e,r=le(e,["units"]),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},r),n)}inputConv(e,t,r,n){let a=eC.conv2d(e,t,this.strides,n||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return r?aJ(a,r,this.dataFormat):a}recurrentConv(e,t){return eC.conv2d(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}lr.className="ConvLSTM2DCell",n9.registerClass(lr);class ln extends lt{constructor(e){super(Object.assign(Object.assign({},e),{cell:new lr(e)}))}static fromConfig(e,t){return new e(t)}}ln.className="ConvLSTM2D",n9.registerClass(ln);var n9=n9;class la extends sC{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;let t=e.shape,r=[];for(let e=0;e<this.noiseShape.length;++e)r.push(null==this.noiseShape[e]?t[e]:this.noiseShape[e]);return r}call(e,t){return(0,nz.tidy)(()=>{this.invokeCallHook(e,t);let r=sf(e);if(0<this.rate&&this.rate<1){let e=null!=t.training&&t.training,n=this.getNoiseShape(r);return a0(()=>aQ(r,this.rate,n,this.seed),()=>r,e)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed};return Object.assign(e,super.getConfig()),e}dispose(){return super.dispose()}}la.className="Dropout",n9.registerClass(la);class ls extends la{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}}ls.className="SpatialDropout1D",n9.registerClass(ls);class li extends sC{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,n5(this.units,"units"),this.activation=ox(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=sp(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=sp(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=sU(e.kernelConstraint),this.biasConstraint=sU(e.biasConstraint),this.kernelRegularizer=oI(e.kernelRegularizer),this.biasRegularizer=oI(e.biasRegularizer),this.activityRegularizer=oI(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){let t=(e=sm(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){let t=(e=sm(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return(0,nz.tidy)(()=>{let r;this.invokeCallHook(e,t);let n=sf(e),a=n8(this.activation.getClassName());return null!=a?r=aK(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=aK(n,this.kernel.read()),null!=this.bias&&(r=aJ(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r})}getConfig(){let e={units:this.units,activation:oy(this.activation),useBias:this.useBias,kernelInitializer:n0(this.kernelInitializer),biasInitializer:n0(this.biasInitializer),kernelRegularizer:n0(this.kernelRegularizer),biasRegularizer:n0(this.biasRegularizer),activityRegularizer:n0(this.activityRegularizer),kernelConstraint:n0(this.kernelConstraint),biasConstraint:n0(this.biasConstraint)};return Object.assign(e,super.getConfig()),e}}li.className="Dense",n9.registerClass(li);class lo extends sC{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){for(let t of(e=sm(e)).slice(1))if(null==t)throw new nW(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],aF(e,1)]}call(e,t){return(0,nz.tidy)(()=>{this.invokeCallHook(e,t);let r=sf(e);if("channelsFirst"===this.dataFormat&&r.rank>1){let e=[0];for(let t=2;t<r.rank;++t)e.push(t);e.push(1),r=(0,ez.transpose)(r,e)}var n=r;if(n.rank<=1)throw new nW(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);let a=[n.shape[0],aF(n.shape,1)];return V.reshape(n,a)})}getConfig(){let e={};return null!=this.dataFormat&&(e.dataFormat=this.dataFormat),Object.assign(e,super.getConfig()),e}}lo.className="Flatten",n9.registerClass(lo);class ll extends sC{constructor(e){super(e),this.supportsMasking=!0,this.activation=ox(e.activation)}call(e,t){return(0,nz.tidy)(()=>{this.invokeCallHook(e,t);let r=sf(e);return this.activation.apply(r)})}getConfig(){let e={activation:oy(this.activation)};return Object.assign(e,super.getConfig()),e}}ll.className="Activation",n9.registerClass(ll);class lu extends sC{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return(0,nz.tidy)(()=>{var t,r;return t=e=sf(e),r=this.n,(0,nz.tidy)(()=>{if(2!==t.shape.length)throw new nW(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return aH(aB(t,1),[1,r,1])})})}getConfig(){let e={n:this.n};return Object.assign(e,super.getConfig()),e}}lu.className="RepeatVector",n9.registerClass(lu);class lh extends sC{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){let r="Total size of new array must be unchanged.",n=t.slice(),a=1,s=null;for(let e=0;e<n.length;++e){let t=n[e];if(this.isUnknown(t))if(null===s)s=e;else throw new nW("Can only specifiy one unknown dimension.");else a*=t}let i=aF(e);if(null!==s){if(0===a||i%a!=0)throw new nW(r);n[s]=i/a}else if(i!==a)throw new nW(r);return n}computeOutputShape(e){let t=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return(0,nz.tidy)(()=>{this.invokeCallHook(e,t);let r=sf(e),n=r.shape,a=n.slice(0,1).concat(this.fixUnknownDimension(n.slice(1),this.targetShape));return(0,V.reshape)(r,a)})}getConfig(){let e={targetShape:this.targetShape};return Object.assign(e,super.getConfig()),e}}lh.className="Reshape",n9.registerClass(lh);class lp extends sC{constructor(e){if(super(e),null==e.dims)throw Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=aM(1,e.dims.length+1);if(!nP.util.arraysEqual(e.dims.slice().sort(),t))throw Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new sS({ndim:this.dims.length+1})]}computeOutputShape(e){let t=(e=sm(e)).slice();return this.dims.forEach((r,n)=>{t[n+1]=e[r]}),t}call(e,t){return(0,ez.transpose)(sf(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims};return Object.assign(e,super.getConfig()),e}}lp.className="Permute",n9.registerClass(lp);class ld extends sC{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e?this.maskValue=null==e.maskValue?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let r=sf(e);return(0,r$.any)((0,nd.notEqual)(r,this.maskValue),-1)}call(e,t){return(0,nz.tidy)(()=>{this.invokeCallHook(e,t);let r=sf(e),n=(0,r$.any)((0,nd.notEqual)(r,this.maskValue),-1,!0);return(0,$.mul)(r,(0,E.cast)(n,r.dtype))})}}ld.className="Masking",n9.registerClass(ld);var n9=n9;class lc extends sC{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(nZ(e.inputLength))}this.inputDim=e.inputDim,n5(this.inputDim,"inputDim"),this.outputDim=e.outputDim,n5(this.outputDim,"outputDim"),this.embeddingsInitializer=sp(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=oI(e.embeddingsRegularizer),this.activityRegularizer=oI(e.activityRegularizer),this.embeddingsConstraint=sU(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return(0,nz.tidy)(()=>this.maskZero?(e=sf(e),(0,nd.notEqual)(e,(0,q.zerosLike)(e))):null)}computeOutputShape(e){if(e=sm(e),null==this.inputLength)return[...e,this.outputDim];let t=nZ(this.inputLength);if(t.length!==e.length-1)throw new nW(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let n=0;n<t.length;++n){let a=t[n],s=e[n+1];if(null!=a&&null!=s&&a!==s)throw new nW(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[r]=s),r++}}return[e[0],...t,this.outputDim]}call(e,t){return(0,nz.tidy)(()=>{this.invokeCallHook(e,t);let r=sf(e);"int32"!==r.dtype&&(r=aP(r,"int32"));let n=aX(this.embeddings.read(),(0,V.reshape)(r,[r.size]));return(0,V.reshape)(n,sm(this.computeOutputShape(r.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:n0(this.embeddingsInitializer),embeddingsRegularizer:n0(this.embeddingsRegularizer),activityRegularizer:n0(this.activityRegularizer),embeddingsConstraint:n0(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength};return Object.assign(e,super.getConfig()),e}}lc.className="Embedding",n9.registerClass(lc);var n9=n9;class lf extends sC{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new nU}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;let r=e.slice(0,e.length-t.length);for(let n=0;n<t.length;++n){let a=e[e.length-t.length+n],s=t[n];if(null==a||null==s||a<0||s<0)r.push(null);else if(1===a)r.push(s);else if(1===s)r.push(a);else{if(a!==s)throw new nW("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));r.push(a)}}return r}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[sm(e)]),e.length<2)throw new nW(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let r of e)null!=r&&null!==r[0]&&t.push(r[0]);if((t=n3(t)).length>1)throw new nW(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let r=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){let n=null==e[t]?null:e[t].slice(1);r=this.computeElementwiseOpOutputShape(r,n)}let n=e.map(e=>e.length);-1===e.indexOf(null)&&1===n3(n).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return(0,nz.tidy)(()=>{if(!this.reshapeRequired)return this.mergeFunction(e);{let t=[],r=e.map(e=>e.rank);if(-1===r.indexOf(null)){let n=a_(r);for(let r of e){let e=r.rank;for(let t=0;t<n-e;++t)r=aB(r,1);t.push(r)}return this.mergeFunction(t)}{let r=!1;for(let n of e){let e=n.rank;if(null==e){let e=n.shape,a=e[0],s=e.slice(1).concat([a]),i=V.reshape(n,[a].concat(aF(e.slice(1))));i=ez.transpose(i,[1,0]),i=V.reshape(i,s),t.push(i),r=!0}else if(e>1){let a=aM(1,e).concat([0]);t.push(ez.transpose(n,a)),r=!0}else t.push(n)}let n=this.mergeFunction(t),a=n.rank;if(r){if(null==a){let e=n.shape,t=e.length,r=e[t-1],a=[r].concat(e.slice(0,e.length-1));n=V.reshape(ez.transpose(V.reshape(n,[-1,r]),[1,0]),a)}else if(a>1){let e=[a-1].concat(aM(0,a-1));n=ez.transpose(n,e)}}return n}}})}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){let n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let r=[];for(let t of e)null!=t&&null!==t[0]&&r.push(t[0]);return 1===(r=n3(r)).length?r.concat(t):[null].concat(t)}computeMask(e,t){return nz.tidy(()=>{if(null==t)return null;if(!Array.isArray(t))throw new nW("`mask` should be an Array");if(!Array.isArray(e))throw new nW("`inputs` should be an Array");if(t.length!==e.length)throw new nW(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(e=>null==e))return null;let r=(t=t.map(e=>null==e?e:rb.expandDims(e,0)))[0];for(let e=1;e<t.length-1;++e)r=eb.logicalAnd(r,t[e]);return r})}}class lm extends lf{constructor(e){super(e)}mergeFunction(e){return(0,nz.tidy)(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=X.add(t,e[r]);return t})}}lm.className="Add",n9.registerClass(lm);class lg extends lf{constructor(e){super(e)}mergeFunction(e){return(0,nz.tidy)(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=$.mul(t,e[r]);return t})}}lg.className="Multiply",n9.registerClass(lg);class ly extends lf{constructor(e){super(e)}mergeFunction(e){return(0,nz.tidy)(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=X.add(t,e[r]);return $.mul(1/e.length,t)})}}ly.className="Average",n9.registerClass(ly);class lb extends lf{constructor(e){super(e)}mergeFunction(e){return(0,nz.tidy)(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=rv.maximum(t,e[r]);return t})}}lb.className="Maximum",n9.registerClass(lb);class lx extends lf{constructor(e){super(e)}mergeFunction(e){return(0,nz.tidy)(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=nl.minimum(t,e[r]);return t})}}lx.className="Minimum",n9.registerClass(lx);class lv extends lf{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||1===e.length)throw new nW("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(let r of e)if(null!=r){t=!1;break}if(t)return;let r=[];for(let t=0;t<e.length;++t){let n=e[t].slice();n.splice(this.axis,1);let a=!1;for(let e of r)if(nP.util.arraysEqual(e,n)){a=!0;break}a||r.push(n)}if(r.length>1)throw new nW("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return(0,nz.tidy)(()=>aG(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new nW("A `Concatenate` layer should be called on a list of inputs.");let t=e[0].slice(),r=this.axis<0?t.length+this.axis:this.axis;for(let n of e.slice(1)){if(null==t[r]||null==n[r]){t[r]=null;break}t[r]+=n[r]}return t}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new nW("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new nW("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new nW(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return nz.tidy(()=>{let r=!0;if(t.forEach(e=>{if(null!=e){r=!1;return}}),r)return null;let n=[];for(let r=0;r<e.length;++r)null==t[r]?n.push(E.cast(nf.onesLike(e[r]),"bool")):t[r].rank<e[r].rank?n.push(rb.expandDims(t[r],-1)):n.push(t[r]);let a=rs.concat(n,this.axis);return rE.all(a,-1,!1)})}getConfig(){let e={axis:this.axis};return Object.assign(e,super.getConfig()),e}}function lw(e,t){for(;e<0;)e+=t;return e}lv.className="Concatenate",n9.registerClass(lv);class lS extends lf{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){nP.util.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],r=e[1];if(t.length>3||r.length>3)throw new nU("Dot layer does not support tensors of 4D or higher rank yet.");let n=this.interpretAxes(t,r);if(t[n[0]]!==r[n[1]])throw new nW(`Dimension incompatibility: ${t[n[0]]} !== ${r[n[1]]}`)}mergeFunction(e){let t;if(2!==e.length)throw new nW(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let r=e[0],n=e[1];t=Array.isArray(this.axes)?this.axes.map((t,r)=>lw(t,e[r].shape.length)):[lw(this.axes,r.shape.length),lw(this.axes,n.shape.length)],this.normalize&&(r=ig(r,t[0]),n=ig(n,t[1]));var a=r,s=n,i=t;if(a.shape.length>3||s.shape.length>3)throw new nU("batchDot is not implemented for tensors of 4D or higher rank yet");if(nP.util.assert(a.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${a.shape.length}`),nP.util.assert(a.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${s.shape.length}`),"number"==typeof i&&(i=[i,i]),"complex64"===a.dtype||"complex64"===s.dtype)throw new nU("batchDot is not implemented for complex64-type Tensors yet.");let o=a.shape.length,l=s.shape.length;null==i&&(i=[o-1,l-2]);let u=i;return nz.tidy(()=>{let e,t;if(o>l){e=o-l;let t=[];for(let r=0;r<e;++r)t.push(1);s=V.reshape(s,s.shape.concat(t))}else if(l>o){e=l-o;let t=[];for(let r=0;r<e;++r)t.push(1);a=V.reshape(a,a.shape.concat(t))}else e=0;if(2===a.shape.length&&2===s.shape.length)t=u[0]===u[1]?W.sum($.mul(a,s),u[0]):W.sum($.mul(ez.transpose(a,[1,0]),s),u[1]);else{let e=u[0]!==a.shape.length-1,r=u[1]===s.shape.length-1;t=eu.matMul(a,s,e,r)}if(e>0){let r;r=o>l?o+l-3:o-1;let n=[];for(let t=r;t<r+e;++t)n.push(t);t=nR.squeeze(t,n)}return 1===t.shape.length&&(t=rb.expandDims(t,1)),t})}interpretAxes(e,t){return Array.isArray(this.axes)?this.axes:[lw(this.axes,e.length),lw(this.axes,t.length)]}computeOutputShape(e){nP.util.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),r=e[1].slice();if(t.length>3||r.length>3)throw new nU("Dot layer does not support tensors of 4D or higher rank yet.");let n=this.interpretAxes(t,r);t.splice(n[0],1),r.splice(n[1],1),r.splice(0,1);let a=t.concat(r);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize};return Object.assign(e,super.getConfig()),e}}lS.className="Dot",n9.registerClass(lS);var n9=n9;class lN extends sC{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return(0,nz.tidy)(()=>{this.invokeCallHook(e,t);let r=sf(e);return a0(()=>(0,X.add)(aj(r.shape,0,this.stddev),r),()=>r,t.training||!1)})}}lN.className="GaussianNoise",n9.registerClass(lN);class lk extends sC{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return(0,nz.tidy)(()=>{this.invokeCallHook(e,t);let r=sf(e);return this.rate>0&&this.rate<1?a0(()=>{let e=Math.sqrt(this.rate/(1-this.rate));return(0,$.mul)(r,aj(r.shape,1,e))},()=>r,t.training||!1):r})}}lk.className="GaussianDropout",n9.registerClass(lk);class lI extends sC{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||sf(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return(0,nz.tidy)(()=>{if(this.rate<1&&this.rate>0){let r=this._getNoiseShape(e);return a0(()=>{let t=sf(e),n=(0,eg.greaterEqual)((0,ax.randomUniform)(r),this.rate);n=aP(n,"float32");let a=((1-this.rate)*(1+3.09091329228798*this.rate))**-.5,s=-(-1.7580993408473766*a)*this.rate,i=(0,X.add)((0,$.mul)(t,n),(0,$.mul)((0,X.add)(n,-1),-1.7580993408473766));return(0,X.add)((0,$.mul)(i,a),s)},()=>sf(e),t.training||!1)}return e})}}lI.className="AlphaDropout",n9.registerClass(lI);var lT=e.i(34414),lC=e.i(12785),lE=e.i(90632),l$=e.i(12965),n9=n9;function lA(e,t,r,n,a,s=.001){let i;if(2===e.rank)i=lE.batchNorm2d(e,t,r,n,a,s);else if(3===e.rank)i=lC.batchNorm3d(e,t,r,n,a,s);else if(4===e.rank)i=lT.batchNorm4d(e,t,r,n,a,s);else throw new nU(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}class lR extends sC{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=sp(e.betaInitializer||"zeros"),this.gammaInitializer=sp(e.gammaInitializer||"ones"),this.movingMeanInitializer=sp(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=sp(e.movingVarianceInitializer||"ones"),this.betaConstraint=sU(e.betaConstraint),this.gammaConstraint=sU(e.gammaConstraint),this.betaRegularizer=oI(e.betaRegularizer),this.gammaRegularizer=oI(e.gammaRegularizer)}build(e){e=sm(e);let t=this.axis>=0?this.axis:this.axis+e.length,r=e[t];if(null==r)throw new nW(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new sS({ndim:e.length,axes:{[t]:r}})];let n=[r];this.scale&&(this.gamma=this.addWeight("gamma",n,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",n,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",n,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",n,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return(0,nz.tidy)(()=>{let r=null!=t.training&&t.training,n=sf(e),a=n.shape,s=a.length,i=aM(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=nH(1,s);l[o]=a[o];let u=i.slice();u.sort();let h=!nP.util.arraysEqual(u,aM(0,s).slice(0,s-1)),p=()=>h?lA(n,(0,V.reshape)(this.movingMean.read(),l),(0,V.reshape)(this.movingVariance.read(),l),this.center?(0,V.reshape)(this.beta.read(),l):null,this.scale?(0,V.reshape)(this.gamma.read(),l):null,this.epsilon):lA(n,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon);if(!r)return p();let[d,c,f]=function(e,t,r,n,a=.001){return nP.util.arraysEqual(n.slice().sort(),aM(0,e.rank-1))?function(e,t,r,n,a=.001){return(0,nz.tidy)(()=>{let s=l$.moments(e,n),i=s.mean,o=s.variance;return[lA(e,i,o,r,t,a),i,o]})}(e,t,r,n,a):function(e,t,r,n,a=.001){return(0,nz.tidy)(()=>{let s=l$.moments(e,n),i=s.mean,o=s.variance,l=[];for(let t of aM(0,e.rank))-1!==n.indexOf(t)?l.push(1):l.push(e.shape[t]);let u=(0,V.reshape)(i,l),h=(0,V.reshape)(o,l),p=null==t?null:(0,V.reshape)(t,l);return[lA(e,u,h,null==r?null:(0,V.reshape)(r,l),p,a),i,o]})}(e,t,r,n,a)}(n,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(e,t,r)=>{nz.tidy(()=>{let n=e.read(),a=$.mul(L.sub(n,t),1-r);e.write(L.sub(n,a))})};return m(this.movingMean,c,this.momentum),m(this.movingVariance,f,this.momentum),d})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:n0(this.betaInitializer),gammaInitializer:n0(this.gammaInitializer),movingMeanInitializer:n0(this.movingMeanInitializer),movingVarianceInitializer:n0(this.movingVarianceInitializer),betaRegularizer:n0(this.betaRegularizer),gammaRegularizer:n0(this.gammaRegularizer),betaConstraint:n0(this.betaConstraint),gammaConstraint:n0(this.gammaConstraint)};return Object.assign(e,super.getConfig()),e}}lR.className="BatchNormalization",n9.registerClass(lR);class lD extends sC{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const e of this.axis)if(!Number.isInteger(e))throw Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=sp(e.betaInitializer||"zeros"),this.gammaInitializer=sp(e.gammaInitializer||"ones"),this.betaRegularizer=oI(e.betaRegularizer),this.gammaRegularizer=oI(e.gammaRegularizer),this.supportsMasking=!0}build(e){let t=(e=sm(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(let e of this.axis)if(e<0||e>=t)throw Error(`Invalid axis: ${e}`);if(this.axis.length!==n3(this.axis).length)throw Error(`Found duplicate axes in: ${this.axis}`);let r=this.axis.map(t=>e[t]);this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(e,t){let r=sf(e),n=r.shape,a=n.length;return(0,nz.tidy)(()=>{let{mean:e,variance:t}=(0,l$.moments)(r,this.axis,!0),s=nH(1,a);for(let e of this.axis)s[e]=n[e];let i=e=>null!=e&&e.shape.length!==a?V.reshape(e,s):e,o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null,u=[],h=[];for(let e=0;e<a;++e)-1!==this.axis.indexOf(e)?(u.push(n[e]),h.push(1)):(u.push(1),h.push(n[e]));return e=eQ.tile(e,u),t=eQ.tile(t,u),null!=o&&(o=eQ.tile(o,h)),null!=l&&(l=eQ.tile(l,h)),lA(r,e,t,l,o,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:n0(this.betaInitializer),gammaInitializer:n0(this.gammaInitializer),betaRegularizer:n0(this.betaRegularizer),gammaRegularizer:n0(this.gammaRegularizer)};return Object.assign(e,super.getConfig()),e}}lD.className="LayerNormalization",n9.registerClass(lD);var n9=n9;class lF extends sC{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?az():e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{let t,r;if(e.padding=e.padding,2!==e.padding.length)throw new nW(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new nW(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new nW(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[t,r]}this.inputSpec=[new sS({ndim:4})]}computeOutputShape(e){let t,r;return(e=sm(e),"channelsFirst"===this.dataFormat)?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,r=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,r]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,r=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,r,e[3]])}call(e,t){return(0,nz.tidy)(()=>{var t,r,n;return t=sf(e),r=this.padding,n=this.dataFormat,(0,nz.tidy)(()=>{let e;if(4!==t.rank)throw new nW(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==r&&(r=[[1,1],[1,1]]),2!==r.length||2!==r[0].length||2!==r[1].length)throw new nW("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n=az()),"channelsLast"!==n&&"channelsFirst"!==n)throw new nW(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);return e="channelsFirst"===n?[[0,0],[0,0],r[0],r[1]]:[[0,0],r[0],r[1],[0,0]],t8.pad(t,e)})})}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat};return Object.assign(e,super.getConfig()),e}}lF.className="ZeroPadding2D",n9.registerClass(lF);var lO=e.i(90881),l_=e.i(64733),n9=n9;function lM(e,t,r,n,a,s){return(0,nz.tidy)(()=>{let i;al(a),ah(s),au(n),null==r&&(r=[1,1]),null==n&&(n="valid"),null==a&&(a=az()),null==s&&(s="max"),e=oL(e,a);let o="same"===n?"same":"valid";return i="max"===s?na.maxPool(e,t,r,o):rL.avgPool(e,t,r,o),"channelsFirst"===a&&(i=ez.transpose(i,[0,3,1,2])),i})}function lL(e,t,r,n,a,s){return(0,nz.tidy)(()=>{let i;al(a),ah(s),au(n),null==r&&(r=[1,1,1]),null==n&&(n="valid"),null==a&&(a=az()),null==s&&(s="max"),e=oz(e,a);let o="same"===n?"same":"valid";return i="max"===s?l_.maxPool3d(e,t,r,o):lO.avgPool3d(e,t,r,o),"channelsFirst"===a&&(i=ez.transpose(i,[0,4,1,2,3])),i})}class lz extends sC{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&1===e.poolSize.length&&"number"==typeof e.poolSize[0])this.poolSize=e.poolSize;else throw new nW(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(n5(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else if(Array.isArray(e.strides)&&1===e.strides.length&&"number"==typeof e.strides[0])this.strides=e.strides;else throw new nW(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);n5(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,au(this.padding),this.inputSpec=[new sS({ndim:3})]}computeOutputShape(e){let t=o_((e=sm(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return(0,nz.tidy)(()=>{this.invokeCallHook(e,t),e=aB(sf(e),2);let r=this.poolingFunction(sf(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return nR.squeeze(r,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides};return Object.assign(e,super.getConfig()),e}}class lP extends lz{constructor(e){super(e)}poolingFunction(e,t,r,n,a){return al(a),au(n),lM(e,t,r,n,a,"max")}}lP.className="MaxPooling1D",n9.registerClass(lP);class lB extends lz{constructor(e){super(e)}poolingFunction(e,t,r,n,a){return al(a),au(n),lM(e,t,r,n,a,"avg")}}lB.className="AveragePooling1D",n9.registerClass(lB);class lV extends sC{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new nW(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];n5(this.poolSize,"poolSize"),n5(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,al(this.dataFormat),au(this.padding),this.inputSpec=[new sS({ndim:4})]}computeOutputShape(e){e=sm(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],r="channelsFirst"===this.dataFormat?e[3]:e[2];return(t=o_(t,this.poolSize[0],this.padding,this.strides[0]),r=o_(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat)?[e[0],e[1],t,r]:[e[0],t,r,e[3]]}call(e,t){return(0,nz.tidy)(()=>(this.invokeCallHook(e,t),this.poolingFunction(sf(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat};return Object.assign(e,super.getConfig()),e}}class lW extends lV{constructor(e){super(e)}poolingFunction(e,t,r,n,a){return al(a),au(n),lM(e,t,r,n,a,"max")}}lW.className="MaxPooling2D",n9.registerClass(lW);class lU extends lV{constructor(e){super(e)}poolingFunction(e,t,r,n,a){return al(a),au(n),lM(e,t,r,n,a,"avg")}}lU.className="AveragePooling2D",n9.registerClass(lU);class lG extends sC{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new nW(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];n5(this.poolSize,"poolSize"),n5(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,al(this.dataFormat),au(this.padding),this.inputSpec=[new sS({ndim:5})]}computeOutputShape(e){e=sm(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],r="channelsFirst"===this.dataFormat?e[3]:e[2],n="channelsFirst"===this.dataFormat?e[4]:e[3];return(t=o_(t,this.poolSize[0],this.padding,this.strides[0]),r=o_(r,this.poolSize[1],this.padding,this.strides[1]),n=o_(n,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat)?[e[0],e[1],t,r,n]:[e[0],t,r,n,e[4]]}call(e,t){return(0,nz.tidy)(()=>(this.invokeCallHook(e,t),this.poolingFunction(sf(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat};return Object.assign(e,super.getConfig()),e}}class lq extends lG{constructor(e){super(e)}poolingFunction(e,t,r,n,a){return al(a),au(n),lL(e,t,r,n,a,"max")}}lq.className="MaxPooling3D",n9.registerClass(lq);class lH extends lG{constructor(e){super(e)}poolingFunction(e,t,r,n,a){return al(a),au(n),lL(e,t,r,n,a,"avg")}}lH.className="AveragePooling3D",n9.registerClass(lH);class lj extends sC{constructor(e){super(e),this.inputSpec=[new sS({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new nU}}class lK extends lj{constructor(e){super(e||{})}call(e,t){return(0,nz.tidy)(()=>{let t=sf(e);return ni.mean(t,1)})}}lK.className="GlobalAveragePooling1D",n9.registerClass(lK);class lX extends lj{constructor(e){super(e||{})}call(e,t){return(0,nz.tidy)(()=>{let t=sf(e);return ns.max(t,1)})}}lX.className="GlobalMaxPooling1D",n9.registerClass(lX);class lZ extends sC{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,al(this.dataFormat),this.inputSpec=[new sS({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new nU}getConfig(){let e={dataFormat:this.dataFormat};return Object.assign(e,super.getConfig()),e}}class lY extends lZ{call(e,t){return(0,nz.tidy)(()=>{let t=sf(e);return"channelsLast"===this.dataFormat?ni.mean(t,[1,2]):ni.mean(t,[2,3])})}}lY.className="GlobalAveragePooling2D",n9.registerClass(lY);class lJ extends lZ{call(e,t){return(0,nz.tidy)(()=>{let t=sf(e);return"channelsLast"===this.dataFormat?ns.max(t,[1,2]):ns.max(t,[2,3])})}}lJ.className="GlobalMaxPooling2D",n9.registerClass(lJ);var n9=n9;class lQ extends sC{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}};return Object.assign(e,super.getConfig()),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,r={}){let n=ic(t.layer,r);delete t.layer;let a={layer:n};return Object.assign(a,t),new e(a)}}class l0 extends lQ{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=sm(e)).length<3)throw new nW(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){let t=[(e=sm(e))[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(t),n=e[1];return[r[0],n].concat(r.slice(1))}call(e,t){return(0,nz.tidy)(()=>oQ((e,r)=>[sf(this.layer.call(e,t)),[]],e=sf(e),[],!1,null,null,!1,!0)[1])}}l0.className="TimeDistributed",n9.registerClass(l0);class l1 extends lQ{constructor(e){super(e);const t=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=t,this.forwardLayer=ic(r),t.goBackwards=!0!==t.goBackwards;const n={};if(n.className=e.layer.getClassName(),n.config=t,this.backwardLayer=ic(n),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,n4(ai,"BidirectionalMergeMode",this.mergeMode),e.weights)throw new nU("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,t)),this.backwardLayer.setWeights(e.slice(t))}computeOutputShape(e){let t,r,n,a=this.forwardLayer.computeOutputShape(e);return(Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState&&(n=a.slice(1)),t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,r=[t]):r=null==this.mergeMode?[t,t.slice()]:[t],this.returnState)?null==this.mergeMode?r.concat(n).concat(n.slice()):[t].concat(n).concat(n.slice()):nX(r)}apply(e,t){let r=null==t?null:t.initialState,n=null==t?null:t.constants;null==t&&(t={});let a=oJ(e,r,n,this.numConstants);if(e=a.inputs,r=a.initialState,n=a.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(null==r||0===r.length)&&null==n)return super.apply(e,t);let s=[],i=[];if(null!=r){let e=r.length;if(e%2>0)throw new nW("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=r,s.push(...r);let n=r.map(e=>new sS({shape:e.shape}));this.forwardLayer.stateSpec=n.slice(0,e/2),this.backwardLayer.stateSpec=n.slice(e/2),i.push(...n)}if(null!=n)throw new nU("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof sN;for(let e of s)if(e instanceof sN!==o)throw new nW("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(!o)return super.apply(e,t);{let r=[e].concat(s),n=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=n;let o=super.apply(r,t);return this.inputSpec=a,o}}call(e,t){return(0,nz.tidy)(()=>{let r,n,a,s,i=t.initialState;if(null==i)r=this.forwardLayer.call(e,t),n=this.backwardLayer.call(e,t);else{let a=i.slice(0,i.length/2),s=i.slice(i.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),n=this.backwardLayer.call(e,Object.assign(t,{initialState:s}))}return(this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(n.slice(1))),r=r[0],n=n[0]),this.returnSequences&&(n=tj.reverse(n,1)),"concat"===this.mergeMode?s=aG([r,n]):"sum"===this.mergeMode?s=X.add(r,n):"ave"===this.mergeMode?s=$.mul(.5,X.add(r,n)):"mul"===this.mergeMode?s=$.mul(r,n):null==this.mergeMode&&(s=[r,n]),this.returnState)?null==this.mergeMode?s.concat(a):[s].concat(a):s})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){ad(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),ad(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let r;if(Array.isArray(t)&&(t=t[0]),r=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,!this.returnState)return r;{let e=this.forwardLayer.states.map(e=>null);return Array.isArray(r)?r.concat(e).concat(e):[r].concat(e).concat(e)}}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode};return Object.assign(e,super.getConfig()),e}static fromConfig(e,t){let r=ic(t.layer);if(delete t.layer,null!=t.numConstants)throw new nU("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");return t.layer=r,new e(t)}}l1.className="Bidirectional",n9.registerClass(l1);var n9=n9;class l2 extends sC{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset};return Object.assign(e,super.getConfig()),e}call(e,t){return(0,nz.tidy)(()=>("float32"!==(e=sf(e)).dtype&&(e=aP(e,"float32")),(0,X.add)((0,$.mul)(e,this.scale),this.offset)))}}l2.className="Rescaling",n9.registerClass(l2);var n9=n9,l3=e.i(98976),l4=e.i(47710);let{resizeBilinear:l6,cropAndResize:l5}=ab.image;class l8 extends sC{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,r,n,a,s,i,o){return(0,nz.tidy)(()=>{let l,u=!1,h=[t/s,r/i,(n+t)/s,(a+r)/i],p=[];3===e.rank?(u=!0,l=(0,e1.stack)([e])):l=e;for(let e=0;e<l.shape[0];e++)p.push(h);let d=l5(l,(0,l3.tensor)(p,[p.length,4]),(0,l4.range)(0,p.length,1,"int32"),[n,a],"nearest");return u?aP(sf((0,tA.unstack)(d)),o):aP(d,o)})}upsize(e,t,r,n){return(0,nz.tidy)(()=>aP(l6(e,[t,r]),n))}call(e,t){return(0,nz.tidy)(()=>{let t=sf(e),r=t.dtype,n=t.shape,a=n[n.length-3],s=n[n.length-2],i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let o=0;return(s!==this.width&&0===(o=Math.floor((s-this.width)/2))&&(o=1),i>=0&&o>=0)?this.centerCrop(t,i,o,this.height,this.width,a,s,r):this.upsize(e,this.height,this.width,r)})}getConfig(){let e={height:this.height,width:this.width};return Object.assign(e,super.getConfig()),e}computeOutputShape(e){let t=(e=sm(e)).length-3,r=e.length-2;return e[t]=this.height,e[r]=this.width,e}}l8.className="CenterCrop",n9.registerClass(l8);var n9=n9,l9=e.i(37262);class l7 extends sC{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode};return Object.assign(e,super.getConfig()),e}computeOutputShape(e){return null==(e=sm(e))?[this.numTokens]:("oneHot"===this.outputMode&&1!==e[e.length-1]?e.push(this.numTokens):e[e.length-1]=this.numTokens,e)}call(e,t){return(0,nz.tidy)(()=>{let r;if("int32"!==(e=sf(e)).dtype&&(e=aP(e,"int32")),void 0!==t.countWeights){if("count"!==this.outputMode)throw new nW(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);r=sf(t.countWeights)}let n=(0,ns.max)(e),a=(0,no.min)(e),s=(0,tt.greater)(this.numTokens,n).bufferSync().get(0),i=(0,eg.greaterEqual)(a,0).bufferSync().get(0);if(!(s&&i))throw new nW(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,r,n){let a,s=sf(e);if("int32"!==s.dtype&&(s=aP(s,"int32")),"int"===t)return s;let i=s.shape;if(0===s.rank&&(s=(0,rb.expandDims)(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=(0,rb.expandDims)(s,-1)),s.rank>2)throw new nW(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${s.rank}.`);let o=["multiHot","oneHot"].includes(t),l=s;if(a=void 0!==n&&"count"===t?(0,l9.denseBincount)(l,n,r,o):(0,l9.denseBincount)(l,[],r,o),"tfIdf"!==t)return a;if(n)return(0,$.mul)(a,n);throw new nW("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,r)})}}l7.className="CategoryEncoding",n9.registerClass(l7);var n9=n9;let ue=new Set(["bilinear","nearest"]);class ut extends sC{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(ue.has(e.interpolation))this.interpolation=e.interpolation;else throw new nW(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){let t=(e=sm(e))[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio};return Object.assign(e,super.getConfig()),e}call(e,t){return(0,nz.tidy)(()=>{let t=[this.height,this.width];if("bilinear"===this.interpolation)return ab.image.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return ab.image.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw Error(`Interpolation is ${this.interpolation} but only ${[...ue]} are supported`)})}}ut.className="Resizing",n9.registerClass(ut);var n9=n9;class ur{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}ur.className="RandomSeed";class un extends sC{constructor(e){super(e),this.randomGenerator=new ur(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed};return Object.assign(e,super.getConfig()),e}}un.className="BaseRandomLayer";let ua=new Set(["bilinear","nearest"]);class us extends un{constructor(e){super(e);const{factor:t,interpolation:r="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new nW(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new nW(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new nW(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(ua.has(r))this.interpolation=r;else throw new nW(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation};return Object.assign(e,super.getConfig()),e}computeOutputShape(e){let t=(e=sm(e))[2];return[this.imgHeight,-1,t]}call(e,t){return(0,nz.tidy)(()=>{let t=sf(e);this.imgHeight=t.shape[t.shape.length-3];let r=t.shape[t.shape.length-2];this.widthFactor=(0,ax.randomUniform)([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let n=this.widthFactor.dataSync()[0]*r;n=Math.round(n);let a=[this.imgHeight,n];switch(this.interpolation){case"bilinear":return ab.image.resizeBilinear(e,a);case"nearest":return ab.image.resizeNearestNeighbor(e,a);default:throw Error(`Interpolation is ${this.interpolation}
          but only ${[...ua]} are supported`)}})}}function ui(e){return new sE(e)}function uo(e){return new o$(e)}function ul(e){return new oT(e)}function uu(e){return new oC(e)}function uh(e){return new oE(e)}function up(e){return new oR(e)}function ud(e){return new oA(e)}function uc(e){return new oK(e)}function uf(e){return new oW(e)}function um(e){return new oG(e)}function ug(e){return new oU(e)}function uy(e){return new oq(e)}function ub(e){return new oj(e)}function ux(e){return new oX(e)}function uv(e){return new oZ(e)}function uw(e){return new oY(e)}function uS(e){return new ll(e)}function uN(e){return new li(e)}function uk(e){return new la(e)}function uI(e){return new ls(e)}function uT(e){return new lo(e)}function uC(e){return new lu(e)}function uE(e){return new lh(e)}function u$(e){return new lp(e)}function uA(e){return new lc(e)}function uR(e){return new lm(e)}function uD(e){return new ly(e)}function uF(e){return new lv(e)}function uO(e){return new lb(e)}function u_(e){return new lx(e)}function uM(e){return new lg(e)}function uL(e){return new lS(e)}function uz(e){return new lR(e)}function uP(e){return new lD(e)}function uB(e){return new lF(e)}function uV(e){return new lB(e)}function uW(e){return uV(e)}function uU(e){return uV(e)}function uG(e){return new lU(e)}function uq(e){return uG(e)}function uH(e){return uG(e)}function uj(e){return new lH(e)}function uK(e){return uj(e)}function uX(e){return uj(e)}function uZ(e){return new lK(e)}function uY(e){return new lY(e)}function uJ(e){return new lX(e)}function uQ(e){return new lJ(e)}function u0(e){return new lP(e)}function u1(e){return new lW(e)}function u2(e){return new lq(e)}function u3(e){return new o6(e)}function u4(e){return new o4(e)}function u6(e){return new o8(e)}function u5(e){return new o5(e)}function u8(e){return new o3(e)}function u9(e){return new o2(e)}function u7(e){return new ln(e)}function he(e){return new lr(e)}function ht(e){return new o0(e)}function hr(e){return new o9(e)}function hn(e){return new l1(e)}function ha(e){return new l0(e)}function hs(e){return new lN(e)}function hi(e){return new lk(e)}function ho(e){return new lI(e)}function hl(e){return new ld(e)}function hu(e){return new l2(e)}function hh(e){return new l8(e)}function hp(e){return new ut(e)}function hd(e){return new l7(e)}function hc(e){return new us(e)}function hf(e,t){return iT(e,t)}function hm(e,t){return iS(e,t)}function hg(e,t){return iR(e,t)}function hy(e,t){return iC(e,t)}function hb(e,t){return iv(e,t)}function hx(e,t){return i$(e,t)}function hv(e,t){return(0,nz.tidy)(()=>{let r=iE(e,t),n=(0,nz.tidy)(()=>E.cast(W.sum(eb.logicalAnd(tl.equal(e,1),tl.equal(t,0))),"float32")),a=X.add(r,n);return E.cast(ex.where(tt.greater(a,0),D.div(r,a),0),"float32")})}function hw(e,t){return iN(e,t)}function hS(e,t){return ib(e,t)}function hN(e,t){return ix(e,t)}function hk(e,t){return ix(e,t)}function hI(e,t){return ix(e,t)}function hT(e,t){return iy(e,t)}function hC(e,t){return iy(e,t)}function hE(e,t){return iy(e,t)}function h$(e,t){return(0,nz.tidy)(()=>{let r=e.sub(t).square().sum(),n=e.sub(e.mean()).square().sum();return O.scalar(1).sub(r.div(n))})}function hA(e){return new oS(e)}function hR(e){return ov(e),new oS({l1:null!=e?e.l1:null,l2:0})}function hD(e){return ov(e),new oS({l2:null!=e?e.l2:null,l1:0})}us.className="RandomWidth",n9.registerClass(us),e.s(["activation",()=>uS,"add",()=>uR,"alphaDropout",()=>ho,"average",()=>uD,"averagePooling1d",()=>uV,"averagePooling2d",()=>uG,"averagePooling3d",()=>uj,"avgPool1d",()=>uW,"avgPool2d",()=>uq,"avgPool3d",()=>uK,"avgPooling1d",()=>uU,"avgPooling2d",()=>uH,"avgPooling3d",()=>uX,"batchNormalization",()=>uz,"bidirectional",()=>hn,"categoryEncoding",()=>hd,"centerCrop",()=>hh,"concatenate",()=>uF,"conv1d",()=>uc,"conv2d",()=>uf,"conv2dTranspose",()=>um,"conv3d",()=>ug,"conv3dTranspose",()=>uy,"convLstm2d",()=>u7,"convLstm2dCell",()=>he,"cropping2D",()=>ux,"dense",()=>uN,"depthwiseConv2d",()=>uw,"dot",()=>uL,"dropout",()=>uk,"elu",()=>uo,"embedding",()=>uA,"flatten",()=>uT,"gaussianDropout",()=>hi,"gaussianNoise",()=>hs,"globalAveragePooling1d",()=>uZ,"globalAveragePooling2d",()=>uY,"globalMaxPool1d",0,uJ,"globalMaxPool2d",0,uQ,"globalMaxPooling1d",()=>uJ,"globalMaxPooling2d",()=>uQ,"gru",()=>u3,"gruCell",()=>u4,"inputLayer",()=>ui,"layerNormalization",()=>uP,"leakyReLU",()=>uu,"lstm",()=>u6,"lstmCell",()=>u5,"masking",()=>hl,"maxPool1d",0,u0,"maxPool2d",0,u1,"maxPooling1d",()=>u0,"maxPooling2d",()=>u1,"maxPooling3d",()=>u2,"maximum",()=>uO,"minimum",()=>u_,"multiply",()=>uM,"permute",()=>u$,"prelu",()=>uh,"randomWidth",()=>hc,"reLU",()=>ul,"repeatVector",()=>uC,"rescaling",()=>hu,"reshape",()=>uE,"resizing",()=>hp,"rnn",()=>ht,"separableConv2d",()=>ub,"simpleRNN",()=>u8,"simpleRNNCell",()=>u9,"softmax",()=>up,"spatialDropout1d",()=>uI,"stackedRNNCells",()=>hr,"thresholdedReLU",()=>ud,"timeDistributed",()=>ha,"upSampling2d",()=>uv,"zeroPadding2d",()=>uB],75168),e.i(75168),e.s(["Layer",()=>sC,"RNN",()=>o0,"RNNCell",()=>o1,"activation",()=>uS,"add",()=>uR,"alphaDropout",()=>ho,"average",()=>uD,"averagePooling1d",()=>uV,"averagePooling2d",()=>uG,"averagePooling3d",()=>uj,"avgPool1d",()=>uW,"avgPool2d",()=>uq,"avgPool3d",()=>uK,"avgPooling1d",()=>uU,"avgPooling2d",()=>uH,"avgPooling3d",()=>uX,"batchNormalization",()=>uz,"bidirectional",()=>hn,"categoryEncoding",()=>hd,"centerCrop",()=>hh,"concatenate",()=>uF,"conv1d",()=>uc,"conv2d",()=>uf,"conv2dTranspose",()=>um,"conv3d",()=>ug,"conv3dTranspose",()=>uy,"convLstm2d",()=>u7,"convLstm2dCell",()=>he,"cropping2D",()=>ux,"dense",()=>uN,"depthwiseConv2d",()=>uw,"dot",()=>uL,"dropout",()=>uk,"elu",()=>uo,"embedding",()=>uA,"flatten",()=>uT,"gaussianDropout",()=>hi,"gaussianNoise",()=>hs,"globalAveragePooling1d",()=>uZ,"globalAveragePooling2d",()=>uY,"globalMaxPool1d",0,uJ,"globalMaxPool2d",0,uQ,"globalMaxPooling1d",()=>uJ,"globalMaxPooling2d",()=>uQ,"gru",()=>u3,"gruCell",()=>u4,"input",()=>i7,"inputLayer",()=>ui,"layerNormalization",()=>uP,"leakyReLU",()=>uu,"lstm",()=>u6,"lstmCell",()=>u5,"masking",()=>hl,"maxPool1d",0,u0,"maxPool2d",0,u1,"maxPooling1d",()=>u0,"maxPooling2d",()=>u1,"maxPooling3d",()=>u2,"maximum",()=>uO,"minimum",()=>u_,"multiply",()=>uM,"permute",()=>u$,"prelu",()=>uh,"randomWidth",()=>hc,"reLU",()=>ul,"repeatVector",()=>uC,"rescaling",()=>hu,"reshape",()=>uE,"resizing",()=>hp,"rnn",()=>ht,"separableConv2d",()=>ub,"simpleRNN",()=>u8,"simpleRNNCell",()=>u9,"softmax",()=>up,"spatialDropout1d",()=>uI,"stackedRNNCells",()=>hr,"thresholdedReLU",()=>ud,"timeDistributed",()=>ha,"upSampling2d",()=>uv,"zeroPadding2d",()=>uB],26196),e.i(26196),e.s(["MAPE",()=>hk,"MSE",()=>hC,"binaryAccuracy",()=>hf,"binaryCrossentropy",()=>hm,"categoricalAccuracy",()=>hy,"categoricalCrossentropy",()=>hb,"cosineProximity",()=>hw,"mape",()=>hI,"meanAbsoluteError",()=>hS,"meanAbsolutePercentageError",()=>hN,"meanSquaredError",()=>hT,"mse",()=>hE,"precision",()=>hx,"r2Score",()=>h$,"recall",()=>hv,"sparseCategoricalAccuracy",()=>hg],2923),e.i(2923),e.s([],35425),e.i(35425),e.s(["modelFromJSON",()=>i8],12450),e.i(12450),e.s(["l1",()=>hR,"l1l2",()=>hA,"l2",()=>hD],17096),e.i(17096);e.i(70001);var hF=e.i(89378),hO=e.i(41175),hO=hO;function h_(e,t,r=new Map,n=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(n.has(e))throw Error("Circular references are not supported.");if(r.has(e))return r.get(e);let a=t(e);if(a.recurse&&null!==a.value)throw Error("A deep map function may not return both a value and recurse=true.");if(!a.recurse)return r.set(e,a.value),a.value;if(hz(e)){let a=Array.isArray(e)?[]:{};for(let s in n.add(e),e){let i=h_(e[s],t,r,n);a[s]=i}return n.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw Error(`Can't recurse into non-iterable type: ${e}`)}function hM(e){return null===e?null:hz(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function hL(e,t){let r=new Map;for(let n of(h_(e,t,r),Array.from(r.keys()))){let e=r.get(n);if(nP.util.isPromise(e)){let t=await e;r.set(n,t)}}return h_(e,t,r)}function hz(e){let t=!1;if(nL.env().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:r}={};t=e instanceof r}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof rI.Tensor)&&!(e instanceof Promise)&&!t)}function hP(e){return e instanceof rI.Tensor?{value:e.clone(),recurse:!1}:hz(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class hB{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw RangeError("Can't create ring buffer of capacity < 1.");this.data=Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),r=this.get(t);return this.set(t,this.pop()),r}}class hV extends hB{constructor(){super(hV.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=2*this.capacity,t=Array(e),r=this.length();for(let e=0;e<r;e++)t[e]=this.get(this.wrap(this.begin+e));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}}hV.INITIAL_CAPACITY=32;class hW{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],r=await e.next();for(;!r.done;)t.push(r.value),r=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),r=e(t.value);for(;!t.done&&r;)r=e((t=await this.next()).value)}handleErrors(e){return new hY(this,e)}filter(e){return new hX(this,e)}map(e){return new hZ(this,e)}mapAsync(e){return new hJ(this,e)}serialMapAsync(e){return new hJ(this,e).serial()}flatmap(e){return new h0(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(e=>!0===e)}rowMajorBatch(e,t=!0){return new hK(this,e,t)}columnMajorBatch(e,t=!0,r=hM){return this.rowMajorBatch(e,t).map(e=>(function(e,t=hM){return function e(t,r,n=new Set){let a=t[0];if(n.has(a))throw Error("Circular references are not supported.");let s=r(t);if(s.recurse&&null!==s.value)throw Error("A deep zip function may not return both a value and recurse=true.");if(!s.recurse)return s.value;if(hz(a)){let s=Array.isArray(a)?[]:{};for(let i in n.add(a),a){let a=e(t.map(e=>e[i]),r,n);s[i]=a}return n.delete(a),s}throw Error(`Can't recurse into non-iterable type: ${a}`)}(e,t)})(e,r))}concatenate(e,t){return new h1(new hU([this,e]),t)}take(e){return e<0||null==e?this:new hj(this,e)}skip(e){return e<0||null==e?this:new hH(this,e)}prefetch(e){return new h3(this,e)}shuffle(e,t){return new h4(this,e,t)}serial(){return new hq(this)}}class hU extends hW{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:h_(e,hP),done:!1}}}class hG extends hW{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class hq extends hW{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class hH extends hW{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;nz.dispose(e.value)}return this.upstream.next()}}class hj extends hW{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class hK extends hW{constructor(e,t,r=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done){if(this.enableSmallLastBatch&&e.length>0)return{value:e,done:!1};return{value:null,done:!0}}e.push(t.value)}return{value:e,done:!1}}}class hX extends hW{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;nz.dispose(e.value)}}}class hZ extends hW{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=hO.getTensorsInContainer(e.value),r=this.transform(e.value),n=hO.getTensorsInContainer(r);for(let e of t)hO.isTensorInList(e,n)||e.dispose();return{value:r,done:!1}}}class hY extends hW{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class hJ extends hW{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=hO.getTensorsInContainer(e.value),r=await this.transform(e.value),n=hO.getTensorsInContainer(r);for(let e of t)hO.isTensorInList(e,n)||e.dispose();return{value:r,done:!1}}}class hQ extends hW{constructor(){super(),this.outputQueue=new hV,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class h0 extends hQ{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=hO.getTensorsInContainer(e.value),r=this.transform(e.value),n=hO.getTensorsInContainer(r);for(let e of(this.outputQueue.pushAll(r),t))hO.isTensorInList(e,n)||e.dispose();return!0}}class h1 extends hW{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){let e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}(i=d||(d={}))[i.FAIL=0]="FAIL",i[i.SHORTEST=1]="SHORTEST",i[i.LONGEST=2]="LONGEST";class h2 extends hW{constructor(e,t=d.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,r=0,n=await hL(this.iterators,function(e){return e instanceof hW?{value:e.next().then(e=>(t++,e.done&&r++,e.value)),recurse:!1}:{value:null,recurse:!0}});if(t===r)return{value:null,done:!0};if(r>0)switch(this.mismatchMode){case d.FAIL:throw Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case d.SHORTEST:return{value:null,done:!0};case d.LONGEST:}return this.count++,{value:n,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class h3 extends hW{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new hB(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class h4 extends h3{constructor(e,t,r){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=hF.alea(r||nP.util.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class h6{constructor(){this.size=null}batch(e,t=!0){let r=this;return nP.util.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`),h5(async()=>(await r.iterator()).columnMajorBatch(e,t,h7),this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e))}concatenate(e){let t=this;return h5(async()=>(await t.iterator()).concatenate(await e.iterator()),this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null)}filter(e){let t=this;return h5(async()=>(await t.iterator()).filter(t=>nz.tidy(()=>e(t))),this.size===1/0?1/0:null)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return h5(async()=>(await t.iterator()).map(t=>nz.tidy(()=>e(t))),this.size)}mapAsync(e){let t=this;return h5(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(null==e)throw RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return h5(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this;return h5(async()=>new h1(new hG(async()=>({value:await t.iterator(),done:!1})).take(e),void 0),null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null)}skip(e){let t=this;return h5(async()=>(await t.iterator()).skip(e),null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null)}shuffle(e,t,r=!0){if(null==e||e<0)if(null==this.size)throw RangeError("`Dataset.shuffle()` requires bufferSize to be specified.");else throw RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let n=this,a=hF.alea(t||nP.util.now().toString());return h5(async()=>{let t=a.int32();return r&&(t+=a.int32()),(await n.iterator()).shuffle(e,t.toString())},this.size)}take(e){let t=this;return h5(async()=>(await t.iterator()).take(e),null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null)}async toArray(){if(this.size===1/0)throw Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function h5(e,t=null){return new class extends h6{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function h8(e){return h5(async()=>new hU(e),e.length)}function h9(e){let t;if(!hz(e))throw Error("The argument to zip() must be an object or array.");if(Array.isArray(e))for(let r=0;r<e.length;r++)t=null==t?e[r].size:Math.min(t,e[r].size);else if(e instanceof Object)for(let r in e)t=null==t?e[r].size:Math.min(t,e[r].size);return h5(async()=>(function(e,t=d.FAIL){return new h2(e,t)})(await hL(e,e=>{if(e instanceof h6)return{value:e.iterator(),recurse:!1};if(hz(e))return{value:null,recurse:!0};throw Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}),d.SHORTEST),t)}function h7(e){var t,r;if(null===e)return null;return null==(t=e[0])||null===(r=t)||"object"!=typeof r&&"function"!=typeof r||Array.isArray(t)||"object"==typeof t&&t instanceof rI.Tensor||nP.util.isTypedArray(t)?{value:function(e){if(0===e.length)throw Error("Can't make a batch of zero elements.");return e[0]instanceof rI.Tensor?e1.stack(e):l3.tensor(e)}(e),recurse:!1}:{value:null,recurse:!0}}h6.MAX_BUFFER_SIZE=1e4;class pe extends h6{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}}let pt=Symbol("out"),pr=Symbol("field"),pn=Symbol("quote"),pa=Symbol("quoteafterquote"),ps=Symbol("quoteinquote");class pi extends h6{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(this.fullColumnNames||e)this.fullColumnNames&&e&&nP.util.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").");else throw Error("Column names must be provided if there is no header line.");this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((e,t)=>(e[t]=e[t]+1||1,e),{}),r=Object.keys(t).filter(e=>t[e]>1);if(nP.util.assert(0===r.length,()=>"Duplicate column names found: "+r.toString()),this.columnConfigs){for(let e of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(e))throw Error('The key "'+e+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(!this.hasHeader)return null;{let e=await this.base.iterator(),t=await e.next();if(t.done)throw Error("No data was found for CSV parsing.");let r=t.value;return this.parseRow(r,!1)}}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new pe(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(nP.util.assert(null==t.delimiter,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(e=>this.makeDataElement(e))}makeDataElement(e){let t=this.parseRow(e),r={},n={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!this.configuredColumnsOnly||i){let o=t[a],l=null;if(""===o)if(i&&void 0!==i.default)l=i.default;else if(i&&(i.required||i.isLabel))throw Error(`Required column ${s} is empty in this line: ${e}`);else l=void 0;else{let e=Number(o);if(isNaN(e))l=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":default:l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(o)}else l=e}i&&i.isLabel?n[s]=l:r[s]=l}}return 0===Object.keys(n).length?r:{xs:r,ys:n}}getBoolean(e){return+("1"===e||"true"===e.toLowerCase())}parseRow(e,t=!0){let r=[],n=0,a=e.length,s=pt;for(let t=0;t<a;t++)switch(s){case pt:switch(e.charAt(t)){case'"':n=t+1,s=pn;break;case this.delimiter:if(n=t+1," "===this.delimiter&&this.delimWhitespace)break;r.push(""),s=pt;break;default:s=pr,n=t}break;case pr:e.charAt(t)===this.delimiter&&(r.push(e.substring(n,t)),s=pt,n=t+1);break;case pn:'"'===e.charAt(t)&&(s=pa);break;case pa:switch(e.charAt(t)){case this.delimiter:r.push(e.substring(n,t-1)),s=pt,n=t+1;break;case'"':s=pn;break;default:s=ps}break;case ps:'"'===e.charAt(t)&&(s=pn)}if(s===pa?r.push(e.substring(n,a-1)):r.push(e.substring(n)),t&&r.length!==this.fullColumnNames.length)throw Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${r}`);return r}}class po extends hW{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!(0,nL.env)().get("IS_BROWSER"))throw Error("microphone API is only supported in browser environment.");let t=new po(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(e){throw Error(`Error thrown while initializing video stream: ${e.message}`)}if(!this.stream)throw Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){let e,t;if(this.isClosed)return{value:null,done:!0};let r=await this.getAudioData();if(this.includeSpectrogram){let t=this.flattenQueue(r.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let e=this.flattenQueue(r.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],r=0;return new Promise(n=>{let a=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&n({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++r===this.numFrames&&(clearInterval(a),n({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){!this.isClosed&&(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,r=new Float32Array(e.length*t);return e.forEach((e,n)=>r.set(e,n*t)),r}getTensorFromAudioDataArray(e,t){let r=new Float32Array(nP.util.sizeFromShape(t));return r.set(e,r.length-e.length),(0,l3.tensor)(r,t)}}var pl=e.i(53988),pl=pl,pu=e.i(38363);class ph extends hW{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=(0,aD.tensor1d)([0],"int32"),this.webcamConfig.centerCrop){const e=this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=this.webcamConfig.resizeHeight/this.webcamVideoElement.height,r=(1-e)/2,n=(1-t)/2;this.cropBox=(0,pu.tensor2d)([n,r,t+n,r+e],[1,4])}else this.cropBox=(0,pu.tensor2d)([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!(0,nL.env)().get("IS_BROWSER"))throw Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let r=new ph(e,t);return await r.start(),r}async start(){this.webcamConfig.facingMode&&nP.util.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){let e;if(this.isClosed)return{value:null,done:!0};try{e=pl.fromPixels(this.webcamVideoElement)}catch(e){throw Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(e){throw Error(`Error thrown cropping the video: ${e.message}`)}finally{e.dispose()}}needToResize(){return!!this.webcamConfig.resizeWidth&&!!this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return(0,nz.tidy)(()=>{let t,r=(0,rb.expandDims)((0,E.cast)(e,"float32"),0),n=(t=ab.image.cropAndResize(r,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear")).shape;return(0,V.reshape)(t,n.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw Error("Can not convert infinite video stream to array.")}}class pp{}var pd=e.i(67034);class pc extends hW{split(e){return new pf(this,e)}}class pf extends pc{constructor(e,t){super(),this.upstream=e,this.impl=new pm(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class pm extends hQ{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);for(let e of(t[0]=this.carryover+t[0],t.slice(0,-1)))this.outputQueue.push(e);return this.carryover=t[t.length-1],!0}}class pg extends hW{decodeUTF8(){return new py(this)}}class py extends pc{constructor(e){super(),this.upstream=e,this.impl=new pb(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class pb extends hQ{constructor(e){if(super(),this.upstream=e,(0,nL.env)().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:e}={};this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e,t,r=await this.upstream.next();return!r.done&&(e=r.value,t=(0,nL.env)().get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(pd.Buffer.from(e.buffer)),this.outputQueue.push(t),!0)}}class px extends pg{constructor(e,t={}){super(),this.file=e,this.options=t,nP.util.assert(e instanceof Uint8Array||!!(0,nL.env)().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};let e=new Promise((e,t)=>{let r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,r)));else{let n=new FileReader;n.onload=r=>{let a=n.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return t(TypeError("FileReader returned unknown type."));e(a)},n.onabort=e=>t(Error("Aborted")),n.onerror=e=>t(Error(e.type));let a=this.file.slice(this.offset,r);n.readAsArrayBuffer(a)}this.offset=r});return{value:await e,done:!1}}}async function pv(e,t={},r){let n,a;"string"==typeof e?n=e:(n=e.url,a=pw(e));let s=await (r||nP.util.fetch)(n,a);if(s.ok)return new px(new Uint8Array(await s.arrayBuffer()),t);throw Error(s.statusText)}let pw=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function pS(e){return"string"==typeof e&&"file://"===e.slice(0,7)}class pN extends pp{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){return pS(this.input)&&(0,nL.env)().get("IS_NODE")&&(this.input=({}).readFileSync(this.input.slice(7))),new px(this.input,this.options)}}class pk extends pp{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return pS(this.url)?new pN(this.url,this.fileOptions).iterator():pv(this.url,this.fileOptions)}}function pI(e,t={}){return new pi(new pk(e),t)}function pT(e){let t=new hG(e);return h5(async()=>t)}function pC(e){return h5(async()=>{let t=await e();return new hG(()=>t.next())})}async function pE(e,t){return ph.create(e,t)}async function p$(e){return po.create(e)}e.s([],15571),e.i(15571),e.s(["CSVDataset",()=>pi,"Dataset",()=>h6,"FileDataSource",()=>pN,"TextLineDataset",()=>pe,"URLDataSource",()=>pk,"array",()=>h8,"csv",()=>pI,"func",()=>pT,"generator",()=>pC,"microphone",()=>p$,"version_data",()=>"4.22.0","webcam",()=>pE,"zip",()=>h9],31594),e.i(31594);var tL=tL,pA=e.i(61133),pR=e.i(90422),pD=e.i(17723),pD=pD;function pF(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&nP.util.assert("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}let pO=pD.whereImpl;class p_ extends pR.KernelBackend{nextDataId(){return p_.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new pR.DataStorage(this,(0,nz.engine)())}write(e,t,r){this.firstUse&&(this.firstUse=!1,(0,nL.env)().get("IS_NODE")&&tL.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let n={id:this.nextDataId()};return this.data.set(n,{values:e,dtype:r,refCount:1}),n}makeTensorInfo(e,t,r){let n;if("string"===t&&null!=r&&r.length>0&&nP.util.isString(r[0])){let a=r.map(e=>nP.util.encodeString(e));n=this.write(a,e,t)}else n=this.write(r,e,t);return{dataId:n,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,r,n,a){this.data.set(e,{values:t,dtype:n,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:r}=this.data.get(e);if("complex64"===t){let e=this.readSync(r.real.dataId),t=this.readSync(r.imag.dataId);return tL.mergeRealAndImagArrays(e,t)}return nP.util.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let r=t.map(e=>nP.util.decodeString(e));return(0,pA.buffer)(e.shape,e.dtype,r)}catch(e){throw Error("Failed to decode encoded string bytes into utf-8")}return(0,pA.buffer)(e.shape,e.dtype,t)}makeOutput(e,t,r){return(0,nz.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(t,r,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:r}=this.data.get(e);null!=r&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=nP.util.now();return e(),{kernelMs:nP.util.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){pF([e],"where");let t=this.readSync(e.dataId);return pO(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function pM(e){let t=new Float32Array(e.length);for(let r=0;r<e.length;++r)t[r]=Math.abs(e[r]);return t}p_.nextDataId=0,e.s([],25164),e.i(25164);let pL={kernelName:C.Abs,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,r=e.backend;pF(t,"abs");let n=new Float32Array(nP.util.sizeFromShape(t.shape));return n=pM(r.data.get(t.dataId).values),r.makeOutput(n,t.shape,t.dtype)}};var tL=tL;function pz(e){return(t,r,n,a,s)=>{let i=tL.assertAndGetBroadcastShape(t,r),o=i.length,l=nP.util.computeStrides(i),u=nP.util.sizeFromShape(i),h=nP.util.getTypedArrayFromDType(s,u),p=t.length,d=r.length,c=nP.util.computeStrides(t),f=nP.util.computeStrides(r),m=tL.getBroadcastDims(t,i),g=tL.getBroadcastDims(r,i);if(m.length+g.length===0)for(let t=0;t<h.length;++t)h[t]=e(n[t%n.length],a[t%a.length]);else for(let t=0;t<h.length;++t){let r=nP.util.indexToLoc(t,o,l),s=r.slice(-p);m.forEach(e=>s[e]=0);let i=nP.util.locToIndex(s,p,c),u=r.slice(-d);g.forEach(e=>u[e]=0);let y=nP.util.locToIndex(u,d,f);h[t]=e(n[i],a[y])}return[h,i]}}var tL=tL;function pP(e){let{inputs:t,backend:r}=e,{real:n,imag:a}=t,s=r.data.get(n.dataId).values,i=r.data.get(a.dataId).values,o=r.makeTensorInfo(n.shape,"complex64");return r.data.get(o.dataId).complexTensorInfos={real:r.makeTensorInfo(n.shape,"float32",s),imag:r.makeTensorInfo(a.shape,"float32",i)},o}let pB={kernelName:C.Complex,backendName:"cpu",kernelFunc:pP};function pV(e,t,r="float32"){if("complex64"===r)return pP({inputs:{real:pV(e,t,"float32"),imag:pV(e,t,"float32")},backend:e});let n=nP.util.makeZerosTypedArray(nP.util.sizeFromShape(t),r);return e.makeTensorInfo(t,r,n)}function pW(e){let{inputs:t,backend:r}=e,{x:n}=t;return r.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}let pU={kernelName:C.Identity,backendName:"cpu",kernelFunc:pW};function pG(e){let{inputs:t,backend:r}=e,{input:n}=t,a=r.data.get(n.dataId).complexTensorInfos.real,s=r.data.get(a.dataId).values;return r.makeTensorInfo(a.shape,a.dtype,s)}let pq={kernelName:C.Real,backendName:"cpu",kernelFunc:pG};function pH(e,t,r,n){if("int32"===n)return[t,"int32",Int32Array.from(e)];if("bool"===n){let n=nP.util.toTypedArray([0],r),[a,s]=pz((e,t)=>+(e!==t))(t,[],e,n,"bool");return[s,"bool",a]}throw Error(`Error in Cast: failed to cast ${r} to ${n}`)}function pj(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{dtype:s}=n;if("complex64"===s){if("complex64"===a.dtype)return pW({inputs:{x:a},backend:r});let e=pV(r,a.shape,a.dtype),t=pj({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),n=pP({inputs:{real:t,imag:e},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(t),n}if("complex64"===a.dtype){let e=pG({inputs:{input:a},backend:r}),t=pj({inputs:{x:e},backend:r,attrs:{dtype:s}});return r.disposeIntermediateTensorInfo(e),t}if(!nP.util.hasEncodingLoss(a.dtype,s)){let e=pW({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:s}}let[i,o,l]=pH(r.data.get(a.dataId).values,a.shape,a.dtype,s);return r.makeTensorInfo(i,o,l)}let pK={kernelName:C.Cast,backendName:"cpu",kernelFunc:pj};function pX(e,t,r,n){return null==r?({inputs:r,backend:a})=>{let{a:s,b:i}=r;pF([s,i],e);let o=a.data.get(s.dataId).values,l=a.data.get(i.dataId).values,u="string"===s.dtype?tL.fromUint8ToStringArray(o):o,h="string"===s.dtype?tL.fromUint8ToStringArray(l):l,p=n||s.dtype,[d,c]=t(s.shape,i.shape,u,h,p);return a.makeTensorInfo(c,p,d)}:({inputs:e,backend:a})=>{let{a:s,b:i}=e;if("complex64"===s.dtype||"complex64"===i.dtype){let e=pj({inputs:{x:s},backend:a,attrs:{dtype:"complex64"}}),t=a.data.get(e.dataId),n=t.complexTensorInfos.real,o=t.complexTensorInfos.imag,l=a.data.get(n.dataId).values,u=a.data.get(o.dataId).values,h=pj({inputs:{x:i},backend:a,attrs:{dtype:"complex64"}}),p=a.data.get(h.dataId),d=p.complexTensorInfos.real,c=p.complexTensorInfos.imag,f=a.data.get(d.dataId).values,m=a.data.get(c.dataId).values,[g,y,b]=r(s.shape,i.shape,l,u,f,m),x=a.makeTensorInfo(b,"float32",g),v=a.makeTensorInfo(b,"float32",y),w=pP({inputs:{real:x,imag:v},backend:a});return a.disposeIntermediateTensorInfo(e),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(v),w}{let e=a.data.get(s.dataId).values,r=a.data.get(i.dataId).values,o=n||s.dtype,[l,u]=t(s.shape,i.shape,e,r,o);return a.makeTensorInfo(u,o,l)}}}function pZ(e){return(t,r,n,a,s,i)=>{let o=tL.assertAndGetBroadcastShape(t,r),l=nP.util.sizeFromShape(o),u=o.length,h=nP.util.computeStrides(o),p=nP.util.getTypedArrayFromDType("float32",l),d=nP.util.getTypedArrayFromDType("float32",l),c=tL.getBroadcastDims(t,o),f=tL.getBroadcastDims(r,o),m=tL.mergeRealAndImagArrays(n,a),g=tL.mergeRealAndImagArrays(s,i),y=t.length,b=nP.util.computeStrides(t),x=r.length,v=nP.util.computeStrides(r);if(c.length+f.length===0)for(let t=0;t<p.length;t++){let r=t%m.length,n=t%g.length,a=e(m[2*r],m[2*r+1],g[2*n],g[2*n+1]);p[t]=a.real,d[t]=a.imag}else for(let t=0;t<p.length;t++){let r=nP.util.indexToLoc(t,u,h),n=r.slice(-y);c.forEach(e=>n[e]=0);let a=nP.util.locToIndex(n,y,b),s=r.slice(-x);f.forEach(e=>s[e]=0);let i=nP.util.locToIndex(s,x,v),o=e(m[2*a],m[2*a+1],g[2*i],g[2*i+1]);p[t]=o.real,d[t]=o.imag}return[p,d,o]}}let pY=pz((e,t)=>e+t),pJ=pZ((e,t,r,n)=>({real:e+r,imag:t+n})),pQ=pX(C.Add,pY,pJ),p0={kernelName:C.Add,backendName:"cpu",kernelFunc:pQ};function p1(e,t,r,n,a){let s=nP.util.sizeFromShape(n),i=nP.util.makeZerosTypedArray(a,r);for(let r=0;r<e.length;r++){let n=e[r];if(n<0)throw Error("Input x must be non-negative!");n>=a||(s>0?i[n]+=t[r]:i[n]+=1)}return i}function p2(e,t,r,n=!1){let a=e.shape[0],s=e.shape[1],i=(0,pA.buffer)([a,r],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<s;a++){let s=e.get(o,a);if(s<0)throw Error("Input x must be non-negative!");s>=r||(n?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,a),o,s):i.set(i.get(o,s)+1,o,s))}return i}let p3=pz((e,t)=>e&t),p4=pX(C.BitwiseAnd,p3),p6={kernelName:C.BitwiseAnd,backendName:"cpu",kernelFunc:p4};function p5(e){return(t,r,n)=>{let a=nP.util.getArrayFromDType(r,t.length);for(let r=0;r<t.length;++r)a[r]=e(t[r],n);return a}}var tL=tL;function p8(e,t,r){return p9(e,p5(t),r)}function p9(e,t,r){return({inputs:n,attrs:a,backend:s})=>{let i,{x:o}=n;pF(o,e);let l=s.data.get(o.dataId).values;if("string"===o.dtype){if(!Array.isArray(l))throw Error("String tensor's value was not an instance of Array");i=tL.fromUint8ToStringArray(l)}else i=l;let u=r||o.dtype,h=t(i,u,a);return s.makeTensorInfo(o.shape,u,h)}}let p7=p5(e=>Math.ceil(e)),de=p9(C.Ceil,p7),dt={kernelName:C.Ceil,backendName:"cpu",kernelFunc:de};var tL=tL;function dr(e,t,r,n){let a=nP.util.getArrayFromDType(r,nP.util.sizeFromShape(t));if(n&&"string"!==r){let t=0;e.forEach(e=>{let r=nP.util.sizeFromShape(e.shape);a.set(e.vals,t),t+=r})}else{let n=0;e.forEach(e=>{let s="string"===r?tL.fromUint8ToStringArray(e.vals):e.vals,i=0;for(let r=0;r<e.shape[0];++r){let o=r*t[1]+n;for(let t=0;t<e.shape[1];++t)a[o+t]=s[i++]}n+=e.shape[1]})}return a}let dn=pz((e,t)=>+(e===t)),da=pX(C.Equal,dn,null,"bool"),ds={kernelName:C.Equal,backendName:"cpu",kernelFunc:da},di=p5(e=>Math.exp(e)),dl=p9(C.Exp,di,"float32"),du={kernelName:C.Exp,backendName:"cpu",kernelFunc:dl},dh=p5(e=>Math.expm1(e)),dp=p9(C.Expm1,dh),dd={kernelName:C.Expm1,backendName:"cpu",kernelFunc:dp},dc=p5(e=>Math.floor(e)),df=p9(C.Floor,dc),dm={kernelName:C.Floor,backendName:"cpu",kernelFunc:df},dg=pz((e,t)=>Math.floor(e/t)),dy=pX(C.FloorDiv,dg,null,"int32"),db={kernelName:C.FloorDiv,backendName:"cpu",kernelFunc:dy};function dx(e,t,r,n,a,s,i,o,l){let u=(0,pA.buffer)([n,s],r);for(let r=0;r<n;r++){let n=[],h=0;for(let t=0;t<a;t++){let s=e[r*a+t];h+=s*i[t],n.push(s)}if(h<0||h>=l/s)throw Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<s;e++)u.values[r*s+e]=t.get(...t.indexToLoc(h*s+e))}return u}function dv(e,t,r){let n=(0,pA.buffer)(r,e.dtype);for(let r=0;r<n.size;++r){let a=n.indexToLoc(r).slice(),s=a[0],i=a[2],o=t.locToIndex([s,i]);a[2]=t.values[o];let l=e.locToIndex(a);0<=l&&l<e.values.length&&(n.values[r]=e.values[l])}return n}let dw=pz((e,t)=>+(e>t)),dS=pX(C.Greater,dw,null,"bool"),dN={kernelName:C.Greater,backendName:"cpu",kernelFunc:dS},dk=pz((e,t)=>+(e>=t)),dI=pX(C.GreaterEqual,dk,null,"bool"),dT={kernelName:C.GreaterEqual,backendName:"cpu",kernelFunc:dI},dC=pz((e,t)=>+(e<t)),dE=pX(C.Less,dC,null,"bool"),d$={kernelName:C.Less,backendName:"cpu",kernelFunc:dE},dA=pz((e,t)=>+(e<=t)),dR=pX(C.LessEqual,dA,null,"bool"),dD={kernelName:C.LessEqual,backendName:"cpu",kernelFunc:dR};function dF(e,t,r){let n=(t-e)/(r-1),a=nP.util.makeZerosTypedArray(r,"float32");a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+n;return a}let dO=p5(e=>Math.log(e)),d_=p9(C.Log,dO),dM={kernelName:C.Log,backendName:"cpu",kernelFunc:d_};function dL(e,t,r,n){let a=nP.util.getTypedArrayFromDType(n,nP.util.sizeFromShape(r));for(let r=0;r<a.length;++r){let n=r*t,s=e[n];for(let r=0;r<t;++r){let t=e[n+r];(Number.isNaN(t)||t>s)&&(s=t)}a[r]=s}return a}let dz=pz((e,t)=>Math.max(e,t)),dP=pX(C.Maximum,dz),dB={kernelName:C.Maximum,backendName:"cpu",kernelFunc:dP},dV=pz((e,t)=>Math.min(e,t)),dW=pX(C.Minimum,dV),dU={kernelName:C.Minimum,backendName:"cpu",kernelFunc:dW},dG=pz((e,t)=>e*t),dq=pZ((e,t,r,n)=>({real:e*r-t*n,imag:e*n+t*r})),dH=pX(C.Multiply,dG,dq),dj={kernelName:C.Multiply,backendName:"cpu",kernelFunc:dH};function dK(e,t,r){return dG([],t,nP.util.createScalarValue(-1,r),e,r)}let dX={kernelName:C.Neg,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{x:n}=t;pF(n,"neg");let[a,s]=dK(r.data.get(n.dataId).values,n.shape,n.dtype);return r.makeTensorInfo(s,n.dtype,a)}},dZ=pz((e,t)=>+(e!==t)),dY=pX(C.NotEqual,dZ,null,"bool"),dJ={kernelName:C.NotEqual,backendName:"cpu",kernelFunc:dY};var tL=tL,dQ=e.i(8308);function d0(e,t,r,n,a){let s=t.length,i=nP.util.sizeFromShape(t),o=nP.util.computeStrides(t),l=nP.util.computeStrides(a),u=nP.util.getTypedArrayFromDType(r,nP.util.sizeFromShape(a));for(let t=0;t<i;++t){let r=nP.util.indexToLoc(t,s,o),a=Array(r.length);for(let e=0;e<a.length;e++)a[e]=r[n[e]];u[nP.util.locToIndex(a,s,l)]=e[t]}return u}function d1(e){let{inputs:t,attrs:r,backend:n}=e,{x:a}=t,{perm:s}=r;pF(a,"transpose");let i=Array(a.shape.length);for(let e=0;e<i.length;e++)i[e]=a.shape[s[e]];let o=d0(n.data.get(a.dataId).values,a.shape,a.dtype,s,i);return{dataId:n.write(o,i,a.dtype),shape:i,dtype:a.dtype}}let d2={kernelName:C.Transpose,backendName:"cpu",kernelFunc:d1};function d3(e,t,r,n){let[a,s]=tL.computeOutAndReduceShapes(e,n),i=(0,dQ.upcastType)(t,"int32"),o=nP.util.makeZerosTypedArray(nP.util.sizeFromShape(a),i),l=nP.util.sizeFromShape(s);for(let e=0;e<o.length;++e){let t=e*l,n=1;for(let e=0;e<l;++e)n*=r[t+e];o[e]=n}return{outVals:o,outShape:a,outDtype:i}}let d4={kernelName:C.Prod,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s,keepDims:i}=n;pF(a,"prod");let o=a.shape.length,l=nP.util.parseAxisParam(s,a.shape),u=tL.getAxesPermutation(l,o),h=l,p=a,d=[];null!=u&&(d.push(p=d1({inputs:{x:a},backend:r,attrs:{perm:u}})),h=tL.getInnerMostAxes(h.length,o));let c=r.data.get(p.dataId).values,{outVals:f,outShape:m,outDtype:g}=d3(p.shape,p.dtype,c,h),y=m;return i&&(y=tL.expandShapeToKeepDim(m,l)),d.forEach(e=>r.disposeIntermediateTensorInfo(e)),r.makeTensorInfo(y,g,f)}};function d6(e,t){let r=e.slice(0,t);for(;r.length<t;)r.push(1);for(let n=t;n<e.length;n++)r[t-1]*=e[n];return r}function d5(e,t,r,n,a,s,i,o){let l,u,h,p;if(0===e.length)throw Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw Error("Split tensors must not be scalars");let d=t[0][0]-1;if(s.forEach((e,t)=>{if(e<0||e>=d){let r=nP.util.indexToLoc(t,i.length,nP.util.computeStrides(i)).join(",");throw Error(`indices[${r}] = ${e} is not in [0, ${d})`)}}),0===n.length)throw Error("params.rank must be nonzero");let{outSplits:c,valueSlices:f,numValues:m}=function(e,t,r,n){let a=[],s=0,i=Array(t.length-1+r.length).fill(null).map(()=>[0]);for(let e=0;e<r.length;++e){let t=r[e],a=e===r.length-1?n:r[e+1].length;if(0===t.length)throw Error("Ragged splits may not be empty");if(t[0]<0)throw Error("Ragged splits must be non-negative");if(t[t.length-1]>a)throw Error("Ragged splits must not point past values");for(let e=1;e<t.length;++e)if(t[e-1]>t[e])throw Error("Ragged splits must be sorted in ascending order")}let o=1;for(let e=0;e<t.length-1;++e){o*=t[e];let r=t[e+1];for(let t=1;t<o+1;++t)i[e].push(t*r)}for(let n=0;n<e.length;++n){let o=e[n],l=e[n]+1;for(let e=0;e<r.length;++e){let n=r[e],a=e+t.length-1;if(a>=0){let e=i[a],t=e[e.length-1]-n[o];for(let e=o;e<l;++e)i[a].push(n[e+1]+t)}o=n[o],l=n[l]}l!==o&&(a.push([o,l]),s+=l-o)}return{outSplits:i,valueSlices:a,numValues:s}}(s,i,e,n[0]),g=function(e){let t=[];for(let r=0;r<e.length;++r){let n=e[r].length,a=nP.util.getArrayFromDType("int32",n);t.push(a),e[r].forEach((e,t)=>a[t]=e)}return t}(c),y=((l=n.slice())[0]=m,u=nP.util.getArrayFromDType(a,nP.util.sizeFromShape(l)),p=0===(h=r.length)?0:h/n[0],!function(e,t,r,n,a,s){let i=d6(t,2)[1],o=d6(s,2)[1],l=0;for(let t of r)for(let r=t[0];r<t[1];++r){for(let t=0;t<n;++t)a[l*o+t]=e[r*i+t];++l}}(r,n,f,p,u,l),[u,l]);return[g,y[0],y[1]]}function d8(e,t,r,n,a,s,i){if(t.length>1)throw Error("starts must be a scalar or vector");if(a.length>1)throw Error("limits must be a scalar or vector");if(i.length>1)throw Error("deltas must be a scalar or vector");let o=0===t.length,l=0===a.length,u=0===i.length,h=[];o||h.push(t[0]),l||h.push(a[0]),u||h.push(i[0]);for(let e=1;e<h.length;++e)if(h[e]!==h[e-1])throw Error("starts, limits, and deltas must have the same shape");let p=0===h.length?1:h[0],d=nP.util.getArrayFromDType("int32",p+1);d[0]=0;for(let t=0;t<p;++t){let r,a=o?e[0]:e[t],i=l?n[0]:n[t],h=u?s[0]:s[t];if(0===h)throw Error("Requires delta != 0");if(h>0&&i<a||h<0&&i>a)r=0;else if((r=Math.ceil(Math.abs((i-a)/h)))>0x7fffffff)throw Error("Requires ((limit - start) / delta) <= 2147483647");d[t+1]=d[t]+r}let c=d[p],f=nP.util.getArrayFromDType(r,c),m=0;for(let t=0;t<p;++t){let r=d[t+1]-d[t],n=o?e[0]:e[t],a=u?s[0]:s[t];for(let e=0;e<r;++e)f[m++]=n,n+=a}return[d,f]}var tL=tL,d9=tL.RowPartitionType;class d7{constructor(e,t,r,n,a,s,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=n,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=tL.getRowPartitionTypesHelper(u),this.raggedRank=tL.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===d9.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===d9.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case d9.VALUE_ROWIDS:return d7.getMaxWidthValueRowID(t);case d9.ROW_SPLITS:return d7.getMaxWidthRowSplit(t);default:throw Error(`Cannot handle partition type ${d9[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(0===t||1===t)return 0;let r=0;for(let n=0;n<t-1;++n){let t=e[n+1]-e[n];t>r&&(r=t)}return r}static getMaxWidthValueRowID(e){let t=e.length;if(0===t)return 0;let r=0,n=e[0],a=0;for(let s=1;s<t;++s){let t=e[s];t!==n&&(n=t,a=Math.max(s-r,a),r=s)}return Math.max(t-r,a)}tensorShapeFromTensor(e,t,r=!0){if(0===t.length){if(-1===e[0])return[];throw Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return ct(e,r)}calculateOutputSize(e){let t=this.valuesShape,r=this.defaultValueShape;tL.validateDefaultValueShape(r,t);let n=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=tL.combineRaggedTensorToTensorShapes(this.raggedRank,n,t);a[0]<0&&(a[0]=e);for(let e=1;e<=this.raggedRank;++e)a[e]<0&&(a[e]=this.getMaxWidth(e));return a}calculateFirstParentOutputIndex(e,t,r){let n=Math.min(e,r),a=[],s=0;for(let e=0;e<n;++e,s+=t)a.push(s);for(let t=n;t<e;++t)a.push(-1);return nP.util.assert(a.length===e,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(e,t,r,n){let a=e.length,s=[];for(let i=0;i<a-1;++i){let a=e[i+1]-e[i],o=Math.min(n,a),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)s.push(l),l+=r;for(let e=0;e<a-o;++e)s.push(-1)}if(a>0&&s.length!==e[a-1])throw Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,r,n){let a=e.length,s=[];if(0===a)return[];let i=0,o=e[0];if(o>=t.length)throw Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];s.push(l);for(let u=1;u<a;++u){let a=e[u];if(a===o)l>=0&&(++i<n?l+=r:l=-1);else{if(i=0,o=a,a>=t.length)throw Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);l=t[a]}s.push(l)}if(s.length!==e.length)throw Error("Invalid row ids.");return s}calculateOutputIndex(e,t,r,n){let a=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case d9.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,r,n);case d9.ROW_SPLITS:if(a.length-1>t.length)throw Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,r,n);default:throw Error(`Unsupported partition type: ${d9[s]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case d9.FIRST_DIM_SIZE:return e[0];case d9.VALUE_ROWIDS:throw Error("Cannot handle VALUE_ROWIDS in first dimension.");case d9.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw Error(`Cannot handle type ${d9[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),r=Array(this.raggedRank+1);r[r.length-1]=1;for(let e=r.length-2;e>=0;--e)r[e]=r[e+1]*t[e+1];let n=ct(t,!1),a=nP.util.getArrayFromDType(this.valuesDType,nP.util.sizeFromShape(n));if(r[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,r[0],t[0]);for(let e=1;e<=this.raggedRank;++e)s=this.calculateOutputIndex(e-1,s,r[e],t[e]);this.setOutput(this.raggedRank,s,a,n)}return[n,a]}setOutput(e,t,r,n){if(0===r.length)return;let a=this.values,s=n.slice();s=s.slice(e+1);let i=nP.util.sizeFromShape(s),o=t.length,l=this.defaultValue;if(l.length!==i&&1!==l.length){let e=this.defaultValueShape;(0,nz.tidy)(()=>{let t=(0,V.reshape)(l,e);l=(0,rP.broadcastTo)(t,s).dataSync()})}let u=0,h=0,p=0;for(let e=0;e<=o;++e){let n=e<o?t[e]:-1;if(n===p){++p;continue}if(h<p){let e=a.subarray(u*i);ce(r.subarray(h*i),e,(p-h)*i)}if(e>=o&&(n=Math.floor(r.length/i)),n>p)if(1===this.defaultValue.length)r.subarray(p*i,n*i).fill(this.defaultValue[0]),p=n;else for(;n>p;)ce(r.slice(p*i),l,i),++p;n<0?(u=e+1,h=p):(u=e,p=(h=p)+1)}}}function ce(e,t,r){for(let n=0;n<r;n++)e[n]=t[n]}function ct(e,t){let r=[];for(let n of e){if(n<0){if(!t)throw Error(`Dimension ${n} must be >= 0`);if(n<-1)throw Error(`Dimension ${n} must be >= -1`);n=-1}r.push(n)}return r}function cr(e,t,r,n,a,s,i,o,l,u){return new d7(e,t,r,n,a,s,i,o,l,u).compute()}function cn(e,t,r,n){let a=e===t,s=e<t&&r<0,i=t<e&&r>1;if(a||s||i)return nP.util.makeZerosTypedArray(0,n);let o=Math.abs(Math.ceil((t-e)/r)),l=nP.util.makeZerosTypedArray(o,n);t<e&&1===r&&(r=-1),l[0]=e;for(let e=1;e<l.length;e++)l[e]=l[e-1]+r;return l}let ca=p5(e=>1/Math.sqrt(e)),cs=p9(C.Rsqrt,ca),ci={kernelName:C.Rsqrt,backendName:"cpu",kernelFunc:cs};function co(e,t,r,n,a,s,i,o,l,u){let h=e.values,p=t.values;if(0===n)return(0,pA.buffer)(r,t.dtype);let d=l instanceof rI.TensorBuffer?l:(0,pA.buffer)([n/a,a],t.dtype);"string"==typeof l||"number"==typeof l?d.values.fill(l):"boolean"==typeof l&&d.values.fill(+l);for(let e=0;e<s;e++){let s=[],l=0;for(let t=0;t<i;t++){let r=h[e*i+t];s.push(r),l+=r*o[t]}if(l<0||l>=n/a)throw Error(`Invalid indices: ${s} does not index into ${r}`);for(let r=0;r<a;r++)u?d.values[l*a+r]+=p[e*a+r]:d.values[l*a+r]=0===t.rank?p[0]:p[e*a+r]}return d}let cl=p5(e=>1/(1+Math.exp(-e))),cu=p8(C.Sigmoid,e=>1/(1+Math.exp(-e))),ch={kernelName:C.Sigmoid,backendName:"cpu",kernelFunc:cu};var tL=tL,cp=t9;function cd(e,t,r,n,a){let s=cp.isSliceContinous(n,t,r),i=nP.util.sizeFromShape(r),o=nP.util.computeStrides(n);if(s){let r=cp.computeFlatOffset(t,o);return"string"===a?e.slice(r,r+i):e.subarray(r,r+i)}let l="string"===a?tL.fromUint8ToStringArray(e):e,u=(0,pA.buffer)(n,a,l),h=(0,pA.buffer)(r,a);for(let e=0;e<h.size;++e){let r=h.indexToLoc(e),n=r.map((e,r)=>e+t[r]);h.set(u.get(...n),...r)}return"string"===a?tL.fromStringArrayToUint8(h.values):h.values}function cc(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{begin:s,size:i}=n;pF(a,"slice");let[o,l]=cp.parseSliceParams(a,s,i);cp.assertParamsValid(a,o,l);let u=cd(r.data.get(a.dataId).values,o,l,a.shape,a.dtype);return r.makeTensorInfo(l,a.dtype,u)}let cf={kernelName:C.Slice,backendName:"cpu",kernelFunc:cc};var tL=tL;function cm(e,t,r,n,a,s,i){let o=t[0],l=s[0],u=Array(l),h=Array(o),p=t[1];if(0===l){if(0!==o)throw Error(tL.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));return[nP.util.getArrayFromDType(r,0),[0,p],nP.util.getArrayFromDType(a,0),u,h]}let d=!0,c=0,f=Array(l).fill(0);for(let t=0;t<o;++t){let r=e[t*p];if(r<0)throw Error(tL.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,r));if(r>=l)throw Error(tL.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,r,l));++f[r],d=d&&r>=c,c=r}let m=!0;for(let e=0;e<l;++e){let t=0===f[e];u[e]=t,m=m&&!t,f[e]=Math.max(f[e],1),e>0&&(f[e]+=f[e-1])}if(m&&d){for(let e=0;e<o;++e)h[e]=e;return[e,[o,p],n,u,h]}{let t=f[l-1],s=nP.util.getArrayFromDType(r,t*p),d=nP.util.getArrayFromDType(a,t),c=Array(l).fill(0);for(let t=0;t<o;++t){let r=e[t*p],a=c[r],i=(0===r?0:f[r-1])+a;c[r]++;for(let r=0;r<p;++r)s[i*p+r]=e[t*p+r];d[i]=n[t],h[t]=i}for(let e=0;e<l;++e)if(0===c[e]){let t=0===e?0:f[e-1];s[t*p+0]=e;for(let e=1;e<p;++e)s[t*p+e]=0;d[t]=i}return[s,[t,p],d,u,h]}}var tL=tL;function cg(e,t,r,n,a){let s=nP.util.sizeFromShape(n),i=t[0],o=a.length,l=[],u=1,h=-1;for(let e=0;e<o;++e){let t=a[e];if(-1===t){if(-1!==h)throw Error(tL.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(h,e));h=e,l.push(1)}else{if(t<0)throw Error(tL.getSparseReshapeNegativeOutputDimErrorMessage(e,t));u*=t,l.push(t)}}if(-1!==h){if(u<=0)throw Error(tL.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let e=Math.trunc(s/u);if(u*e!==s)throw Error(tL.getSparseReshapeInputOutputMultipleErrorMessage(n,l));l[h]=e}if(nP.util.sizeFromShape(l)!==s)throw Error(tL.getSparseReshapeInputOutputMismatchErrorMessage(n,l));let p=n.length,d=[];if(p>0){d[p-1]=1;for(let e=p-2;e>=0;--e)d[e]=d[e+1]*n[e+1]}let c=[];if(o>0){c[o-1]=1;for(let e=o-2;e>=0;--e)c[e]=c[e+1]*l[e+1]}let f=nP.util.getArrayFromDType(r,i*o);for(let t=0;t<i;++t){let r=0;for(let n=0;n<p;++n)r+=e[t*p+n]*d[n];for(let e=0;e<o;++e)f[t*o+e]=Math.trunc(r/c[e]),r%=c[e]}return[f,[i,o],l]}var tL=tL;function cy(e,t,r,n,a,s=!1,i=0){let o=n.length,l=[t[0],e.length/t[0]],u=l[1],h=o>0?a[o-1]+1:0;if(h<0)throw Error(tL.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=t.slice();p[0]=h;let d=p.reduce((e,t)=>e*t,1),c=nP.util.getArrayFromDType(r,d);if(0===o)return h>0&&c.fill(i),[c,p];if(h<=0)throw Error(tL.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[0];for(;;){let t=0;if(m<o){if(y===(t=a[m])){++m;continue}if(y>=t)throw Error(tL.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=h)throw Error(tL.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,h));y>g&&c.fill(i,g*u,y*u);for(let t=f;t<m;++t){let r=n[t];if(r<0||r>=l[0])throw Error(tL.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,n[t],l[0]));for(let t=0;t<u;t++)c[y*u+t]+=e[r*u+t]}if(s)for(let e=0;e<u;e++)c[y*u+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>o)break}return g<h&&c.fill(i,g*u,h*u),[c,p]}let cb=p5(e=>Math.sqrt(e)),cx=p8(C.Sqrt,e=>Math.sqrt(e)),cv={kernelName:C.Sqrt,backendName:"cpu",kernelFunc:cx},cw=pz((e,t)=>{let r=e-t;return r*r}),cS=pX(C.SquaredDifference,cw),cN={kernelName:C.SquaredDifference,backendName:"cpu",kernelFunc:cS},ck=p5((e,t)=>{let{pattern:r,replaceGlobal:n,rewrite:a}=t;return e.replace(new RegExp(r,n?"g":""),a)}),cI=p9(C.StaticRegexReplace,ck),cT={kernelName:C.StaticRegexReplace,backendName:"cpu",kernelFunc:cI};function cC(e,t,r,n){let a=(0,pA.buffer)(e,t.dtype);for(let e=0;e<a.size;e++){let s=a.indexToLoc(e),i=Array(s.length);for(let e=0;e<i.length;e++)i[e]=s[e]*r[e]+n[e];a.set(t.get(...i),...s)}return a}class cE{constructor(e,t,r,n,a,s){this.separator=nP.util.encodeString(e),this.nGramWidths=t,this.leftPad=nP.util.encodeString(r),this.rightPad=nP.util.encodeString(n),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){return Math.max(0,e+2*this.getPadWidth(t)-t+1)}createNGrams(e,t,r,n,a,s){for(let i=0;i<a;++i){let o,l=this.getPadWidth(s),u=Math.max(0,l-i),h=Math.max(0,l-(a-(i+1))),p=s-(u+h),d=t+(u>0?0:i-l);o=0+u*this.leftPad.length;for(let t=0;t<p;++t)o+=e[d+t].length;o+=h*this.rightPad.length,o+=(u+h+p-1)*this.separator.length,r[n+i]=new Uint8Array(o);let c=r[n+i],f=0,m=e=>e.forEach(e=>c[f++]=e);for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<p-1;++t)m(e[d+t]),m(this.separator);if(p>0){m(e[d+p-1]);for(let e=0;e<h;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<h-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){let r=e.length,n=t.length;if(n>0){let e=t[0];if(0!==e)throw Error(`First split value must be 0, got ${e}`);for(let a=1;a<n;++a){let n=t[a]>=e;if(!(n=n&&t[a]<=r))throw Error(`Invalid split value ${t[a]}, must be in [${e}, ${r}]`);e=t[a]}if(e!==r)throw Error(`Last split value must be data size. Expected ${r}, got ${e}`)}let a=n-1,s=nP.util.getArrayFromDType("int32",n);if(0===r||0===n){let e=Array(r);for(let e=0;e<=a;++e)s[e]=0;return[e,s]}s[0]=0;for(let e=1;e<=a;++e){let r=t[e]-t[e-1],n=0;this.nGramWidths.forEach(e=>{n+=this.getNumNGrams(r,e)}),this.preserveShort&&r>0&&0===n&&(n=1),s[e]=s[e-1]+n}let i=Array(s[a]);for(let r=0;r<a;++r){let n=t[r],a=s[r];if(this.nGramWidths.forEach(s=>{let o=t[r+1]-t[r],l=this.getNumNGrams(o,s);this.createNGrams(e,n,i,a,l,s),a+=l}),this.preserveShort&&a===s[r]){let s=t[r+1]-t[r];if(0===s)continue;let o=s+2*this.padWidth;this.createNGrams(e,n,i,a,1,o)}}return[i,s]}}function c$(e,t,r,n,a,s,i,o){return new cE(r,n,a,s,i,o).compute(e,t)}function cA(e,t,r){let n=e.length,a=[],s=0,i=0,o=Array(n);for(let l=0;l<n;++l){let n=a.length;!function(e,t,r,n){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)n.push(e.subarray(t,t+1));return}if(1===t.length){let a=t[0],s=e.indexOf(a);for(;-1!==s;){let t=e.subarray(0,s);r&&0===t.length||n.push(t),s=(e=e.subarray(s+1)).indexOf(a)}r&&0===e.length||n.push(e);return}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){let t=e.subarray(a,s);r&&0===t.length||n.push(t),a=s+1}}(e[l],t,r,a);let u=a.length-n;o[l]=u,s+=u,i=Math.max(i,u)}let l=nP.util.getArrayFromDType("int32",2*s),u=Array(s),h=[n,i],p=0;for(let e=0;e<n;++e)for(let t=0;t<o[e];++t)l[2*p]=e,l[2*p+1]=t,u[p]=a[p],++p;return[l,u,h]}function cR(e,t){let r=nP.util.getArrayFromDType("int32",e.length);for(let n=0;n<e.length;++n)r[n]=nP.util.fingerPrint64(e[n]).modulo(t).getLowBitsUnsigned();return r}let cD=pz((e,t)=>e-t),cF=pZ((e,t,r,n)=>({real:e-r,imag:t-n})),cO=pX(C.Sub,cD,cF),c_={kernelName:C.Sub,backendName:"cpu",kernelFunc:cO};function cM(e,t){let r=Array(e.rank);for(let n=0;n<r.length;n++)r[n]=e.shape[n]*t[n];let n=(0,pA.buffer)(r,e.dtype);for(let t=0;t<n.values.length;++t){let r=n.indexToLoc(t),a=Array(e.rank);for(let t=0;t<a.length;t++)a[t]=r[t]%e.shape[t];let s=e.locToIndex(a);n.values[t]=e.values[s]}return n}let cL=(e,t)=>{let r=t.value-e.value;return 0===r?e.index-t.index:r};function cz(e,t,r,n,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=nP.util.getTypedArrayFromDType(r,i*n),u=nP.util.getTypedArrayFromDType("int32",i*n);for(let t=0;t<i;t++){let r=t*o,s=e.subarray(r,r+o),i=Array(s.length);s.forEach((e,t)=>i[t]={value:e,index:t}),n<i.length&&(!function e(t,r,n=0,a=t.length-1){for(;a>n;){if(a-n>600){let s=a-n+1,i=r-n+1,o=Math.log(s),l=.5*Math.exp(2*o/3),u=.5*Math.sqrt(o*l*(s-l)/s)*Math.sign(i-s/2),h=Math.max(n,Math.floor(r-i*l/s+u)),p=Math.min(a,Math.floor(r+(s-i)*l/s+u));e(t,r,h,p)}let s=t[r],i=n,o=a;for(nP.util.swap(t,n,r),cL(t[a],s)>0&&nP.util.swap(t,n,a);i<o;){for(nP.util.swap(t,i,o),i++,o--;0>cL(t[i],s);)i+=1;for(;cL(t[o],s)>0;)o-=1}0===cL(t[n],s)?nP.util.swap(t,n,o):(o+=1,nP.util.swap(t,o,a)),o<=r&&(n=o+1),r<=o&&(a=o-1)}}(i,n),i=i.slice(0,n)),a&&i.sort(cL);let h=t*n,p=l.subarray(h,h+n),d=u.subarray(h,h+n);for(let e=0;e<n;e++)p[e]=i[e].value,d[e]=i[e].index}let h=t.slice();return h[h.length-1]=n,[(0,pA.buffer)(h,r,l),(0,pA.buffer)(h,"int32",u)]}function cP(e,t,r,n){let a=nP.util.parseAxisParam(t,r)[0],s=[1,r[0],1];for(let e=0;e<a;e++)s[0]*=r[e];s[1]=r[a];for(let e=a+1;e<r.length;e++)s[2]*=r[e];let i=new Map,o=new Int32Array(r[a]),l=new rI.TensorBuffer(s,n,e),u=[],h=1===s[0]&&1===s[2];for(let t=0;t<r[a];t++){let r;if(h)r=e[t].toString();else{let e=[];for(let r=0;r<s[0];r++)for(let n=0;n<s[2];n++)e.push(l.get(r,t,n));r=e.join(",")}let n=i.get(r);if(null!=n)o[t]=n;else{let e=i.size;i.set(r,e),o[t]=e,u.push(t)}}let p=s.slice();p[1]=i.size;let d=new rI.TensorBuffer(p,n);u.forEach((e,t)=>{for(let r=0;r<s[0];r++)for(let n=0;n<s[2];n++)d.set(l.get(r,e,n),r,t,n)});let c=r.slice();return c[a]=p[1],{outputValues:d.values,outputShape:c,indices:o}}e.s(["addImpl",0,pY,"bincountImpl",()=>p1,"bincountReduceImpl",()=>p2,"bitwiseAndImpl",0,p3,"castImpl",()=>pH,"ceilImpl",0,p7,"concatImpl",()=>dr,"equalImpl",0,dn,"expImpl",0,di,"expm1Impl",0,dh,"floorDivImpl",0,dg,"floorImpl",0,dc,"gatherNdImpl",()=>dx,"gatherV2Impl",()=>dv,"greaterEqualImpl",0,dk,"greaterImpl",0,dw,"lessEqualImpl",0,dA,"lessImpl",0,dC,"linSpaceImpl",()=>dF,"logImpl",0,dO,"maxImpl",()=>dL,"maximumImpl",0,dz,"minimumImpl",0,dV,"multiplyImpl",0,dG,"negImpl",()=>dK,"notEqualImpl",0,dZ,"prodImpl",()=>d3,"raggedGatherImpl",()=>d5,"raggedRangeImpl",()=>d8,"raggedTensorToTensorImpl",()=>cr,"rangeImpl",()=>cn,"rsqrtImpl",0,ca,"scatterImpl",()=>co,"sigmoidImpl",0,cl,"simpleAbsImpl",()=>pM,"sliceImpl",()=>cd,"sparseFillEmptyRowsImpl",()=>cm,"sparseReshapeImpl",()=>cg,"sparseSegmentReductionImpl",()=>cy,"sqrtImpl",0,cb,"squaredDifferenceImpl",0,cw,"staticRegexReplaceImpl",0,ck,"stridedSliceImpl",()=>cC,"stringNGramsImpl",()=>c$,"stringSplitImpl",()=>cA,"stringToHashBucketFastImpl",()=>cR,"subImpl",0,cD,"tileImpl",()=>cM,"topKImpl",()=>cz,"transposeImpl",()=>d0,"uniqueImpl",()=>cP],81235);var cB=e.i(81235);(0,nz.registerBackend)("cpu",()=>new p_,1),e.s([],81217);let cV=p8(C.Elu,e=>e>=0?e:Math.exp(e)-1),cW={kernelName:C.Elu,backendName:"cpu",kernelFunc:cV};function cU(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{alpha:s}=n;pF([a],"leakyRelu");let i=nP.util.sizeFromShape(a.shape),o=r.data.get(a.dataId).values,l=nP.util.getTypedArrayFromDType("float32",i);for(let e=0;e<o.length;e++)l[e]=o[e]<0?s*o[e]:o[e];return r.makeTensorInfo(a.shape,"float32",l)}let cG={kernelName:C.LeakyRelu,backendName:"cpu",kernelFunc:cU},cq=pz((e,t)=>e<0?t*e:e);function cH(e){let{inputs:t,backend:r}=e,{x:n,alpha:a}=t;pF([n,a],"prelu");let s=r.data.get(n.dataId).values,i=r.data.get(a.dataId).values,[o,l]=cq(n.shape,a.shape,s,i,"float32");return r.makeTensorInfo(l,"float32",o)}let cj={kernelName:C.Prelu,backendName:"cpu",kernelFunc:cH},cK=p8(C.Relu,e=>Math.max(0,e)),cX={kernelName:C.Relu,backendName:"cpu",kernelFunc:cK},cZ=p8(C.Relu6,e=>Math.min(Math.max(0,e),6)),cY={kernelName:C.Relu6,backendName:"cpu",kernelFunc:cZ};function cJ(e,t,r,n,a){if("linear"===r)return pW({inputs:{x:t},backend:e});if("relu"===r)return cK({inputs:{x:t},backend:e});if("elu"===r)return cV({inputs:{x:t},backend:e});if("relu6"===r)return cZ({inputs:{x:t},backend:e});if("prelu"===r)return cH({inputs:{x:t,alpha:n},backend:e});else if("leakyrelu"===r)return cU({inputs:{x:t},backend:e,attrs:{alpha:a}});else if("sigmoid"===r)return cu({inputs:{x:t},backend:e});throw Error(`Activation ${r} has not been implemented for the CPU backend.`)}var cQ=B;function c0(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{shape:s}=n,i=nP.util.sizeFromShape(a.shape),o=nP.util.inferFromImplicitShape(s,i),l=nP.util.sizeFromShape(o);nP.util.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),r.incRef(a.dataId);let u=r.data.get(a.dataId);if(null!=u.complexTensorInfos){let e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}let c1={kernelName:C.Reshape,backendName:"cpu",kernelFunc:c0};function c2(e){let{inputs:t,backend:r,attrs:n}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=n;pF([a,s],"matMul");let l=a.shape.length,u=s.shape.length,h=i?a.shape[l-2]:a.shape[l-1],p=o?s.shape[u-1]:s.shape[u-2],d=i?a.shape[l-1]:a.shape[l-2],c=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=nP.util.sizeFromShape(f),y=nP.util.sizeFromShape(m),b=cQ.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,c]);nP.util.assert(h===p,()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=c0({inputs:{x:a},backend:r,attrs:{shape:i?[g,h,d]:[g,d,h]}}),v=c0({inputs:{x:s},backend:r,attrs:{shape:o?[y,c,p]:[y,p,c]}}),w=i?x.shape[1]:x.shape[2],S=i?x.shape[2]:x.shape[1],N=o?v.shape[1]:v.shape[2],k=Math.max(g,y),I=r.data.get(x.dataId).values,T=r.data.get(v.dataId).values,C=nP.util.computeStrides(x.shape),E=nP.util.computeStrides(v.shape),[$,A,R]=i?[C[0],1,C[1]]:[C[0],C[1],1],[D,F,O]=o?[1,E[1],E[0]]:[E[1],1,E[0]],_=S*N,M=(0,pA.buffer)([k,S,N],x.dtype),L=M.values,z=r.blockSize;for(let e=0;e<k;e++){let t=e%g,r=e%y;for(let n=0;n<S;n+=z){let a=Math.min(n+z,S);for(let s=0;s<N;s+=z){let i=Math.min(s+z,N);for(let o=0;o<w;o+=z){let l=Math.min(o+z,w);for(let u=n;u<a;u++)for(let n=s;n<i;n++){let a=0;for(let e=o;e<l;e++)a+=I[t*$+u*A+e*R]*T[e*D+n*F+r*O];L[e*_+(u*N+n)]+=a}}}}}return r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(v),r.makeTensorInfo(b,M.dtype,M.values)}let c3={kernelName:C.BatchMatMul,backendName:"cpu",kernelFunc:c2},c4={kernelName:C._FusedMatMul,backendName:"cpu",kernelFunc:function(e){let t,r,n,{inputs:a,backend:s,attrs:i}=e,{a:o,b:l,bias:u,preluActivationWeights:h}=a,{transposeA:p,transposeB:d,activation:c,leakyreluAlpha:f}=i,m=[];for(let e of(t=c2({inputs:{a:o,b:l},attrs:{transposeA:p,transposeB:d},backend:s}),u&&(r=pQ({inputs:{a:t,b:u},backend:s}),m.push(t),t=r),c&&(n=cJ(s,t,c,h,f),m.push(t),t=n),m))s.disposeIntermediateTensorInfo(e);return t}},c6=p8(C.Acos,e=>Math.acos(e)),c5={kernelName:C.Acos,backendName:"cpu",kernelFunc:c6},c8=p8(C.Acosh,e=>Math.acosh(e)),c9={kernelName:C.Acosh,backendName:"cpu",kernelFunc:c8},c7={kernelName:C.AddN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e;pF(t,"addN");let n=t.map(e=>r.data.get(e.dataId).values),a=(0,pA.buffer)(t[0].shape,t[0].dtype),s=a.values;for(let e=0;e<t.length;e++){let t=n[e];for(let e=0;e<s.length;e++)s[e]+=t[e]}return r.makeTensorInfo(a.shape,a.dtype,a.values)}};var tL=tL;let fe={kernelName:C.All,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s,keepDims:i}=n;pF(a,"all");let o=nP.util.parseAxisParam(s,a.shape),l=o,u=tL.getAxesPermutation(l,a.shape.length),h=a;null!=u&&(h=d1({inputs:{x:a},backend:r,attrs:{perm:u}}),l=tL.getInnerMostAxes(l.length,a.shape.length)),tL.assertAxesAreInnerMostDims("all",l,h.shape.length);let[p,d]=tL.computeOutAndReduceShapes(h.shape,l),c=nP.util.sizeFromShape(d),f=nP.util.makeZerosTypedArray(nP.util.sizeFromShape(p),h.dtype),m=r.data.get(h.dataId).values;for(let e=0;e<f.length;++e){let t=e*c,r=m[t];for(let e=0;e<c;++e){let n=m[t+e];r=r&&n}f[e]=r}null!=u&&r.disposeIntermediateTensorInfo(h);let g=r.makeTensorInfo(p,h.dtype,f);if(i){let e=c0({inputs:{x:g},backend:r,attrs:{shape:tL.expandShapeToKeepDim(p,o)}});return r.disposeIntermediateTensorInfo(g),e}return g}};var tL=tL;let ft={kernelName:C.Any,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s,keepDims:i}=n;pF(a,"any");let o=nP.util.parseAxisParam(s,a.shape),l=o,u=tL.getAxesPermutation(l,a.shape.length),h=a;null!=u&&(h=d1({inputs:{x:a},backend:r,attrs:{perm:u}}),l=tL.getInnerMostAxes(l.length,a.shape.length)),tL.assertAxesAreInnerMostDims("any",l,h.shape.length);let[p,d]=tL.computeOutAndReduceShapes(h.shape,l),c=nP.util.sizeFromShape(d),f=nP.util.makeZerosTypedArray(nP.util.sizeFromShape(p),h.dtype),m=r.data.get(h.dataId).values;for(let e=0;e<f.length;++e){let t=e*c,r=m[t];for(let e=0;e<c;++e){let n=m[t+e];r=r||n}f[e]=r}null!=u&&r.disposeIntermediateTensorInfo(h);let g=r.makeTensorInfo(p,h.dtype,f);if(i){let e=c0({inputs:{x:g},backend:r,attrs:{shape:tL.expandShapeToKeepDim(p,o)}});return r.disposeIntermediateTensorInfo(g),e}return g}};var tL=tL;let fr={kernelName:C.ArgMax,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s}=n;pF(a,"argMax");let i=nP.util.parseAxisParam(s,a.shape),o=tL.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(u.push(l=d1({inputs:{x:a},backend:r,attrs:{perm:o}})),i=tL.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],tL.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[h,p]=tL.computeOutAndReduceShapes(l.shape,i),d=nP.util.sizeFromShape(h),c=nP.util.makeZerosTypedArray(d,"int32"),f=nP.util.sizeFromShape(p),m=r.data.get(l.dataId).values;for(let e=0;e<c.length;++e){let t=e*f,r=m[t],n=0;for(let e=0;e<f;++e){let a=m[t+e];a>r&&(r=a,n=e)}c[e]=n}return u.forEach(e=>r.disposeIntermediateTensorInfo(e)),r.makeTensorInfo(h,"int32",c)}};var tL=tL;let fn={kernelName:C.ArgMin,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s}=n;pF(a,"argMin");let i=nP.util.parseAxisParam(s,a.shape),o=tL.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(u.push(l=d1({inputs:{x:a},backend:r,attrs:{perm:o}})),i=tL.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],tL.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[h,p]=tL.computeOutAndReduceShapes(l.shape,i),d=nP.util.sizeFromShape(h),c=nP.util.makeZerosTypedArray(d,"int32"),f=nP.util.sizeFromShape(p),m=r.data.get(l.dataId).values;for(let e=0;e<c.length;++e){let t=e*f,r=m[t],n=0;for(let e=0;e<f;++e){let a=m[t+e];a<r&&(r=a,n=e)}c[e]=n}return u.forEach(e=>r.disposeIntermediateTensorInfo(e)),r.makeTensorInfo(h,"int32",c)}},fa=p8(C.Asin,e=>Math.asin(e)),fs={kernelName:C.Asin,backendName:"cpu",kernelFunc:fa},fi=p8(C.Asinh,e=>Math.asinh(e)),fo={kernelName:C.Asinh,backendName:"cpu",kernelFunc:fi},fl=p8(C.Atan,e=>Math.atan(e)),fu={kernelName:C.Atan,backendName:"cpu",kernelFunc:fl},fh=pz((e,t)=>Math.atan2(e,t)),fp=pX(C.Atan2,fh),fd={kernelName:C.Atan2,backendName:"cpu",kernelFunc:fp},fc=p8(C.Atanh,e=>Math.atanh(e)),ff={kernelName:C.Atanh,backendName:"cpu",kernelFunc:fc};var tL=tL;function fm(e,t,r,n,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,h=a.effectiveFilterHeight,p=a.effectiveFilterWidth,d=a.padInfo.top,c=a.padInfo.left,f="max"===s?-1/0:1/0,m=(0,pA.buffer)(a.outShape,r),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],x=a.outShape[3];for(let t=0;t<a.batchSize;++t){let r=t*y,m=t*n[0];for(let t=0;t<a.inChannels;++t)for(let y=0;y<a.outHeight;++y){let v=y*i-d,w=Math.max(0,v),S=Math.min(a.inHeight,h+v),N=r+y*b;for(let r=0;r<a.outWidth;++r){let i=r*o-c,h=Math.max(0,i),d=Math.min(a.inWidth,p+i),y=f,b=0,v=0;for(let r=w;r<S;r+=l){let a=m+r*n[1];for(let r=h;r<d;r+=u){let i=e[a+r*n[2]+t];"max"===s&&i>y?y=i:"avg"===s&&(b+=i,v++)}if(isNaN(y))break}g[N+r*x+t]="avg"===s?b/v:y}}}return m}function fg(e,t,r,n,a=!1,s=!1){let i=(0,pA.buffer)(n.outShape,"int32"),o=n.strideHeight,l=n.strideWidth,u=n.dilationHeight,h=n.dilationWidth,p=n.effectiveFilterHeight,d=n.effectiveFilterWidth,c=n.padInfo.top,f=n.padInfo.left,m=(0,pA.buffer)(t,r,e);for(let e=0;e<n.batchSize;++e)for(let t=0;t<n.inChannels;++t)for(let r=0;r<n.outHeight;++r){let g=r*o-c,y=g;for(;y<0;)y+=u;let b=Math.min(n.inHeight,p+g);for(let o=0;o<n.outWidth;++o){let p=o*l-f,c=p;for(;c<0;)c+=h;let x=Math.min(n.inWidth,d+p),v=-1/0,w=-1;for(let r=y;r<b;r+=u){let i=r-g;for(let o=c;o<x;o+=h){let l=o-p,u=m.get(e,r,o,t);u>v&&(v=u,w=a?s?((e*n.inHeight+r)*n.inWidth+o)*n.inChannels+t:(r*n.inWidth+o)*n.inChannels+t:i*d+l)}}i.set(w,e,r,o,t)}}return i}function fy(e,t,r,n,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,h=a.dilationHeight,p=a.dilationWidth,d=a.effectiveFilterDepth,c=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b="max"===s?-1/0:1/0,x=(0,pA.buffer)(a.outShape,r),v=x.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[2]*a.outShape[3]*a.outShape[4],N=a.outShape[3]*a.outShape[4],k=a.outShape[4];for(let t=0;t<a.batchSize;++t){let r=t*w,x=t*n[0];for(let t=0;t<a.inChannels;++t)for(let w=0;w<a.outDepth;++w){let I=w*i-m,T=I;for(;T<0;)T+=u;let C=Math.min(a.inDepth,d+I),E=r+w*S;for(let r=0;r<a.outHeight;++r){let i=r*o-g,d=i;for(;d<0;)d+=h;let m=Math.min(a.inHeight,c+i),w=E+r*N;for(let r=0;r<a.outWidth;++r){let i=r*l-y,o=i;for(;o<0;)o+=p;let c=Math.min(a.inWidth,f+i),g=w+r*k,S=b,N=0,I=0;for(let r=T;r<C;r+=u){let a=x+r*n[1];for(let r=d;r<m;r+=h){let i=a+r*n[2];for(let r=o;r<c;r+=p){let a=e[i+r*n[3]+t];if("max"===s&&a>S?S=a:"avg"===s&&(N+=a,I++),isNaN(S))break}if(isNaN(S))break}if(isNaN(S))break}v[g+t]="avg"===s?N/Math.max(I,1):S}}}}return x}let fb={kernelName:C.AvgPool,backendName:"cpu",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s}=r;pF(s,"avgPool");let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a;nP.util.assert(tL.eitherStridesOrDilationsAreOne(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);let h=tL.computePool2DInfo(s.shape,i,o,1,l,u);if(1===h.filterWidth&&1===h.filterHeight&&nP.util.arraysEqual(h.inShape,h.outShape))t=pW({inputs:{x:s},backend:n});else{let e=n.data.get(s.dataId).values,r=nP.util.computeStrides(s.shape),a=fm(e,s.shape,s.dtype,r,h,"avg");t=n.makeTensorInfo(h.outShape,s.dtype,a.values)}return t}};var tL=tL;let fx={kernelName:C.AvgPool3D,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=n;pF(a,"avgPool3d");let h=tL.computePool3DInfo(a.shape,s,i,1,o,l,u),p=fy(r.data.get(a.dataId).values,a.shape,a.dtype,nP.util.computeStrides(a.shape),h,"avg");return r.makeTensorInfo(p.shape,"float32",p.values)}};var tL=tL;let fv={kernelName:C.AvgPool3DGrad,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n;pF([a,s],"avgPool3DGrad");let h=tL.computePool3DInfo(s.shape,i,o,1,l,u),p=h.strideDepth,d=h.strideHeight,c=h.strideWidth,f=h.filterDepth,m=h.filterHeight,g=h.filterWidth,y=h.dilationDepth,b=h.dilationHeight,x=h.dilationWidth,v=h.effectiveFilterDepth,w=h.effectiveFilterHeight,S=h.effectiveFilterWidth,N=v-1-h.padInfo.front,k=S-1-h.padInfo.left,I=w-1-h.padInfo.top,T=(0,pA.buffer)(s.shape,"float32"),C=1/(f*m*g),E=r.bufferSync(a);for(let e=0;e<h.batchSize;++e)for(let t=0;t<h.inChannels;++t)for(let r=0;r<h.inDepth;++r)for(let n=0;n<h.inHeight;++n)for(let a=0;a<h.inWidth;++a){let s=r-N,i=n-I,o=a-k,l=0;for(let r=0;r<v;r+=y){let n=(s+r)/p;if(!(n<0)&&!(n>=h.outDepth)&&Math.floor(n)===n)for(let r=0;r<w;r+=b){let a=(i+r)/d;if(!(a<0)&&!(a>=h.outHeight)&&Math.floor(a)===a)for(let r=0;r<S;r+=x){let s=(o+r)/c;s<0||s>=h.outWidth||Math.floor(s)!==s||(l+=E.get(e,n,a,s,t))}}}T.set(l*C,e,r,n,a,t)}return r.makeTensorInfo(T.shape,T.dtype,T.values)}};var tL=tL;let fw={kernelName:C.AvgPoolGrad,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:s}=t;pF([a,s],"avgPoolGrad");let{filterSize:i,strides:o,pad:l}=n,u=tL.computePool2DInfo(s.shape,i,o,1,l),h=u.strideHeight,p=u.strideWidth,d=u.filterHeight,c=u.filterWidth,f=u.dilationHeight,m=u.dilationWidth,g=u.effectiveFilterHeight,y=u.effectiveFilterWidth,b=y-1-u.padInfo.left,x=g-1-u.padInfo.top,v=(0,pA.buffer)(s.shape,"float32"),w=1/(d*c),S=r.data.get(a.dataId).values,N=(0,pA.buffer)(a.shape,"float32",S);for(let e=0;e<u.batchSize;++e)for(let t=0;t<u.inChannels;++t)for(let r=0;r<u.inHeight;++r)for(let n=0;n<u.inWidth;++n){let a=r-x,s=n-b,i=0;for(let r=0;r<g;r+=f){let n=(a+r)/h;if(!(n<0)&&!(n>=u.outHeight)&&Math.floor(n)===n)for(let r=0;r<y;r+=m){let a=(s+r)/p;a<0||a>=u.outWidth||Math.floor(a)!==a||(i+=N.get(e,n,a,t))}}v.set(i*w,e,r,n,t)}return r.makeTensorInfo(v.shape,v.dtype,v.values)}},fS={kernelName:C.FusedBatchNorm,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;nP.util.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),nP.util.assert(null==i||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),nP.util.assert(null==s||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),pF([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=n;null==u&&(u=.001);let h=r.data.get(a.dataId).values,p=r.data.get(o.dataId).values,d=r.data.get(l.dataId).values,c=s?r.data.get(s.dataId).values:new Float32Array([1]),f=i?r.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(h.length),g=f.length,y=c.length,b=d.length,x=p.length,v=0,w=0,S=0,N=0;for(let e=0;e<h.length;++e)m[e]=f[v++]+(h[e]-p[w++])*c[S++]/Math.sqrt(d[N++]+u),v>=g&&(v=0),w>=x&&(w=0),S>=y&&(S=0),N>=b&&(N=0);return r.makeTensorInfo(a.shape,a.dtype,m)}};var tL=tL;let fN={kernelName:C.BatchToSpaceND,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{blockShape:s,crops:i}=n;pF([a],"batchToSpaceND");let o=s.reduce((e,t)=>e*t),l=tL.getReshaped(a.shape,s,o),u=tL.getPermuted(l.length,s.length),h=tL.getReshapedPermuted(a.shape,s,o),p=tL.getSliceBeginCoords(i,s.length),d=tL.getSliceSize(h,i,s.length),c=c0({inputs:{x:a},backend:r,attrs:{shape:l}}),f=d1({inputs:{x:c},backend:r,attrs:{perm:u}}),m=c0({inputs:{x:f},backend:r,attrs:{shape:h}}),g=cc({inputs:{x:m},backend:r,attrs:{begin:p,size:d}});return r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),g}},fk={kernelName:C.Bincount,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,weights:s}=t,{size:i}=n,o=p1(r.data.get(a.dataId).values,r.data.get(s.dataId).values,s.dtype,s.shape,i);return r.makeTensorInfo([i],s.dtype,o)}};var tL=tL;let fI={kernelName:C.BroadcastArgs,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{s0:n,s1:a}=t,s=r.data.get(n.dataId).values,i=r.data.get(a.dataId).values,o=tL.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return r.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},fT=p8(C.ClipByValue,(e,t)=>e>t.clipValueMax?t.clipValueMax:e<t.clipValueMin?t.clipValueMin:e),fC={kernelName:C.ClipByValue,backendName:"cpu",kernelFunc:fT},fE={kernelName:C.ComplexAbs,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,r=e.backend,n=new Float32Array(nP.util.sizeFromShape(t.shape)),a=r.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=r.data.get(s.dataId).values,l=r.data.get(i.dataId).values;for(let e=0;e<o.length;e++){let t=o[e],r=l[e];n[e]=Math.hypot(t,r)}return r.makeOutput(n,t.shape,"float32")}};var tL=tL;function f$(e){let{inputs:t,backend:r}=e,{input:n}=t,a=r.data.get(n.dataId).complexTensorInfos.imag,s=r.data.get(a.dataId).values;return r.makeTensorInfo(a.shape,a.dtype,s)}let fA={kernelName:C.Imag,backendName:"cpu",kernelFunc:f$};function fR(e){let{inputs:t,backend:r,attrs:n}=e,{axis:a}=n,s=nP.util.parseAxisParam(a,t[0].shape)[0],i=t.map(e=>e.shape);tL.assertParamsConsistent(i,s);let o=tL.computeOutShape(t.map(e=>e.shape),s);if(0===nP.util.sizeFromShape(o))return r.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(e=>nP.util.sizeFromShape(e.shape)>0);if(1===l.length)return pW({inputs:{x:l[0]},backend:r});if("complex64"===l[0].dtype){let e=l.map(e=>pG({inputs:{input:e},backend:r})),t=l.map(e=>f$({inputs:{input:e},backend:r})),n=fR({inputs:e,backend:r,attrs:{axis:s}}),a=fR({inputs:t,backend:r,attrs:{axis:s}}),i=pP({inputs:{real:n,imag:a},backend:r});return e.forEach(e=>r.disposeIntermediateTensorInfo(e)),t.forEach(e=>r.disposeIntermediateTensorInfo(e)),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),i}let u=l.map(e=>{let t=nP.util.sizeFromShape(e.shape.slice(s));return c0({inputs:{x:e},backend:r,attrs:{shape:[-1,t]}})}),h=u.map(e=>({vals:r.data.get(e.dataId).values,shape:e.shape}));o=tL.computeOutShape(u.map(e=>e.shape),1);let p=1===u[0].shape[0],d=dr(h,o,t[0].dtype,p),c=tL.computeOutShape(l.map(e=>e.shape),s),f=r.makeTensorInfo(c,t[0].dtype,d);return u.forEach(e=>r.disposeIntermediateTensorInfo(e)),f}let fD={kernelName:C.Concat,backendName:"cpu",kernelFunc:fR};var tL=tL;function fF(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:h}=n;pF([a,s],"conv2d");let p=tL.convertConv2DDataFormat(l),d=tL.computeConv2DInfo(a.shape,s.shape,i,u,o,h,!1,p),c=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,x="channelsLast"===d.dataFormat,v=new rI.TensorBuffer(d.outShape,a.dtype),w=nP.util.computeStrides(a.shape),S=nP.util.computeStrides(s.shape),N=w[0],k=x?w[1]:w[2],I=x?w[2]:1,T=x?1:w[1],C=v.strides[0],E=x?v.strides[1]:v.strides[2],$=x?v.strides[2]:1,A=x?1:v.strides[1],R=r.data.get(a.dataId).values,D=r.data.get(s.dataId).values,F=v.values;for(let e=0;e<d.batchSize;++e){let t=e*N,r=e*C;for(let e=0;e<d.outHeight;++e){let n=r+e*E,a=e*d.strideHeight-b;for(let e=0;e<c;++e){let r=a+e*m;if(r<0||r>=d.inHeight)continue;let s=e*S[0],i=t+r*k;for(let e=0;e<d.outWidth;++e){let t=n+e*$,r=e*d.strideWidth-y;for(let e=0;e<f;++e){let n=r+e*g;if(n<0||n>=d.inWidth)continue;let a=s+e*S[1],o=i+n*I,l=a;for(let e=0;e<d.inChannels;++e){let r=R[o+e*T];for(let e=0;e<d.outChannels;++e)F[t+e*A]+=r*D[l+e];l+=d.outChannels}}}}}}return r.makeTensorInfo(v.shape,v.dtype,F)}let fO={kernelName:C.Conv2D,backendName:"cpu",kernelFunc:fF};var tL=tL;let f_={kernelName:C.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:h}=n;pF([a,s],"conv2dBackpropFilter");let p=tL.convertConv2DDataFormat(l),d=tL.computeConv2DInfo(a.shape,h,i,1,o,u,!1,p),{strideHeight:c,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new rI.TensorBuffer(d.filterShape,"float32"),x=d.padInfo.left,v=d.padInfo.top,w=r.data.get(a.dataId).values,S=r.data.get(s.dataId).values,N=new rI.TensorBuffer(a.shape,a.dtype,w),k=new rI.TensorBuffer(s.shape,s.dtype,S);for(let e=0;e<m;++e){let t=Math.max(0,Math.ceil((v-e)/c)),r=Math.min(d.outHeight,(d.inHeight+v-e)/c);for(let n=0;n<g;++n){let a=Math.max(0,Math.ceil((x-n)/f)),s=Math.min(d.outWidth,(d.inWidth+x-n)/f);for(let i=0;i<d.inChannels;++i)for(let o=0;o<d.outChannels;++o){let l=0;for(let u=0;u<d.batchSize;++u)for(let h=t;h<r;++h){let t=e+h*c-v;for(let e=a;e<s;++e){let r=n+e*f-x;y?l+=N.get(u,t,r,i)*k.get(u,h,e,o):l+=N.get(u,i,t,r)*k.get(u,o,h,e)}}b.set(l,e,n,i,o)}}}return r.makeTensorInfo(b.shape,b.dtype,b.values)}};var tL=tL;let fM={kernelName:C.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:h}=n;pF([a,s],"conv2dBackpropInput");let p=nP.util.computeStrides(s.shape),d=nP.util.computeStrides(a.shape),c=tL.convertConv2DDataFormat(u),f=tL.computeConv2DInfo(i,s.shape,o,1,l,h,!1,c),m=new rI.TensorBuffer(f.inShape,"float32"),g=m.values,y=r.data.get(a.dataId).values,b=r.data.get(s.dataId).values,[x,v,w]=p,{batchSize:S,filterHeight:N,filterWidth:k,inChannels:I,inHeight:T,inWidth:C,outChannels:E,outHeight:$,outWidth:A,strideHeight:R,strideWidth:D}=f;c=f.dataFormat;let F=N-1-f.padInfo.top,O=k-1-f.padInfo.left,_="channelsLast"===c,M=m.strides[0],L=_?m.strides[1]:m.strides[2],z=_?m.strides[2]:1,P=_?1:m.strides[1],B=d[0],V=_?d[1]:d[2],W=_?d[2]:1,U=_?1:d[1];for(let e=0;e<S;++e)for(let t=0;t<I;++t)for(let r=0;r<T;++r){let n=r-F,a=Math.max(0,Math.ceil(n/R)),s=Math.min($,(N+n)/R);for(let i=0;i<C;++i){let o=i-O,l=Math.max(0,Math.ceil(o/D)),u=Math.min(A,(k+o)/D),h=0;for(let r=a;r<s;++r){let a=r*R-n;for(let n=l;n<u;++n){let s=n*D-o,i=B*e+V*r+W*n,l=x*(N-1-a)+v*(k-1-s)+w*t;for(let e=0;e<E;++e)h+=y[i+U*e]*b[l+e]}}g[M*e+L*r+z*i+P*t]=h}}return r.makeTensorInfo(m.shape,m.dtype,m.values)}};var tL=tL;let fL={kernelName:C.Conv3D,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=n;pF([a,s],"conv3d");let u=tL.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:h,filterHeight:p,filterWidth:d,dilationDepth:c,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,x=g.top,v=new rI.TensorBuffer(u.outShape,a.dtype),w=r.data.get(a.dataId).values,S=r.data.get(s.dataId).values,N=v.values,k=nP.util.computeStrides(a.shape),I=nP.util.computeStrides(s.shape);for(let e=0;e<u.batchSize;++e){let t=e*k[0],r=e*v.strides[0];for(let e=0;e<u.outDepth;++e){let n=r+e*v.strides[1],a=e*u.strideDepth-y;for(let e=0;e<h;++e){let r=a+e*c;if(r<0||r>=u.inDepth)continue;let s=e*I[0],i=t+r*k[1];for(let e=0;e<u.outHeight;++e){let t=n+e*v.strides[2],r=e*u.strideHeight-x;for(let e=0;e<p;++e){let n=r+e*f;if(n<0||n>=u.inHeight)continue;let a=s+e*I[1],o=i+n*k[2];for(let e=0;e<u.outWidth;++e){let r=t+e*u.outChannels,n=e*u.strideWidth-b;for(let e=0;e<d;++e){let t=n+e*m;if(t<0||t>=u.inWidth)continue;let s=a+e*I[2],i=o+t*u.inChannels,l=s;for(let e=0;e<u.inChannels;++e){let t=w[i+e];for(let e=0;e<u.outChannels;++e)N[r+e]+=t*S[l+e];l+=u.outChannels}}}}}}}}return r.makeTensorInfo(v.shape,v.dtype,v.values)}};var tL=tL;let fz={kernelName:C.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=n;pF([a,s],"conv3dBackpropFilterV2");let u=nP.util.computeStrides(a.shape),h=nP.util.computeStrides(s.shape),p=tL.computeConv3DInfo(a.shape,l,i,1,o),d=p.strideDepth,c=p.strideHeight,f=p.strideWidth,m=p.filterDepth,g=p.filterHeight,y=p.filterWidth,b=new rI.TensorBuffer(p.filterShape,"float32"),x=b.values,[v,w,S,N]=b.strides,k=r.data.get(s.dataId).values,[I,T,C,E]=h,$=r.data.get(a.dataId).values,[A,R,D,F]=u,O=p.padInfo.front,_=p.padInfo.left,M=p.padInfo.top;for(let e=0;e<m;++e){let t=Math.max(0,Math.ceil((O-e)/d)),r=Math.min(p.outDepth,(p.inDepth+O-e)/d),n=e*v;for(let a=0;a<g;++a){let s=Math.max(0,Math.ceil((M-a)/c)),i=Math.min(p.outHeight,(p.inHeight+M-a)/c),o=a*w+n;for(let n=0;n<y;++n){let l=Math.max(0,Math.ceil((_-n)/f)),u=Math.min(p.outWidth,(p.inWidth+_-n)/f),h=n*S+o;for(let o=0;o<p.inChannels;++o){let m=o*N+h;for(let h=0;h<p.outChannels;++h){let g=0;for(let m=0;m<p.batchSize;++m){let p=m*A,y=m*I;for(let m=t;m<r;++m){let t=(e+m*d-O)*R+p,r=m*T+y;for(let e=s;e<i;++e){let s=(a+e*c-M)*D+t,i=e*C+r;for(let e=l;e<u;++e){let t=(n+e*f-_)*F+s,r=e*E+i;g+=$[t+o]*k[r+h]}}}}x[m+h]=g}}}}}return r.makeTensorInfo(b.shape,b.dtype,b.values)}};var tL=tL;let fP={kernelName:C.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=n;pF([a],"conv3dBackpropInputV2");let u=nP.util.computeStrides(a.shape),h=nP.util.computeStrides(s.shape),p=tL.computeConv3DInfo(l,s.shape,o,1,i),d=new rI.TensorBuffer(p.inShape,"float32"),c=d.values,[f,m,g,y]=d.strides,b=r.data.get(a.dataId).values,[x,v,w,S]=u,N=r.data.get(s.dataId).values,[k,I,T,C]=h,{batchSize:E,filterDepth:$,filterHeight:A,filterWidth:R,inChannels:D,inDepth:F,inHeight:O,inWidth:_,outChannels:M,outDepth:L,outHeight:z,outWidth:P,strideDepth:B,strideHeight:V,strideWidth:W}=p,U=$-1-p.padInfo.front,G=A-1-p.padInfo.top,q=R-1-p.padInfo.left;for(let e=0;e<E;++e)for(let t=0;t<D;++t)for(let r=0;r<F;++r){let n=r-U,a=Math.max(0,Math.ceil(n/B)),s=Math.min(L,($+n)/B);for(let i=0;i<O;++i){let o=i-G,l=Math.max(0,Math.ceil(o/V)),u=Math.min(z,(A+o)/V);for(let h=0;h<_;++h){let p=h-q,d=Math.max(0,Math.ceil(p/W)),E=Math.min(P,(R+p)/W),D=0;for(let r=a;r<s;++r){let a=r*B-n;for(let n=l;n<u;++n){let s=n*V-o;for(let i=d;i<E;++i){let o=i*W-p,l=x*e+v*r+w*n+S*i,u=k*($-1-a)+I*(A-1-s)+T*(R-1-o)+C*t;for(let e=0;e<M;++e)D+=b[l+e]*N[u+e]}}}c[f*e+m*r+g*i+y*h+t]=D}}}return r.makeTensorInfo(d.shape,d.dtype,d.values)}},fB=p8(C.Cos,e=>Math.cos(e)),fV={kernelName:C.Cos,backendName:"cpu",kernelFunc:fB},fW=p8(C.Cosh,e=>Math.cosh(e)),fU={kernelName:C.Cosh,backendName:"cpu",kernelFunc:fW},fG={kernelName:C.CropAndResize,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=n,[h,p,d,c]=a.shape,f=s.shape[0],[m,g]=o,y=(0,pA.buffer)([f,m,g,c],"float32"),b=r.data.get(s.dataId).values,x=r.data.get(i.dataId).values,v=r.data.get(a.dataId).values,w=nP.util.computeStrides(a.shape),S=nP.util.computeStrides(y.shape);for(let e=0;e<f;e++){let t=4*e,r=b[t],n=b[t+1],a=b[t+2],s=b[t+3],i=x[e];if(i>=h)continue;let o=m>1?(a-r)*(p-1)/(m-1):0,f=g>1?(s-n)*(d-1)/(g-1):0;for(let t=0;t<m;t++){let h=m>1?r*(p-1)+t*o:.5*(r+a)*(p-1);if(h<0||h>p-1){for(let r=0;r<g;r++)for(let n=0;n<c;n++){let a=n+r*S[2]+t*S[1]+e*S[0];y.values[a]=u}continue}if("bilinear"===l){let r=Math.floor(h),a=Math.ceil(h),o=h-r;for(let l=0;l<g;l++){let h=g>1?n*(d-1)+l*f:.5*(n+s)*(d-1);if(h<0||h>d-1){for(let r=0;r<c;r++){let n=r+l*S[2]+t*S[1]+e*S[0];y.values[n]=u}continue}let p=Math.floor(h),m=Math.ceil(h),b=h-p;for(let n=0;n<c;n++){let s=n+p*w[2]+r*w[1]+i*w[0],u=v[s],h=v[s=n+m*w[2]+r*w[1]+i*w[0]],d=v[s=n+p*w[2]+a*w[1]+i*w[0]],c=v[s=n+m*w[2]+a*w[1]+i*w[0]],f=u+(h-u)*b,g=d+(c-d)*b;s=n+l*S[2]+t*S[1]+e*S[0],y.values[s]=f+(g-f)*o}}}else for(let r=0;r<g;++r){let a=g>1?n*(d-1)+r*f:.5*(n+s)*(d-1);if(a<0||a>d-1){for(let n=0;n<c;n++){let a=n+r*S[2]+t*S[1]+e*S[0];y.values[a]=u}continue}let o=Math.round(a),l=Math.round(h);for(let n=0;n<c;n++){let a=n+o*w[2]+l*w[1]+i*w[0],s=n+r*S[2]+t*S[1]+e*S[0];y.values[s]=v[a]}}}}return r.makeTensorInfo(y.shape,y.dtype,y.values)}};var tL=tL;let fq={kernelName:C.Cumprod,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=n;pF(a,"cumprod");let l=tL.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=d1({inputs:{x:a},backend:r,attrs:{perm:l}}));let h=tL.getInnerMostAxes(1,a.shape.length)[0];if(h!==u.shape.length-1)throw Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${h}`);let p=(0,dQ.upcastType)(u.dtype,"int32"),d=nP.util.makeOnesTypedArray(nP.util.sizeFromShape(u.shape),p),c=r.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<c.length;e+=f)for(let t=0;t<f;t++){let r=m(e,t);if(0===t)d[r]=i?1:c[r];else{let n=m(e,t-1);d[r]=i?c[n]*d[n]:c[r]*d[n]}}let g=r.makeTensorInfo(u.shape,p,d);if(null!=l){let e=d1({inputs:{x:g},backend:r,attrs:{perm:tL.getUndoAxesPermutation(l)}});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(u),e}return g}};var tL=tL;let fH={kernelName:C.Cumsum,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=n;pF(a,"cumsum");let l=tL.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=d1({inputs:{x:a},backend:r,attrs:{perm:l}}));let h=tL.getInnerMostAxes(1,a.shape.length)[0];if(h!==u.shape.length-1)throw Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${h}`);let p=(0,dQ.upcastType)(u.dtype,"int32"),d=nP.util.makeZerosTypedArray(nP.util.sizeFromShape(u.shape),p),c=r.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<c.length;e+=f)for(let t=0;t<f;t++){let r=m(e,t);if(0===t)d[r]=i?0:c[r];else{let n=m(e,t-1);d[r]=i?c[n]+d[n]:c[r]+d[n]}}let g=r.makeTensorInfo(u.shape,p,d);if(null!=l){let e=d1({inputs:{x:g},backend:r,attrs:{perm:tL.getUndoAxesPermutation(l)}});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(u),e}return g}},fj={kernelName:C.DenseBincount,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=n;if(1===a.shape.length){let e=p1(r.data.get(a.dataId).values,r.data.get(s.dataId).values,s.dtype,s.shape,i);return r.makeTensorInfo([i],s.dtype,e)}if(2===a.shape.length){let e=p2(r.bufferSync(a),r.bufferSync(s),i,o);return r.makeTensorInfo(e.shape,s.dtype,e.values)}throw Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}},fK={kernelName:C.DepthToSpace,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{blockSize:s,dataFormat:i}=n;nP.util.assert("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=a.shape[0],l=a.shape[1],u=a.shape[2],h=a.shape[3],p=l*s,d=u*s,c=h/(s*s),f=r.data.get(a.dataId).values,m=new Float32Array(o*p*d*c),g=0;for(let e=0;e<o;++e)for(let t=0;t<p;++t){let r=Math.floor(t/s),n=t%s;for(let t=0;t<d;++t){let a=Math.floor(t/s),i=t%s,o=(n*s+i)*c;for(let t=0;t<c;++t){let n=t+o+h*(a+u*(r+l*e));m[g++]=f[n]}}}return r.makeTensorInfo([o,p,d,c],a.dtype,m)}};var tL=tL;function fX(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=n;pF([a,s],"depthwiseConv2DNative");let h=nP.util.computeStrides(a.shape),p=nP.util.computeStrides(s.shape),d=l;null==d&&(d=[1,1]),nP.util.assert(tL.eitherStridesOrDilationsAreOne(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=tL.computeConv2DInfo(a.shape,s.shape,i,d,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=c,x=b.left,v=b.top,w=c.outChannels/c.inChannels,S=new rI.TensorBuffer(c.outShape,a.dtype),N=r.data.get(a.dataId).values,k=r.data.get(s.dataId).values,I=S.values;for(let e=0;e<c.batchSize;++e){let t=e*h[0],r=e*S.strides[0];for(let e=0;e<c.outHeight;++e){let n=r+e*S.strides[1],a=e*c.strideHeight-v;for(let e=0;e<f;++e){let r=a+e*g;if(r<0||r>=c.inHeight)continue;let s=e*p[0],i=t+r*h[1];for(let e=0;e<c.outWidth;++e){let t=n+e*S.strides[2],r=e*c.strideWidth-x;for(let e=0;e<m;++e){let n=r+e*y;if(n<0||n>=c.inWidth)continue;let a=s+e*p[1],o=i+n*c.inChannels,l=t,u=a;for(let e=0;e<c.inChannels;++e){let t=N[o+e];for(let e=0;e<w;++e)I[l+e]+=t*k[u+e];l+=w,u+=w}}}}}}return r.makeTensorInfo(S.shape,S.dtype,S.values)}let fZ={kernelName:C.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:fX};var tL=tL;let fY={kernelName:C.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:h}=n;pF([a,s],"depthwiseConv2dNativeBackpropFilter");let p=tL.computeConv2DInfo(a.shape,h,i,o,l,u,!0),{strideHeight:d,strideWidth:c,filterHeight:f,filterWidth:m}=p,g=new rI.TensorBuffer(p.filterShape,"float32"),y=p.padInfo.left,b=p.padInfo.top,x=p.outChannels/p.inChannels,v=r.data.get(a.dataId).values,w=new rI.TensorBuffer(a.shape,a.dtype,v),S=r.data.get(s.dataId).values,N=new rI.TensorBuffer(s.shape,s.dtype,S);for(let e=0;e<f;++e){let t=Math.max(0,Math.ceil((b-e)/d)),r=Math.min(p.outHeight,(p.inHeight+b-e)/d);for(let n=0;n<m;++n){let a=Math.max(0,Math.ceil((y-n)/c)),s=Math.min(p.outWidth,(p.inWidth+y-n)/c);for(let i=0;i<p.outChannels;++i){let o=Math.trunc(i/x),l=i%x,u=0;for(let l=0;l<p.batchSize;++l)for(let h=t;h<r;++h){let t=e+h*d-b;for(let e=a;e<s;++e){let r=n+e*c-y;u+=w.get(l,t,r,o)*N.get(l,h,e,i)}}g.set(u,e,n,o,l)}}}return r.makeTensorInfo(g.shape,g.dtype,g.values)}};var tL=tL;let fJ={kernelName:C.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:h}=n;pF([a,s],"depthwiseConv2DNativeBackpropInput");let p=nP.util.computeStrides(a.shape),d=nP.util.computeStrides(s.shape),c=tL.computeConv2DInfo(h,s.shape,i,o,l,u,!0),f=new rI.TensorBuffer(c.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=r.data.get(a.dataId).values,[v,w,S]=p,N=r.data.get(s.dataId).values,[k,I,T]=d,{batchSize:C,filterHeight:E,filterWidth:$,inChannels:A,inHeight:R,inWidth:D,outChannels:F,outHeight:O,outWidth:_,strideHeight:M,strideWidth:L}=c,z=E-1-c.padInfo.top,P=$-1-c.padInfo.left,B=F/A;for(let e=0;e<C;++e)for(let t=0;t<A;++t)for(let r=0;r<R;++r){let n=r-z,a=Math.max(0,Math.ceil(n/M)),s=Math.min(O,(E+n)/M);for(let i=0;i<D;++i){let o=i-P,l=Math.max(0,Math.ceil(o/L)),u=Math.min(_,($+o)/L),h=0;for(let r=a;r<s;++r){let a=r*M-n;for(let n=l;n<u;++n){let s=n*L-o,i=v*e+w*r+S*n,l=k*(E-1-a)+I*($-1-s)+T*t;for(let e=0;e<B;++e)h+=x[i+(t*B+e)]*N[l+e]}}m[g*e+y*r+b*i+t]=h}}return r.makeTensorInfo(f.shape,f.dtype,f.values)}},fQ={kernelName:C.Diag,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{x:n}=t,a=nP.util.sizeFromShape(n.shape),s=r.data.get(n.dataId).values,i=(0,pA.buffer)([a,a],n.dtype),o=i.values;for(let e=0;e<s.length;e++)o[e*a+e]=s[e];let l=[...n.shape,...n.shape];return r.makeTensorInfo(l,i.dtype,i.values)}};var tL=tL;let f0={kernelName:C.Dilation2D,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:r})=>{let{x:n,filter:a}=e,{strides:s,pad:i,dilations:o}=r,l=t.data.get(n.dataId).values,u=n.shape.length,h=t.data.get(a.dataId).values,p=a.shape.length,{batchSize:d,inHeight:c,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:w,filterWidth:S,dilationHeight:N,dilationWidth:k,outShape:I}=tL.computeDilation2DInfo(n.shape,a.shape,s,i,"NHWC",o),T=nP.util.sizeFromShape(I),C=I.length,E=nP.util.getArrayFromDType(n.dtype,T);for(let e=0;e<d;++e)for(let t=0;t<g;++t){let r=t*x-b.top;for(let s=0;s<y;++s){let i=s*v-b.left;for(let o=0;o<m;++o){let d=Number.MIN_SAFE_INTEGER;for(let t=0;t<w;++t){let s=r+t*N;if(s>=0&&s<c)for(let r=0;r<S;++r){let c=i+r*k;if(c>=0&&c<f){let i=nP.util.locToIndex([e,s,c,o],u,nP.util.computeStrides(n.shape)),f=nP.util.locToIndex([t,r,o],p,nP.util.computeStrides(a.shape)),m=l[i]+h[f];m>d&&(d=m)}}}E[nP.util.locToIndex([e,t,s,o],C,nP.util.computeStrides(I))]=d}}}return{dataId:t.write(nP.util.toTypedArray(E,n.dtype),I,n.dtype),shape:I,dtype:n.dtype}}};var tL=tL;let f1={kernelName:C.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:r})=>{let{x:n,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=r,u=nP.util.toNestedArray(n.shape,t.data.get(n.dataId).values),h=nP.util.toNestedArray(a.shape,t.data.get(a.dataId).values),{batchSize:p,inHeight:d,inWidth:c,inChannels:f,outHeight:m,outWidth:g,padInfo:y,strideHeight:b,strideWidth:x,filterHeight:v,filterWidth:w,dilationHeight:S,dilationWidth:N,outShape:k}=tL.computeDilation2DInfo(n.shape,a.shape,i,o,"NHWC",l);nP.util.assert(s.rank===k.length,()=>`Error in ${C.Dilation2DBackpropFilter}, dy must have the same rank as output ${k.length}, but got ${s.rank}`);let I=nP.util.toNestedArray(k,t.data.get(s.dataId).values),T=nP.util.makeZerosNestedTypedArray(a.shape,a.dtype);for(let e=0;e<p;++e)for(let t=0;t<m;++t){let r=t*b-y.top;for(let n=0;n<g;++n){let a=n*x-y.left;for(let s=0;s<f;++s){let i=Number.MIN_SAFE_INTEGER,o=0,l=0;for(let t=0;t<v;++t){let n=r+t*S;if(n>=0&&n<d)for(let r=0;r<w;++r){let p=a+r*N;if(p>=0&&p<c){let a=u[e][n][p][s]+h[t][r][s];a>i&&(i=a,o=t,l=r)}}}T[o][l][s]+=I[e][t][n][s]}}}return{dataId:t.write(nP.util.toTypedArray(T,n.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};var tL=tL;let f2={kernelName:C.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:r})=>{let{x:n,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=r,u=nP.util.toNestedArray(n.shape,t.data.get(n.dataId).values),h=nP.util.toNestedArray(a.shape,t.data.get(a.dataId).values),{batchSize:p,inHeight:d,inWidth:c,inChannels:f,outHeight:m,outWidth:g,padInfo:y,strideHeight:b,strideWidth:x,filterHeight:v,filterWidth:w,dilationHeight:S,dilationWidth:N,outShape:k}=tL.computeDilation2DInfo(n.shape,a.shape,i,o,"NHWC",l);nP.util.assert(s.rank===k.length,()=>`Error in ${C.Dilation2DBackpropInput}, dy must have the same rank as output ${k.length}, but got ${s.rank}`);let I=nP.util.toNestedArray(k,t.data.get(s.dataId).values),T=nP.util.makeZerosNestedTypedArray(n.shape,n.dtype);for(let e=0;e<p;++e)for(let t=0;t<m;++t){let r=t*b-y.top;for(let n=0;n<g;++n){let a=n*x-y.left;for(let s=0;s<f;++s){let i=Number.MIN_SAFE_INTEGER,o=r<0?0:r,l=a<0?0:a;for(let t=0;t<v;++t){let n=r+t*S;if(n>=0&&n<d)for(let r=0;r<w;++r){let p=a+r*N;if(p>=0&&p<c){let a=u[e][n][p][s]+h[t][r][s];a>i&&(i=a,o=n,l=p)}}}T[e][o][l][s]+=I[e][t][n][s]}}}return{dataId:t.write(nP.util.toTypedArray(T,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},f3={kernelName:C.Draw,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{image:a}=t,{canvas:s,options:i}=n,{contextOptions:o,imageOptions:l}=i||{},u=(null==l?void 0:l.alpha)||1,h=(null==o?void 0:o.contextType)||"2d";if("2d"!==h)throw Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let p=s.getContext(h,(null==o?void 0:o.contextAttributes)||{});if(null==p)throw Error(`Could not get the context with ${h} type.`);let[d,c]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=r.data.get(a.dataId).values,g="float32"===a.dtype?255:1,y=new Uint8ClampedArray(c*d*4);for(let e=0;e<d*c;++e){let t=[0,0,0,255*u];for(let r=0;r<f;r++){let n=m[e*f+r];if("float32"===a.dtype){if(n<0||n>1)throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${n}.`)}else if("int32"===a.dtype&&(n<0||n>255))throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${n}.`);1===f?(t[0]=n*g,t[1]=n*g,t[2]=n*g):t[r]=n*g}let r=4*e;y[r+0]=Math.round(t[0]),y[r+1]=Math.round(t[1]),y[r+2]=Math.round(t[2]),y[r+3]=Math.round(t[3])}s.width=c,s.height=d;let b=new ImageData(y,c,d);return p.putImageData(b,0,0),a}};var tL=tL,tL=tL;function f4(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s}=r,{axis:i,keepDims:o}=a;pF(s,"sum");let l=(t="bool"===s.dtype?pj({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):pW({inputs:{x:s},backend:n})).shape.length,u=nP.util.parseAxisParam(i,t.shape),h=tL.getAxesPermutation(u,l),p=u,d=t;null!=h&&(d=d1({inputs:{x:t},backend:n,attrs:{perm:h}}),p=tL.getInnerMostAxes(p.length,l)),tL.assertAxesAreInnerMostDims("sum",p,d.shape.length);let[c,f]=tL.computeOutAndReduceShapes(d.shape,p),m=pV(n,c,tL.upcastType(d.dtype,"int32")),g=nP.util.sizeFromShape(f),y=n.data.get(m.dataId).values,b=n.data.get(d.dataId).values;for(let e=0;e<y.length;++e){let t=e*g,r=0;for(let e=0;e<g;++e)r+=b[t+e];y[e]=r}if(o){let e=tL.expandShapeToKeepDim(m.shape,u),t=m;m=c0({inputs:{x:m},backend:n,attrs:{shape:e}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(t),null!=h&&n.disposeIntermediateTensorInfo(d),m}let f6={kernelName:C.Sum,backendName:"cpu",kernelFunc:f4},f5={kernelName:C.Einsum,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{equation:a}=n,{allDims:s,summedDims:i,idDims:o}=tL.decodeEinsumEquation(a,t.length);tL.checkEinsumDimSizes(s.length,o,t);let{path:l,steps:u}=tL.getEinsumComputePath(i,o),h=u.length,p=null,d=s.length,c=[];for(let e=0;e<h;++e){for(let n of u[e]){let e,{permutationIndices:a,expandDims:s}=tL.getEinsumPermutation(d,o[n]);tL.isIdentityPermutation(a)?e=t[n]:(e=d1({inputs:{x:t[n]},backend:r,attrs:{perm:a}}),c.push(e));let i=e.shape.slice();for(let e=0;e<s.length;++e)i.splice(s[e],0,1);nP.util.arraysEqual(e.shape,i)||(e=c0({inputs:{x:e},backend:r,attrs:{shape:i}}),c.push(e)),null===p?p=e:(p=dH({inputs:{a:e,b:p},backend:r}),c.push(p))}e<h-1&&(l[e]>=0&&(p=f4({inputs:{x:p},backend:r,attrs:{axis:l[e]-(s.length-d),keepDims:!1}}),c.push(p)),d--)}for(let e of c)e!==p&&r.disposeIntermediateTensorInfo(e);return p}},f8={kernelName:C.EluGrad,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{dy:n,y:a}=t;pF([n,a],"eluGrad");let s=new Float32Array(nP.util.sizeFromShape(a.shape)),i=r.data.get(a.dataId).values,o=r.data.get(n.dataId).values;for(let e=0;e<i.length;++e){let t=i[e];t>=0?s[e]=o[e]:s[e]=o[e]*(t+1)}return r.makeTensorInfo(a.shape,"float32",s)}};var tL=tL;let f9=tL.ERF_P,f7=tL.ERF_A1,me=tL.ERF_A2,mt=tL.ERF_A3,mr=tL.ERF_A4,mn=tL.ERF_A5,ma=p8(C.Erf,e=>{let t=Math.sign(e),r=Math.abs(e),n=1/(1+f9*r);return t*(1-((((mn*n+mr)*n+mt)*n+me)*n+f7)*n*Math.exp(-r*r))}),ms={kernelName:C.Erf,backendName:"cpu",kernelFunc:ma};function mi(e){let{inputs:t,backend:r,attrs:n}=e,{input:a}=t,{dim:s}=n,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(nP.util.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),c0({inputs:{x:a},backend:r,attrs:{shape:o}})}let mo={kernelName:C.ExpandDims,backendName:"cpu",kernelFunc:mi};var tL=tL;let ml=pz((e,t)=>e/t),mu=pX(C.RealDiv,ml),mh={kernelName:C.RealDiv,backendName:"cpu",kernelFunc:mu};function mp(e,t,r){let n=e.shape,a=n[0],s=n[1],i=r.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],h=nP.util.sizeFromShape(u),p=nP.util.getTypedArrayFromDType("float32",h),d=nP.util.getTypedArrayFromDType("float32",h);for(let e=0;e<a;e++){let n=cc({inputs:{x:o},backend:r,attrs:{begin:[e,0],size:[1,s]}}),a=cc({inputs:{x:l},backend:r,attrs:{begin:[e,0],size:[1,s]}}),i=pP({inputs:{real:n,imag:a},backend:r}),{real:u,imag:h}=function(e,t,r){var n;let a=nP.util.sizeFromShape(e.shape),s=r.data.get(e.dataId),i=r.data.get(s.complexTensorInfos.real.dataId).values,o=r.data.get(s.complexTensorInfos.imag.dataId).values;if(((n=a)&n-1)==0){let n=function e(t,r,n,a,s){if(1===n)return{real:t,imag:r};let i=tL.mergeRealAndImagArrays(t,r),o=n/2,l=tL.complexWithEvenIndex(i),u=l.real,h=l.imag,p=[u.length],d=s.makeTensorInfo(p,"float32",u),c=s.makeTensorInfo(p,"float32",h),f=pP({inputs:{real:d,imag:c},backend:s}),m=tL.complexWithOddIndex(i),g=m.real,y=m.imag,b=[g.length],x=s.makeTensorInfo(b,"float32",g),v=s.makeTensorInfo(b,"float32",y),w=pP({inputs:{real:x,imag:v},backend:s}),S=e(u,h,o,a,s),N=S.real,k=S.imag,I=[N.length],T=s.makeTensorInfo(I,"float32",N),C=s.makeTensorInfo(I,"float32",k),E=pP({inputs:{real:T,imag:C},backend:s}),$=e(g,y,o,a,s),A=$.real,R=$.imag,D=[A.length],F=s.makeTensorInfo(D,"float32",A),O=s.makeTensorInfo(D,"float32",R),_=pP({inputs:{real:F,imag:O},backend:s}),M=tL.exponents(n,a),L=[M.real.length],z=s.makeTensorInfo(L,"float32",M.real),P=s.makeTensorInfo(L,"float32",M.imag),B=pP({inputs:{real:z,imag:P},backend:s}),V=dH({inputs:{a:B,b:_},backend:s}),W=pQ({inputs:{a:E,b:V},backend:s}),U=cO({inputs:{a:E,b:V},backend:s}),G=pG({inputs:{input:W},backend:s}),q=pG({inputs:{input:U},backend:s}),H=f$({inputs:{input:W},backend:s}),j=f$({inputs:{input:U},backend:s}),K=fR({inputs:[G,q],backend:s,attrs:{axis:0}}),X=fR({inputs:[H,j],backend:s,attrs:{axis:0}}),Z=s.data.get(K.dataId).values,Y=s.data.get(X.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(c),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(E),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(X),{real:Z,imag:Y}}(i,o,a,t,r),s=[e.shape[0],e.shape[1]];if(t){let e=r.makeTensorInfo(s,"float32",n.real),t=r.makeTensorInfo(s,"float32",n.imag),i=r.makeTensorInfo([],"float32",nP.util.createScalarValue(a,"float32")),o=pW({inputs:{x:i},backend:r}),l=mh.kernelFunc({inputs:{a:e,b:i},backend:r}),u=mh.kernelFunc({inputs:{a:t,b:o},backend:r}),h=r.data.get(l.dataId).values,p=r.data.get(u.dataId).values;return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(u),{real:h,imag:p}}return n}{let e=function(e,t,r){let n=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,i=0;for(let n=0;n<t;n++){let o=tL.exponent(a*n,t,r),l=tL.getComplexWithIndex(e,n);s+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}r&&(s/=t,i/=t),tL.assignToTypedArray(n,s,i,a)}return n}(tL.mergeRealAndImagArrays(i,o),a,t);return tL.splitRealAndImagArrays(e)}}(i,t,r),c=tL.mergeRealAndImagArrays(u,h);for(let t=0;t<s;t++){let r=tL.getComplexWithIndex(c,t);p[e*s+t]=r.real,d[e*s+t]=r.imag}r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i)}let c=r.makeTensorInfo(u,"float32",p),f=r.makeTensorInfo(u,"float32",d),m=pP({inputs:{real:c,imag:f},backend:r});return r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(f),m}let md={kernelName:C.FFT,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{input:n}=t,a=nP.util.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=c0({inputs:{x:n},backend:r,attrs:{shape:[a/s,s]}}),o=mp(i,!1,r),l=c0({inputs:{x:o},backend:r,attrs:{shape:n.shape}});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}};function mc(e){var t,r;let{backend:n,attrs:a}=e,{shape:s,value:i,dtype:o}=a,l=o||nP.util.inferDtype(i),u=nP.util.getArrayFromDType(l,nP.util.sizeFromShape(s));return t=u,r=i,t.fill(r),n.makeTensorInfo(s,l,u)}let mf={kernelName:C.Fill,backendName:"cpu",kernelFunc:mc},mm={kernelName:C.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{image:n}=e,a=nP.util.getTypedArrayFromDType(n.dtype,nP.util.sizeFromShape(n.shape)),[s,i,o,l]=n.shape,u=r.data.get(n.dataId).values;for(let e=0;e<s;e++){let t=e*o*i*l;for(let e=0;e<i;e++){let r=o*l*e;for(let e=0;e<o;e++){let n=e*l;for(let s=0;s<l;s++){let i=Math.round(o-e-1),h=t+r+n+s,p=u[h];i>=0&&i<o&&(p=u[t+r+i*l+s]),a[h]=p}}}}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},mg={kernelName:C.FusedConv2D,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:h,dilations:p,dimRoundingMode:d,activation:c,leakyreluAlpha:f}=n,m=fF({inputs:{x:a,filter:s},backend:r,attrs:{strides:l,pad:u,dataFormat:h,dilations:p,dimRoundingMode:d}});if(i){let e=m;if("NCHW"===h&&1===i.shape.length&&1!==i.shape[0]){let e=c0({inputs:{x:i},backend:r,attrs:{shape:[i.shape[0],1,1]}});m=pQ({inputs:{a:m,b:e},backend:r}),r.disposeIntermediateTensorInfo(e)}else m=pQ({inputs:{a:m,b:i},backend:r});r.disposeIntermediateTensorInfo(e)}if(c){let e=m;if("NCHW"===h&&"prelu"===c&&1===o.shape.length&&1!==o.shape[0]){let e=c0({inputs:{x:o},backend:r,attrs:{shape:[o.shape[0],1,1]}});m=cJ(r,m,c,e,f),r.disposeIntermediateTensorInfo(e)}else m=cJ(r,m,c,o,f);r.disposeIntermediateTensorInfo(e)}return m}},my={kernelName:C.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:h,dilations:p,dimRoundingMode:d,activation:c,leakyreluAlpha:f}=n,m=fX({inputs:{x:a,filter:s},backend:r,attrs:{strides:l,pad:u,dataFormat:h,dilations:p,dimRoundingMode:d}});if(i){let e=m;m=pQ({inputs:{a:m,b:i},backend:r}),r.disposeIntermediateTensorInfo(e)}if(c){let e=m;m=cJ(r,m,c,o,f),r.disposeIntermediateTensorInfo(e)}return m}};var tL=tL;let mb={kernelName:C.GatherNd,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{params:n,indices:a}=t,s=nP.util.sizeFromShape(n.shape),i=a.shape,o=i[i.length-1],[l,u,h,p]=tL.prepareAndValidate(n,a);if(0===u)return r.makeTensorInfo(l,n.dtype,[]);let d=dx(r.data.get(a.dataId).values,r.bufferSync(n),n.dtype,u,o,h,p,n.shape,s);return r.makeTensorInfo(l,n.dtype,d.values)}};var tL=tL;let mx={kernelName:C.GatherV2,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=n;pF([a,s],"gatherV2");let l=nP.util.parseAxisParam(i,a.shape)[0],u=r.data.get(s.dataId).values,h=a.shape[l];for(let e=0;e<u.length;++e){let t=u[e];nP.util.assert(t<=h-1&&t>=0,()=>`GatherV2: the index value ${t} is not in [0, ${h-1}]`)}let p=o;null==o&&(p=0);let d=nP.util.sizeFromShape(s.shape),c=tL.segment_util.collectGatherOpShapeInfo(a,s,l,p),f=c0({inputs:{x:a},backend:r,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),m=c0({inputs:{x:s},backend:r,attrs:{shape:[c.batchSize,d/c.batchSize]}}),g=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize],y=r.bufferSync(m),b=dv(r.bufferSync(f),y,g);return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),r.makeTensorInfo(c.outputShape,b.dtype,b.values)}},mv={kernelName:C.IFFT,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{input:n}=t,a=nP.util.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=c0({inputs:{x:n},backend:r,attrs:{shape:[a/s,s]}}),o=mp(i,!0,r),l=c0({inputs:{x:o},backend:r,attrs:{shape:n.shape}});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}},mw=p8(C.IsFinite,e=>+!!Number.isFinite(e),"bool"),mS={kernelName:C.IsFinite,backendName:"cpu",kernelFunc:mw},mN=p8(C.IsInf,e=>+(Math.abs(e)===1/0),"bool"),mk={kernelName:C.IsInf,backendName:"cpu",kernelFunc:mN},mI=p8(C.IsNan,e=>+!!Number.isNaN(e),"bool"),mT={kernelName:C.IsNan,backendName:"cpu",kernelFunc:mI},mC={kernelName:C.LinSpace,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:r}=e,{start:n,stop:a,num:s}=r,i=dF(n,a,s);return t.makeTensorInfo([i.length],"float32",i)}},mE=p8(C.Log1p,e=>Math.log1p(e)),m$={kernelName:C.Log1p,backendName:"cpu",kernelFunc:mE},mA=pz((e,t)=>e&&t),mR=pX(C.LogicalAnd,mA,null,"bool"),mD={kernelName:C.LogicalAnd,backendName:"cpu",kernelFunc:mR},mF=p8(C.LogicalNot,e=>+!e,"bool"),mO={kernelName:C.LogicalNot,backendName:"cpu",kernelFunc:mF},m_=pz((e,t)=>e||t),mM=pX(C.LogicalOr,m_,null,"bool"),mL={kernelName:C.LogicalOr,backendName:"cpu",kernelFunc:mM},mz={kernelName:C.LRN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;pF(a,"LRN");let u=a.shape[3],h=u-1,p=r.data.get(a.dataId).values,d=nP.util.sizeFromShape(a.shape),c=new Float32Array(d);for(let e=0;e<d;e++){let t=function(e){let t=e%u,r=e-t+Math.max(0,t-s),n=e-t+Math.min(t+s,h),a=0;for(;r<=n;r++){let e=p[r];a+=e*e}return a}(e),r=p[e]*Math.pow(i+o*t,-l);c[e]=r}return r.makeTensorInfo(a.shape,a.dtype,c)}},mP={kernelName:C.LRNGrad,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:h}=n;pF(i,"LRNGrad");let p=nP.util.sizeFromShape(i.shape),d=i.shape[3],c=r.data.get(i.dataId).values,f=r.data.get(a.dataId).values,m=r.data.get(s.dataId).values,g=new Float32Array(p);for(let e=0;e<p;e++){let t=e%d,r=e-t+Math.max(0,t-o),n=e-t+Math.min(d,t+o+1),a=0;for(let e=r;e<n;e++)a+=Math.pow(f[e],2);a=u*a+l;for(let t=r;t<n;t++){let r=-2*u*h*f[t]*m[e]/a;e===t&&(r+=Math.pow(a,-h)),r*=c[e],g[t]+=r}}return r.makeTensorInfo(i.shape,a.dtype,g)}};var tL=tL;function mB(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=n,o=a.shape,l=o.length,u=nP.util.parseAxisParam(s,o),h=u,p=tL.getAxesPermutation(h,l),d=r.data.get(a.dataId).values;if(null!=p){let e=Array(l);for(let t=0;t<e.length;t++)e[t]=o[p[t]];d=d0(d,o,a.dtype,p,e),h=tL.getInnerMostAxes(h.length,l),o=e}pF(a,"max"),tL.assertAxesAreInnerMostDims("max",h,l);let[c,f]=tL.computeOutAndReduceShapes(o,h),m=dL(d,nP.util.sizeFromShape(f),c,a.dtype),g=r.write(m,c,a.dtype),y=c;return i&&(y=tL.expandShapeToKeepDim(c,u)),{dataId:g,shape:y,dtype:a.dtype}}let mV={kernelName:C.Max,backendName:"cpu",kernelFunc:mB};var tL=tL;let mW={kernelName:C.MaxPool,backendName:"cpu",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s}=r;pF(s,"maxPool");let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a;nP.util.assert(tL.eitherStridesOrDilationsAreOne(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);let h=tL.computePool2DInfo(s.shape,i,o,1,l,u);if(1===h.filterWidth&&1===h.filterHeight&&nP.util.arraysEqual(h.inShape,h.outShape))t=pW({inputs:{x:s},backend:n});else{let e=n.data.get(s.dataId).values,r=nP.util.computeStrides(s.shape),a=fm(e,s.shape,s.dtype,r,h,"max");t=n.makeTensorInfo(h.outShape,s.dtype,a.values)}return t}};var tL=tL;let mU={kernelName:C.MaxPool3D,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=n;pF(a,"maxPool3d");let h=tL.computePool3DInfo(a.shape,s,i,1,o,l,u),p=fy(r.data.get(a.dataId).values,a.shape,a.dtype,nP.util.computeStrides(a.shape),h,"max");return r.makeTensorInfo(p.shape,"float32",p.values)}};var tL=tL;let mG={kernelName:C.MaxPool3DGrad,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n;pF([a,s],"maxPool3DGrad");let h=tL.computePool3DInfo(s.shape,i,o,1,l,u),p=function(e,t){let r=(0,pA.buffer)(t.outShape,"int32"),n=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,h=t.effectiveFilterHeight,p=t.effectiveFilterWidth,d=t.padInfo.front,c=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*n-d,x=b;for(;x<0;)x+=i;let v=Math.min(t.inDepth,u+b);for(let n=0;n<t.outHeight;++n){let u=n*a-c,d=u;for(;d<0;)d+=o;let w=Math.min(t.inHeight,h+u);for(let a=0;a<t.outWidth;++a){let c=a*s-f,S=c;for(;S<0;)S+=l;let N=Math.min(t.inWidth,p+c),k=-1/0,I=-1;for(let t=x;t<v;t+=i){let r=t-b;for(let n=d;n<w;n+=o){let a=n-u;for(let s=S;s<N;s+=l){let i=s-c,o=e.get(m,t,n,s,g);o>=k&&(k=o,I=r*h*p+a*h+i)}}}r.set(I,m,y,n,a,g)}}}return r}(r.bufferSync(s),h),d=h.strideDepth,c=h.strideHeight,f=h.strideWidth,m=h.dilationDepth,g=h.dilationHeight,y=h.dilationWidth,b=h.effectiveFilterDepth,x=h.effectiveFilterHeight,v=h.effectiveFilterWidth,w=b-1-h.padInfo.front,S=v-1-h.padInfo.left,N=x-1-h.padInfo.top,k=(0,pA.buffer)(s.shape,"float32"),I=r.bufferSync(a);for(let e=0;e<h.batchSize;++e)for(let t=0;t<h.inChannels;++t)for(let r=0;r<h.inDepth;++r)for(let n=0;n<h.inHeight;++n)for(let a=0;a<h.inWidth;++a){let s=r-w,i=n-N,o=a-S,l=0;for(let r=0;r<b;r+=m){let n=(s+r)/d;if(!(n<0)&&!(n>=h.outDepth)&&Math.floor(n)===n)for(let a=0;a<x;a+=g){let s=(i+a)/c;if(!(s<0)&&!(s>=h.outHeight)&&Math.floor(s)===s)for(let i=0;i<v;i+=y){let u=(o+i)/f;if(u<0||u>=h.outWidth||Math.floor(u)!==u)continue;let d=+(b*x*v-1-p.get(e,n,s,u,t)===r*x*v+a*v+i);0!==d&&(l+=I.get(e,n,s,u,t)*d)}}}k.set(l,e,r,n,a,t)}return r.makeTensorInfo(k.shape,k.dtype,k.values)}};var tL=tL;let mq={kernelName:C.MaxPoolGrad,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:s,output:i}=t;pF([s,i],"maxPoolGrad");let{filterSize:o,strides:l,pad:u,dimRoundingMode:h}=n,p=tL.computePool2DInfo(s.shape,o,l,1,u,h),d=r.data.get(s.dataId).values,c=(0,pA.buffer)(p.outShape,s.dtype,fg(d,s.shape,s.dtype,p).values),f=p.strideHeight,m=p.strideWidth,g=p.dilationHeight,y=p.dilationWidth,b=p.effectiveFilterHeight,x=p.effectiveFilterWidth,v=x-1-p.padInfo.left,w=b-1-p.padInfo.top,S=(0,pA.buffer)(s.shape,"float32"),N=r.data.get(a.dataId).values,k=(0,pA.buffer)(a.shape,"float32",N);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let r=0;r<p.inHeight;++r)for(let n=0;n<p.inWidth;++n){let a=r-w,s=n-v,i=0;for(let r=0;r<b;r+=g){let n=(a+r)/f;if(!(n<0)&&!(n>=p.outHeight)&&Math.floor(n)===n)for(let a=0;a<x;a+=y){let o=(s+a)/m;if(o<0||o>=p.outWidth||Math.floor(o)!==o)continue;let l=+(b*x-1-c.get(e,n,o,t)===r*x+a);0!==l&&(i+=k.get(e,n,o,t)*l)}}S.set(i,e,r,n,t)}return r.makeTensorInfo(S.shape,S.dtype,S.values)}};var tL=tL;let mH={kernelName:C.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:r})=>{var n,a;let s,i,o,{x:l}=e,{filterSize:u,strides:h,pad:p,includeBatchInIndex:d}=t;pF(l,"MaxPoolWithArgmax");let c=r.data.get(l.dataId).values,f=tL.computePool2DInfo(l.shape,u,h,[1,1],p),[m,g]=(n=l.shape,a=l.dtype,s=nP.util.computeStrides(n),i=fm(c,n,a,s,f,"max"),o=fg(c,n,a,f,!0,d),[i.values,o.values]),y=r.write(m,f.outShape,l.dtype),b=r.write(g,f.outShape,l.dtype);return[{dataId:y,shape:f.outShape,dtype:l.dtype},{dataId:b,shape:f.outShape,dtype:"int32"}]}};var tL=tL;let mj={kernelName:C.Mean,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s,keepDims:i}=n,o=nP.util.parseAxisParam(s,a.shape),l=tL.computeOutAndReduceShapes(a.shape,o)[1],u=nP.util.sizeFromShape(l),h=[],p=r.makeTensorInfo([],"float32",new Float32Array([u]));h.push(p);let d=pj({inputs:{x:a},backend:r,attrs:{dtype:"float32"}});h.push(d);let c=mu({inputs:{a:d,b:p},backend:r});h.push(c);let f=f4({inputs:{x:c},backend:r,attrs:{axis:s,keepDims:i}});return h.forEach(e=>r.disposeIntermediateTensorInfo(e)),f}};var tL=tL;let mK={kernelName:C.Min,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s,keepDims:i}=n;pF(a,"min");let o=nP.util.parseAxisParam(s,a.shape),l=o,u=tL.getAxesPermutation(l,a.shape.length),h=a;null!=u&&(h=d1({inputs:{x:a},backend:r,attrs:{perm:u}}),l=tL.getInnerMostAxes(l.length,a.shape.length)),tL.assertAxesAreInnerMostDims("min",l,h.shape.length);let[p,d]=tL.computeOutAndReduceShapes(h.shape,l),c=nP.util.sizeFromShape(d),f=nP.util.makeZerosTypedArray(nP.util.sizeFromShape(p),h.dtype),m=r.data.get(h.dataId).values;for(let e=0;e<f.length;++e){let t=e*c,r=m[t];for(let e=0;e<c;++e){let n=m[t+e];(Number.isNaN(n)||n<r)&&(r=n)}f[e]=r}null!=u&&r.disposeIntermediateTensorInfo(h);let g=r.makeTensorInfo(p,h.dtype,f);if(i){let e=c0({inputs:{x:g},backend:r,attrs:{shape:tL.expandShapeToKeepDim(p,o)}});return r.disposeIntermediateTensorInfo(g),e}return g}},mX={kernelName:C.MirrorPad,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{paddings:s,mode:i}=n;pF(a,"mirrorPad");let o=s.map((e,t)=>e[0]+a.shape[t]+e[1]),l=s.map(e=>e[0]),u=s.map((e,t)=>e[0]+a.shape[t]),h=+("reflect"!==i),p=r.data.get(a.dataId).values,d=a.shape.length,c=nP.util.computeStrides(a.shape),f=nP.util.sizeFromShape(o),m=o.length,g=nP.util.computeStrides(o),y=nP.util.getTypedArrayFromDType(a.dtype,f);for(let e=0;e<f;e++){let t=nP.util.indexToLoc(e,m,g);for(let e=0;e<m;e++)t[e]<l[e]?t[e]=2*l[e]-t[e]-h:t[e]>=u[e]&&(t[e]=(u[e]-1)*2-t[e]+h);t=t.map((e,t)=>e-l[t]);let r=nP.util.locToIndex(t,d,c);y[e]=p[r]}return{dataId:r.write(y,o,a.dtype),shape:o,dtype:a.dtype}}},mZ=pz((e,t)=>{let r=e%t;return e<0&&t<0||e>=0&&t>=0?r:(r+t)%t}),mY=pX(C.Mod,mZ),mJ={kernelName:C.Mod,backendName:"cpu",kernelFunc:mY};var tL=tL;function mQ(e){let{inputs:t,backend:r,attrs:n}=e,{logits:a}=t,{dim:s}=n,i=a.shape.length,o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=nP.util.parseAxisParam([o],a.shape),u=mB({inputs:{x:a},backend:r,attrs:{reductionIndices:l,keepDims:!1}}),h=tL.expandShapeToKeepDim(u.shape,l),p=c0({inputs:{x:u},backend:r,attrs:{shape:h}}),d=cO({inputs:{a:a,b:p},backend:r}),c=dl({inputs:{x:d},backend:r}),f=f4({inputs:{x:c},backend:r,attrs:{axis:l,keepDims:!1}}),m=c0({inputs:{x:f},backend:r,attrs:{shape:h}}),g=mu({inputs:{a:c,b:m},backend:r});return r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),g}let m0={kernelName:C.Softmax,backendName:"cpu",kernelFunc:mQ},m1={kernelName:C.Multinomial,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=n;pF(a,"multinomial");let l=o?a:mQ({inputs:{logits:a},backend:r,attrs:{dim:-1}}),u=l.shape[0],h=l.shape[1],p=r.data.get(l.dataId).values,d=[u,s],c=nP.util.makeZerosTypedArray(nP.util.sizeFromShape(d),"int32");for(let e=0;e<u;++e){let t=e*h,r=new Float32Array(h-1);r[0]=p[t];for(let e=1;e<r.length;++e)r[e]=r[e-1]+p[t+e];let n=hF.alea(i.toString()),a=e*s;for(let e=0;e<s;++e){let t=n();c[a+e]=r.length;for(let n=0;n<r.length;n++)if(t<r[n]){c[a+e]=n;break}}}return o||r.disposeIntermediateTensorInfo(l),r.makeTensorInfo(d,"int32",c)}};var pD=pD;let m2=pD.nonMaxSuppressionV3Impl,m3={kernelName:C.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=n;pF(a,"NonMaxSuppression");let{selectedIndices:u}=m2(r.data.get(a.dataId).values,r.data.get(s.dataId).values,i,o,l);return r.makeTensorInfo([u.length],"int32",new Int32Array(u))}};var pD=pD;let m4=pD.nonMaxSuppressionV4Impl,m6={kernelName:C.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=n;pF(a,"NonMaxSuppressionPadded");let{selectedIndices:h,validOutputs:p}=m4(r.data.get(a.dataId).values,r.data.get(s.dataId).values,i,o,l,u);return[r.makeTensorInfo([h.length],"int32",new Int32Array(h)),r.makeTensorInfo([],"int32",new Int32Array([p]))]}};var pD=pD;let m5=pD.nonMaxSuppressionV5Impl,m8={kernelName:C.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=n;pF(a,"NonMaxSuppressionWithScore");let{selectedIndices:h,selectedScores:p}=m5(r.data.get(a.dataId).values,r.data.get(s.dataId).values,i,o,l,u);return[r.makeTensorInfo([h.length],"int32",new Int32Array(h)),r.makeTensorInfo([p.length],"float32",new Float32Array(p))]}},m9={kernelName:C.OneHot,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=n;pF(a,"oneHot");let u=nP.util.sizeFromShape(a.shape),h=new Float32Array(u*i);h.fill(l);let p=r.data.get(a.dataId).values;for(let e=0;e<u;++e)p[e]>=0&&p[e]<i&&(h[e*i+p[e]]=o);return r.makeTensorInfo([...a.shape,i],s,h)}};function m7(e){let{inputs:t,backend:r}=e,{x:n}=t;if("string"===n.dtype)throw Error("zerosLike is not supported for string tensors");if("complex64"!==n.dtype)return mc({backend:r,attrs:{shape:n.shape,value:0,dtype:n.dtype}});{let e=pG({inputs:{input:n},backend:r}),t=m7({inputs:{x:e},backend:r}),a=f$({inputs:{input:n},backend:r}),s=m7({inputs:{x:a},backend:r}),i=pP({inputs:{real:t,imag:s},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(s),i}}let ge={kernelName:C.ZerosLike,backendName:"cpu",kernelFunc:m7},gt={kernelName:C.OnesLike,backendName:"cpu",kernelFunc:function e(t){let{inputs:r,backend:n}=t,{x:a}=r;if("string"===a.dtype)throw Error("onesLike is not supported for string tensors");if("complex64"!==a.dtype)return mc({backend:n,attrs:{shape:a.shape,value:1,dtype:a.dtype}});{let t=pG({inputs:{input:a},backend:n}),r=e({inputs:{x:t},backend:n}),s=f$({inputs:{input:a},backend:n}),i=m7({inputs:{x:s},backend:n}),o=pP({inputs:{real:r,imag:i},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}}};function gr(e){let{inputs:t,backend:r,attrs:n}=e,{axis:a}=n;if(1===t.length)return mi({inputs:{input:t[0]},backend:r,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(e=>{nP.util.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),nP.util.assert(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=fR({inputs:t.map(e=>{let t=mi({inputs:{input:e},backend:r,attrs:{dim:a}});return o.push(t),t}),backend:r,attrs:{axis:a}});return o.forEach(e=>r.disposeIntermediateTensorInfo(e)),l}let gn={kernelName:C.Pack,backendName:"cpu",kernelFunc:gr},ga={kernelName:C.PadV2,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{paddings:s,constantValue:i}=n;pF(a,"pad");let o=s.map((e,t)=>e[0]+a.shape[t]+e[1]),l=s.map(e=>e[0]),u=r.data.get(a.dataId).values,h=nP.util.sizeFromShape(a.shape),p=a.shape.length,d=nP.util.computeStrides(a.shape),c=nP.util.sizeFromShape(o),f=o.length,m=nP.util.computeStrides(o),g=nP.util.getTypedArrayFromDType(a.dtype,c);0!==i&&g.fill(i);for(let e=0;e<h;e++){let t=nP.util.indexToLoc(e,p,d).map((e,t)=>e+l[t]);g[nP.util.locToIndex(t,f,m)]=u[e]}return{dataId:r.write(g,o,a.dtype),shape:o,dtype:a.dtype}}},gs=pz((e,t)=>Math.pow(e,t)),gi=pX(C.Pow,gs),go={kernelName:C.Pow,backendName:"cpu",kernelFunc:gi},gl={kernelName:C.RaggedGather,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=n,l=a.map(e=>r.data.get(e.dataId).values),u=a.map(e=>e.shape),h=r.data.get(s.dataId).values,p=r.data.get(i.dataId).values,[d,c,f]=d5(l,u,h,s.shape,s.dtype,p,i.shape,o),m=d.map(e=>r.makeTensorInfo([e.length],"int32",e)),g=r.makeTensorInfo(f,s.dtype,c);return m.concat([g])}},gu={kernelName:C.RaggedRange,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{starts:n,limits:a,deltas:s}=t,i=r.data.get(n.dataId).values,o=r.data.get(a.dataId).values,l=r.data.get(s.dataId).values,[u,h]=d8(i,n.shape,n.dtype,o,a.shape,l,s.shape);return[r.makeTensorInfo([u.length],"int32",u),r.makeTensorInfo([h.length],n.dtype,h)]}},gh={kernelName:C.RaggedTensorToTensor,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=n,u=r.data.get(a.dataId).values,h=r.data.get(s.dataId).values,p=r.data.get(i.dataId).values,d=o.map(e=>r.data.get(e.dataId).values),c=o.map(e=>e.shape),[f,m]=cr(u,a.shape,h,s.shape,s.dtype,p,i.shape,d,c,l);return r.makeTensorInfo(f,s.dtype,m)}},gp={kernelName:C.Range,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:r}=e,{start:n,stop:a,dtype:s,step:i}=r,o=cn(n,a,i,s);return t.makeTensorInfo([o.length],s,o)}},gd=p8(C.Reciprocal,e=>1/e),gc={kernelName:C.Reciprocal,backendName:"cpu",kernelFunc:gd},gf={kernelName:C.ResizeBilinear,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=n;pF(a,"resizeBilinear");let l=nP.util.computeStrides(a.shape),[u,h]=o,[p,d,c,f]=a.shape,m=r.data.get(a.dataId).values,g=new Float32Array(nP.util.sizeFromShape([p,u,h,f])),y=[s&&u>1?d-1:d,s&&h>1?c-1:c],b=[s&&u>1?u-1:u,s&&h>1?h-1:h],x=0,v=y[0]/b[0],w=y[1]/b[1];for(let e=0;e<p;e++)for(let t=0;t<u;t++){let r,n=Math.max(0,Math.floor(r=i?v*(t+.5)-.5:v*t)),a=r-n,s=Math.min(d-1,Math.ceil(r)),o=e*l[0]+n*l[1],u=e*l[0]+s*l[1];for(let e=0;e<h;e++){let t,r=Math.max(0,Math.floor(t=i?w*(e+.5)-.5:w*e)),n=t-r,s=Math.min(c-1,Math.ceil(t)),h=o+r*l[2],p=u+r*l[2],d=o+s*l[2],y=u+s*l[2];for(let e=0;e<f;e++){let t=m[h+e],r=m[p+e],s=m[d+e],i=m[y+e],o=t+(s-t)*n,l=o+(r+(i-r)*n-o)*a;g[x++]=l}}}return r.makeTensorInfo([p,u,h,f],"float32",g)}},gm={kernelName:C.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a,dy:s}=t,{alignCorners:i}=n;pF([s,a],"resizeBilinearGrad");let o=nP.util.computeStrides(a.shape),[l,u,h,p]=a.shape,[,d,c]=s.shape,f=new Float32Array(l*u*h*p),m=[i&&d>1?u-1:u,i&&c>1?h-1:h],g=[i&&d>1?d-1:d,i&&c>1?c-1:c],y=m[0]/g[0],b=m[1]/g[1],x=r.data.get(s.dataId).values,v=0;for(let e=0;e<l;e++){let t=e*o[0];for(let e=0;e<d;e++){let r=e*y,n=Math.floor(r),a=Math.min(Math.ceil(r),u-1),s=t+n*o[1],i=t+a*o[1],l=r-n,d=1-l;for(let e=0;e<c;e++){let t=e*b,r=Math.floor(t),n=Math.min(Math.ceil(t),h-1),a=t-r,u=1-a,c=s+r*o[2],m=s+n*o[2],g=i+r*o[2],y=i+n*o[2],w=d*u,S=d*a,N=l*u,k=l*a;for(let e=0;e<p;e++){let t=x[v++];f[c+e]+=t*w,f[m+e]+=t*S,f[g+e]+=t*N,f[y+e]+=t*k}}}}return r.makeTensorInfo([l,h,u,p],"float32",f)}},gg={kernelName:C.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=n;pF(a,"resizeNearestNeighbor");let l=nP.util.computeStrides(a.shape),[u,h]=o,[p,d,c,f]=a.shape,m=r.data.get(a.dataId).values,g=new Float32Array(p*u*h*f),y=[s&&u>1?d-1:d,s&&h>1?c-1:c],b=[s&&u>1?u-1:u,s&&h>1?h-1:h],x=y[0]/b[0],v=y[1]/b[1],w=0;for(let e=0;e<p;e++){let t=e*l[0];for(let e=0;e<u;e++){let r=i?x*(e+.5):x*e,n=Math.min(d-1,s?Math.round(r):Math.floor(r));i&&(n=Math.max(0,n));let a=t+n*l[1];for(let e=0;e<h;e++){let t=i?v*(e+.5):v*e,r=Math.min(c-1,s?Math.round(t):Math.floor(t));i&&(r=Math.max(0,r));let n=a+r*l[2];for(let e=0;e<f;e++){let t=m[n+e];g[w++]=t}}}}return r.makeTensorInfo([p,u,h,f],a.dtype,g)}},gy={kernelName:C.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a,dy:s}=t,{alignCorners:i}=n;pF([s,a],"resizeNearestNeighborGrad");let o=nP.util.computeStrides(a.shape),l=nP.util.computeStrides(s.shape),[u,h,p,d]=a.shape,[,c,f]=s.shape,m=new Float32Array(u*h*p*d),g=r.data.get(s.dataId).values,y=[i&&c>1?h-1:h,i&&f>1?p-1:p],b=[i&&c>1?c-1:c,i&&f>1?f-1:f],x=y[0]/b[0],v=y[1]/b[1],w=1/x,S=1/v,N=2*Math.ceil(w)+2,k=2*Math.ceil(S)+2;for(let e=0;e<u;e++){let t=e*o[0];for(let e=0;e<h;e++){let r=t+e*o[1],n=Math.floor(Math.floor(e*w)-N/2);for(let a=0;a<p;a++){let s=r+a*o[2],u=Math.floor(Math.floor(a*S)-k/2);for(let r=0;r<d;r++){let o=0;for(let s=0;s<N;s++){let d=s+n;if(d<0||d>=c)continue;let m=t+d*l[1],y=d*x;if(e===Math.min(h-1,i?Math.round(y):Math.floor(y)))for(let e=0;e<k;e++){let t=e+u;if(t<0||t>=f)continue;let n=m+t*l[2],s=t*v;a===Math.min(p-1,i?Math.round(s):Math.floor(s))&&(o+=g[n+r])}}m[s+r]=o}}}}return r.makeTensorInfo(a.shape,a.dtype,m)}},gb={kernelName:C.Reverse,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{dims:s}=n;pF(a,"reverse");let i=a.shape.length,o=nP.util.parseAxisParam(s,a.shape);if(0===i)return pW({inputs:{x:a},backend:r});let l=new rI.TensorBuffer(a.shape,a.dtype),u=r.bufferSync(a);for(let e=0;e<l.size;e++){let t=l.indexToLoc(e),r=t.slice();o.forEach(e=>r[e]=a.shape[e]-1-r[e]),l.set(u.get(...r),...t)}return r.makeTensorInfo(l.shape,l.dtype,l.values)}};var tL=tL;let gx={kernelName:C.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{image:n}=e,{radians:a,fillValue:s,center:i}=t,o=nP.util.getTypedArrayFromDType(n.dtype,nP.util.sizeFromShape(n.shape)),[l,u,h,p]=n.shape,[d,c]=tL.getImageCenter(i,u,h),f=Math.sin(a),m=Math.cos(a),g=r.data.get(n.dataId).values;for(let e=0;e<l;e++){let t=e*h*u*p;for(let e=0;e<u;e++){let r=h*p*e;for(let n=0;n<h;n++){let a=n*p;for(let i=0;i<p;i++){let y=[l,e,n,i],b=y[2],x=y[1],v=(b-d)*m-(x-c)*f,w=(b-d)*f+(x-c)*m;v=Math.round(v+d),w=Math.round(w+c);let S=s;"number"!=typeof s&&(S=3===i?255:s[i]),v>=0&&v<h&&w>=0&&w<u&&(S=g[t+h*p*w+v*p+i]),o[t+r+a+i]=S}}}}return{dataId:r.write(o,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},gv=p8(C.Round,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),gw={kernelName:C.Round,backendName:"cpu",kernelFunc:gv};var tL=tL;let gS={kernelName:C.ScatterNd,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{indices:a,updates:s}=t,{shape:i}=n,{sliceRank:o,numUpdates:l,sliceSize:u,strides:h,outputSize:p}=tL.calculateShapes(s,a,i),d=co(r.bufferSync(a),r.bufferSync(s),i,p,u,l,o,h,0,!0);return r.makeTensorInfo(i,d.dtype,d.values)}},gN={kernelName:C.SearchSorted,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{sortedSequence:a,values:s}=t,{side:i}=n,o=function(e,t,r,n,a,s){let i=nP.util.getArrayFromDType("int32",r*a);for(let o=0;o<r;++o){let r=e.slice(o*n,(o+1)*n),l=o*a;for(let e=0;e<a;++e)i[l+e]="left"===s?function(e,t){let r=0,n=e.length,a=0;for(;r<n;)e[a=Math.floor((r+n)/2)]<t?r=a+1:n=a;return n}(r,t[e+l]):function(e,t){let r=0,n=e.length,a=0;for(;r<n;)e[a=Math.floor((r+n)/2)]<=t?r=a+1:n=a;return n}(r,t[e+l])}return i}(r.data.get(a.dataId).values,r.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],i);return r.makeTensorInfo(s.shape,"int32",o)}},gk={kernelName:C.Select,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{condition:n,t:a,e:s}=t;pF([n,a,s],"select");let i=n.shape.length,o=r.data.get(n.dataId).values,l=r.data.get(a.dataId).values,u=r.data.get(s.dataId).values,h=(0,dQ.upcastType)(a.dtype,s.dtype),p=nP.util.makeZerosTypedArray(nP.util.sizeFromShape(a.shape),h),d=0,c=0===i||i>1||1===a.shape.length?1:nP.util.sizeFromShape(a.shape.slice(1));for(let e=0;e<o.length;e++)for(let t=0;t<c;t++)1===o[e]?p[d++]=l[e]:p[d++]=u[e];return r.makeTensorInfo(a.shape,h,p)}};var tL=tL;let gI=tL.SELU_SCALEALPHA,gT=tL.SELU_SCALE,gC=p8(C.Selu,e=>e>=0?gT*e:gI*(Math.exp(e)-1)),gE={kernelName:C.Selu,backendName:"cpu",kernelFunc:gC},g$=p8(C.Sign,e=>e<0?-1:+(e>0)),gA={kernelName:C.Sign,backendName:"cpu",kernelFunc:g$},gR=p8(C.Sin,e=>Math.sin(e)),gD={kernelName:C.Sin,backendName:"cpu",kernelFunc:gR},gF=p8(C.Sinh,e=>Math.sinh(e)),gO={kernelName:C.Sinh,backendName:"cpu",kernelFunc:gF},g_=Math.log(11920928955078125e-23)+2,gM=p8(C.Softplus,e=>{let t=Math.exp(e);return e<g_?t:e>-g_?e:Math.log(1+t)}),gL={kernelName:C.Softplus,backendName:"cpu",kernelFunc:gM};var tL=tL;let gz={kernelName:C.SpaceToBatchND,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{blockShape:s,paddings:i}=n;pF([a],"spaceToBatchND");let o=nP.util.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let e=1+s.length;e<a.shape.length;++e)l.push([0,0]);let u=ga.kernelFunc({inputs:{x:a},backend:r,attrs:{paddings:l,constantValue:0}}),h=tL.getReshaped(u.shape,s,o,!1),p=tL.getPermuted(h.length,s.length,!1),d=tL.getReshapedPermuted(u.shape,s,o,!1),c=c0({inputs:{x:u},backend:r,attrs:{shape:h}}),f=d1({inputs:{x:c},backend:r,attrs:{perm:p}}),m=c0({inputs:{x:f},backend:r,attrs:{shape:d}});return r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(f),m}},gP={kernelName:C.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{indices:n,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(2!==n.shape.length)throw Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(1!==a.shape.length)throw Error(`Values must be a vector, saw:
        ${a.shape}`);if(0!==i.shape.length)throw Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=r.data.get(n.dataId).values,l=r.data.get(a.dataId).values,u=r.data.get(s.dataId).values,h=r.data.get(i.dataId).values[0],[p,d,c,f,m]=cm(o,n.shape,n.dtype,l,a.dtype,u,h);return[r.makeTensorInfo(d,n.dtype,p),r.makeTensorInfo([d[0]],a.dtype,c),r.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),r.makeTensorInfo([m.length],n.dtype,new Int32Array(m))]}},gB={kernelName:C.SparseReshape,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{inputIndices:n,inputShape:a,newShape:s}=t;if(2!==n.shape.length)throw Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(1!==a.shape.length)throw Error(`Input shape should be a vector but received shape
        ${a.shape}`);if(1!==s.shape.length)throw Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(r.data.get(a.dataId).values),o=r.data.get(n.dataId).values,l=Array.from(r.data.get(s.dataId).values),[u,h,p]=cg(o,n.shape,n.dtype,i,l);return[r.makeTensorInfo(h,n.dtype,u),r.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}},gV={kernelName:C.SparseSegmentMean,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{data:n,indices:a,segmentIds:s}=t;if(n.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw Error(`Indices should be a vector but received shape
          ${a.shape}`);if(1!==s.shape.length)throw Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw Error("segmentIds and indices should have same size.");let i=r.data.get(n.dataId).values,o=r.data.get(a.dataId).values,l=r.data.get(s.dataId).values,[u,h]=cy(i,n.shape,n.dtype,o,l,!0);return r.makeTensorInfo(h,n.dtype,u)}},gW={kernelName:C.SparseSegmentSum,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{data:n,indices:a,segmentIds:s}=t;if(n.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw Error(`Indices should be a vector but received shape
         ${a.shape}`);if(1!==s.shape.length)throw Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw Error("segmentIds and indices should have same size.");let i=r.data.get(n.dataId).values,o=r.data.get(a.dataId).values,l=r.data.get(s.dataId).values,[u,h]=cy(i,n.shape,n.dtype,o,l);return r.makeTensorInfo(h,n.dtype,u)}};var tL=tL;let gU={kernelName:C.SparseToDense,backendName:"cpu",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{sparseIndices:s,sparseValues:i,defaultValue:o}=r,{outputShape:l}=a,{sliceRank:u,numUpdates:h,sliceSize:p,strides:d,outputSize:c}=tL.calculateShapes(i,s,l),f=n.bufferSync(s);switch(i.dtype){case"bool":t=co(f,n.bufferSync(i),l,c,p,h,u,d,!!n.data.get(o.dataId).values[0],!1);break;case"float32":case"int32":t=co(f,n.bufferSync(i),l,c,p,h,u,d,n.data.get(o.dataId).values[0],!1);break;case"string":t=co(f,n.bufferSync(i),l,c,p,h,u,d,nP.util.decodeString(n.data.get(o.dataId).values[0]),!1);break;default:throw Error(`Unsupported type ${i.dtype}`)}return n.makeTensorInfo(l,t.dtype,t.values)}};var tL=tL;let gG={kernelName:C.SplitV,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=nP.util.parseAxisParam(i,a.shape)[0],l=tL.prepareSplitSize(a,s,o),u=Array(a.shape.length).fill(0),h=a.shape.slice();return l.map(e=>{let t=[...h];t[o]=e;let n=cc({inputs:{x:a},backend:r,attrs:{begin:u,size:t}});return u[o]+=e,n})}},gq={kernelName:C.Square,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:r}=e;pF(r,"square");let n=t.data.get(r.dataId).values,a=new Float32Array(n.length);for(let e=0;e<n.length;++e){let t=n[e];a[e]=t*t}return{dataId:t.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},gH=p8(C.Step,(e,t)=>isNaN(e)?NaN:e>0?1:t.alpha),gj={kernelName:C.Step,backendName:"cpu",kernelFunc:gH};var cp=t9;let gK={kernelName:C.StridedSlice,backendName:"cpu",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s}=r,{begin:i,end:o,strides:l,beginMask:u,endMask:h,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:c}=a;pF(s,"stridedSlice");let{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:x,end:v,strides:w}=cp.sliceInfo(s.shape,i,o,l,u,h,p,d,c);if(g)t=c0({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||b){nP.util.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let e=cp.computeOutShape(x,v,w),r=cc({inputs:{x:s},backend:n,attrs:{begin:x,size:e}});t=c0({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(r)}else{let e=cC(f,n.bufferSync(s),w,x);t=n.makeTensorInfo(m,e.dtype,e.values)}return t}},gX={kernelName:C.StringNGrams,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=n,{data:h,dataSplits:p}=t,[d,c]=c$(r.data.get(h.dataId).values,r.data.get(p.dataId).values,a,s,i,o,l,u);return[r.makeTensorInfo([d.length],"string",d),r.makeTensorInfo(p.shape,"int32",c)]}},gZ={kernelName:C.StringSplit,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{skipEmpty:a}=n,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw Error("Input must be of datatype string");if(1!==s.shape.length)throw Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let[o,l,u]=cA(r.data.get(s.dataId).values,r.data.get(i.dataId).values[0],a),h=l.length;return[r.makeTensorInfo([h,2],"int32",o),r.makeTensorInfo([h],"string",l),r.makeTensorInfo([2],"int32",new Int32Array(u))]}},gY={kernelName:C.StringToHashBucketFast,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{numBuckets:a}=n,{input:s}=t;if("string"!==s.dtype)throw Error("Input must be of datatype string");if(a<=0)throw Error("Number of buckets must be at least 1");let i=cR(r.data.get(s.dataId).values,a);return r.makeTensorInfo(s.shape,"int32",i)}},gJ=p8(C.Tan,e=>Math.tan(e)),gQ={kernelName:C.Tan,backendName:"cpu",kernelFunc:gJ},g0=p8(C.Tanh,e=>Math.tanh(e)),g1={kernelName:C.Tanh,backendName:"cpu",kernelFunc:g0};var tL=tL;function g2(e,t,r){switch(r){case"reflect":var n,a,s,i,o=e,l=t;let u=o;if(u<0)if(l<=1)u=0;else{let e=2*l;u<e&&(u=e*Math.trunc(-u/e)+u),u=u<-l?u+e:-u-1}else if(u>l-1)if(l<=1)u=0;else{let e=2*l;(u-=e*Math.trunc(u/e))>=l&&(u=e-u-1)}return nP.util.clamp(0,u,l-1);case"wrap":let h;return n=e,a=t,(h=n)<0?a<=1?h=0:h+=a*(Math.trunc(-h/(a-1))+1):h>a-1&&(a<=1?h=0:h-=a*Math.trunc(h/(a-1))),nP.util.clamp(0,h,a-1);case"nearest":return s=e,i=t,nP.util.clamp(0,s,i-1);default:return e}}function g3(e,t,r,n,a,s,i,o,l,u,h){return 0<=o&&o<t&&0<=l&&l<r?e[i*n+o*a+l*s+u]:h}for(let e of[c4,pL,c5,c9,p0,c7,fe,ft,fr,fn,fs,fo,fu,fd,ff,fb,fx,fv,fw,c3,fS,fN,fk,p6,fI,pK,dt,fC,pB,fE,fD,fO,f_,fM,fL,fz,fP,fV,fU,fG,fq,fH,fj,fK,fZ,fY,fJ,fQ,f0,f1,f2,f3,f5,cW,f8,ds,ms,du,mo,dd,md,mf,mm,dm,db,mg,my,mb,mx,dN,dT,pU,mv,fA,mS,mk,mT,cG,d$,dD,mC,dM,m$,mD,mO,mL,mz,mP,mV,dB,mW,mU,mG,mq,mH,mj,mK,dU,mX,mJ,m1,dj,dX,m3,m6,m8,dJ,m9,gt,gn,ga,go,cj,d4,gl,gu,gh,gp,pq,mh,gc,cX,cY,c1,gf,gm,gg,gy,gb,gx,gw,ci,gS,gN,gk,gE,ch,gA,gD,gO,cf,m0,gL,gz,gP,gB,gV,gW,gU,gG,cv,gq,cN,cT,gj,gK,gX,gZ,gY,c_,f6,gQ,g1,{kernelName:C.TensorScatterUpdate,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{tensor:n,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:h}=tL.calculateShapes(s,a,n.shape),p=r.bufferSync(a),d=r.bufferSync(s),c=r.bufferSync(n),f=co(p,d,n.shape,h,l,o,i,u,c,!1);return r.makeTensorInfo(n.shape,f.dtype,f.values)}},{kernelName:C.Tile,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{reps:s}=n;pF(a,"tile");let i=cM(r.bufferSync(a),s);return r.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:C.TopK,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{k:s,sorted:i}=n;pF(a,"topk");let[o,l]=cz(r.data.get(a.dataId).values,a.shape,a.dtype,s,i);return[r.makeTensorInfo(o.shape,o.dtype,o.values),r.makeTensorInfo(l.shape,l.dtype,l.values)]}},{kernelName:C.Transform,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:r,backend:n}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[h,p,d,c]=a.shape,[f,m]=null!=u?u:[p,d],g=[h,f,m,c],y=nP.util.computeStrides(a.shape),b=y[0],x=y[1],v=y[2],w=nP.util.computeStrides(g),S=w[0],N=w[1],k=w[2],I=nP.util.getTypedArrayFromDType(a.dtype,nP.util.sizeFromShape(g));I.fill(l);let T=n.data.get(a.dataId).values,C=n.data.get(s.dataId).values;for(let e=0;e<h;++e){let t=1===s.shape[0]?C:C.subarray(8*e,8*e+8);for(let r=0;r<f;++r)for(let n=0;n<m;++n)for(let a=0;a<c;++a){let s,u=t[6]*n+t[7]*r+1;if(0===u)continue;let h=(t[0]*n+t[1]*r+t[2])/u,c=(t[3]*n+t[4]*r+t[5])/u,f=g2(h,d,o),m=g2(c,p,o);switch(i){case"nearest":s=g3(T,p,d,b,x,v,e,Math.round(m),Math.round(f),a,l);break;case"bilinear":s=function(e,t,r,n,a,s,i,o,l,u,h){let p=Math.floor(o),d=Math.floor(l),c=p+1,f=d+1,m=(f-l)*g3(e,t,r,n,a,s,i,p,d,u,h)+(l-d)*g3(e,t,r,n,a,s,i,p,f,u,h),g=(f-l)*g3(e,t,r,n,a,s,i,c,d,u,h)+(l-d)*g3(e,t,r,n,a,s,i,c,f,u,h);return(c-o)*m+(o-p)*g}(T,p,d,b,x,v,e,m,f,a,l);break;default:throw Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}I[e*S+r*N+n*k+a]=s}return n.makeTensorInfo(g,a.dtype,I)}return{dataId:n.write(I,g,a.dtype),shape:a.shape,dtype:a.dtype}}},d2,{kernelName:C.Unique,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:r,backend:n}=e,{axis:a}=r,{x:s}=t;pF(s,"unique");let{outputValues:i,outputShape:o,indices:l}=cP(n.data.get(s.dataId).values,a,s.shape,s.dtype);return[n.makeTensorInfo(o,s.dtype,i),n.makeTensorInfo([l.length],"int32",l)]}},{kernelName:C.Unpack,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{value:a}=t,{axis:s}=n;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=Array(i-1),u=0;for(let e=0;e<i;e++)e!==s&&(l[u++]=a.shape[e]);let h=Array(i).fill(0),p=a.shape.slice();p[s]=1;let d=Array(o);for(let e=0;e<d.length;e++){h[s]=e;let t=cc({inputs:{x:a},backend:r,attrs:{begin:h,size:p}});d[e]=c0({inputs:{x:t},backend:r,attrs:{shape:l}}),r.disposeIntermediateTensorInfo(t)}return d}},{kernelName:C.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,segmentIds:s}=t,{numSegments:i}=n;pF(a,"unsortedSegmentSum");let o=a.shape.length,l=s.shape.length,u=[],h=[],p=o-l,d=s;for(let e=0;e<p;++e){let t=mi({inputs:{input:d},backend:r,attrs:{dim:e+1}});d=t,h.push(t)}for(let e=0;e<i;++e){let t=nP.util.createScalarValue(e,"int32"),n=r.makeTensorInfo([],"int32",t),s=da({inputs:{a:n,b:d},backend:r}),i=pj({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),o=dH({inputs:{a:i,b:a},backend:r}),l=f4({inputs:{x:o},backend:r,attrs:{axis:0,keepDims:!1}});u.push(l),h.push(n),h.push(s),h.push(i),h.push(o),h.push(l)}let c=gr({inputs:u,backend:r,attrs:{axis:0}});return h.forEach(e=>r.disposeIntermediateTensorInfo(e)),c}},ge])(0,rN.registerKernel)(e);var g4=e.i(62893),g4=g4,g4=g4;let g6={},g5={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function g8(e,t){g6[e]=t}function g9(e,t){if(!(e in g6)||null!=t){let r=function(e,t){if(1!==e&&2!==e)throw Error("Cannot get WebGL rendering context, WebGL is disabled.");let r=null==t?function(e){if(!(0,nL.env)().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw Error("Cannot create a canvas in this context")}(e):t;return(r.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete g6[e]},!1),(0,nL.env)().getBool("SOFTWARE_WEBGL_ENABLED")&&(g5.failIfMajorPerformanceCaveat=!1),1===e)?r.getContext("webgl",g5)||r.getContext("experimental-webgl",g5):r.getContext("webgl2",g5)}(e,t);if(null===r)return console.log("Could not get context for WebGL version",e),null;g6[e]=r}let r=g6[e];return null==r||r.isContextLost()?(delete g6[e],g9(e)):(r.disable(r.DEPTH_TEST),r.disable(r.STENCIL_TEST),r.disable(r.BLEND),r.disable(r.DITHER),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SAMPLE_COVERAGE),r.enable(r.SCISSOR_TEST),r.enable(r.CULL_FACE),r.cullFace(r.BACK),g6[e])}function g7(e){let t=Math.ceil(nP.util.sizeFromShape(e)/4);return nP.util.sizeToSquarishShape(t)}function ye(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function yt(e,t){let r,n,a,s,i,o,l,u,h,p;return 2===(0,nL.env)().getNumber("WEBGL_VERSION")?(r=e.R32F,n=e.R16F,a=e.RGBA16F,s=e.RGBA32F,i=e.RED,l=4,u=1,h=e.HALF_FLOAT,p=e.FLOAT,o=e.RGBA8):(r=e.RGBA,n=e.RGBA,a=e.RGBA,s=e.RGBA,i=e.RGBA,l=4,u=4,h=null!=t?t.HALF_FLOAT_OES:null,p=e.FLOAT,o=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:n,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:o,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:p}}function yr(e,t){let r=t();return(0,nL.env)().getBool("DEBUG")&&function(e){let t=e.getError();if(t!==e.NO_ERROR)throw Error("WebGL Error: "+ya(e,t))}(e),r}function yn(e){return!!((0,nL.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||596e-10<Math.abs(e)&&65504>Math.abs(e))}function ya(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function ys(e,t){return yA(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function yi(e,t){let r=yA(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(yr(e,()=>e.shaderSource(r,t)),yr(e,()=>e.compileShader(r)),!1===e.getShaderParameter(r,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(r)),Error("Failed to compile vertex shader.");return r}function yo(e,t){let r=yA(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(yr(e,()=>e.shaderSource(r,t)),yr(e,()=>e.compileShader(r)),(0,nL.env)().get("ENGINE_COMPILE_ONLY"))return r;if(!1===e.getShaderParameter(r,e.COMPILE_STATUS))throw yu(t,e.getShaderInfoLog(r)),Error("Failed to compile fragment shader.");return r}(o=c||(c={}))[o.DENSE=0]="DENSE",o[o.SHARED_BATCH=1]="SHARED_BATCH",(l=f||(f={}))[l.RENDER=0]="RENDER",l[l.UPLOAD=1]="UPLOAD",l[l.PIXELS=2]="PIXELS",l[l.DOWNLOAD=3]="DOWNLOAD",(u=m||(m={}))[u.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",u[u.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",u[u.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",u[u.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",u[u.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16";let yl=/ERROR: [0-9]+:([0-9]+):/g;function yu(e,t){let r=yl.exec(t);if(null==r){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let n=+r[1],a=e.split("\n"),s=a.length.toString().length+2,i=a.map((e,t)=>nP.util.rightPad((t+1).toString(),s)+e),o=0;for(let e=0;e<i.length;e++)o=Math.max(i[e].length,o);let l=i.slice(0,n-1),u=i.slice(n-1,n),h=i.slice(n);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${nP.util.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join("\n"))}function yh(e){return yA(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function yp(e,t){if(yr(e,()=>e.linkProgram(t)),!(0,nL.env)().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),Error("Failed to link vertex and fragment shaders.")}function yd(e,t){if(yr(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),Error("Shader program validation failed.")}function yc(e,t){let r=yA(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return yr(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),yr(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),r}function yf(e,t){let r=yA(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return yr(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r)),yr(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),r}function ym(){return 2===(0,nL.env)().getNumber("WEBGL_VERSION")?1:4}function yg(e){return yA(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function yy(e,t){let r=(0,nL.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>r||t>r)throw Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${r}x${r}].`)}function yb(e){return yA(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function yx(e,t,r,n,a,s,i){let o=e.getAttribLocation(t,r);return -1!==o&&(yr(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),yr(e,()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i)),yr(e,()=>e.enableVertexAttribArray(o)),!0)}function yv(e,t,r){yR(e,r),yr(e,()=>e.activeTexture(e.TEXTURE0+r)),yr(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function yw(e,t){yR(e,t),yr(e,()=>e.activeTexture(e.TEXTURE0+t)),yr(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function yS(e,t,r){return yA(e,()=>e.getUniformLocation(t,r),'uniform "'+r+'" not present in program.')}function yN(e,t,r){return e.getUniformLocation(t,r)}function yk(e,t,r,n){yr(e,()=>yv(e,t,n)),yr(e,()=>e.uniform1i(r,n))}function yI(e){yr(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),yr(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),yr(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function yT(e,t,r){yr(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,r)),yr(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function yC(e,t){yr(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),yr(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function yE(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw Error("Error binding framebuffer: "+y$(e,t))}function y$(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function yA(e,t,r){let n=yr(e,()=>t());if(null==n)throw Error(r);return n}function yR(e,t){let r=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=t+e.TEXTURE0;if(n<e.TEXTURE0||n>r){let e=`[gl.TEXTURE0, gl.TEXTURE${r}]`;throw Error(`textureUnit must be in ${e}.`)}}function yD(e,t=2){return nP.util.sizeFromShape(e.slice(0,e.length-t))}function yF(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function yO(e){let t=[1,1,1];return 0!==e.length&&(1!==e.length||1!==e[0])&&(t=[yD(e),...yF(e)]),t}function y_(e,t=!1){let r=(0,nL.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),n=(0,nL.env)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");n===1/0&&(0,nL.env)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(n=r/2),t&&(r*=2,n*=2,1===(e=e.map((t,r)=>r>=e.length-2?nP.util.nearestLargerEven(e[r]):e[r])).length&&(e=[2,e[0]])),2!==e.length&&(e=nP.util.squeezeShape(e).newShape);let a=nP.util.sizeFromShape(e),s=null;e.length<=1&&a<=r?s=[1,a]:2===e.length&&e[0]<=r&&e[1]<=r?s=e:3===e.length&&e[0]*e[1]<=r&&e[2]<=r?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=r&&e[1]*e[2]<=r?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=r&&e[3]<=r?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=r&&e[1]*e[2]*e[3]<=r&&(s=[e[0],e[1]*e[2]*e[3]]);let i=null!=s&&Math.max(...s)>n&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||i)if(t){let t=yD(e),r=2,n=2;e.length&&([r,n]=yF(e)),a=r/2*t*(n/2),s=nP.util.sizeToSquarishShape(a).map(e=>2*e)}else s=nP.util.sizeToSquarishShape(a);return s}function yM(e,t){if(e=e.slice(-2),t=t.slice(-2),nP.util.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let r=e[e.length-1],n=t[t.length-1];if(r===n||r%2==0&&n%2==0&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&e[0]%2==0&&t[0]%2==0}function yL(e){if(null==r){let t=g9(e);r=t.getParameter(t.MAX_TEXTURE_SIZE)}return r}function yz(){r=null}function yP(){n=null}function yB(e){if(null==n){let t=g9(e);n=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,n)}function yV(e){if(0===e)return 0;let t=g9(e);return yW(t,"EXT_disjoint_timer_query_webgl2")&&2===e?2:+!!yW(t,"EXT_disjoint_timer_query")}function yW(e,t){return null!=e.getExtension(t)}function yU(e){try{let t=g9(e);if(null!=t)return!0}catch(e){console.log("Error when getting WebGL context: ",e)}return!1}function yG(e){if(0===e)return!1;let t=g9(e);if(1===e){if(!yW(t,"OES_texture_float"))return!1}else if(!yW(t,"EXT_color_buffer_float"))return!1;return yH(t)}function yq(e){if(0===e)return!1;let t=g9(e);if(1===e){if(!yW(t,"OES_texture_float")||!yW(t,"WEBGL_color_buffer_float"))return!1}else{if(yW(t,"EXT_color_buffer_float"))return yH(t);let e="EXT_color_buffer_half_float";if(yW(t,e)){var r;let n,a,s,i,o=t.getExtension(e);return n=yt(r=t,o),a=r.createTexture(),r.bindTexture(r.TEXTURE_2D,a),r.texImage2D(r.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null),s=r.createFramebuffer(),r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,a,0),i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE,r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(a),r.deleteFramebuffer(s),i}return!1}return yH(t)}function yH(e){let t=yt(e),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let n=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(n),a}function yj(e){return 2===e&&null!=g9(e).fenceSync}function yK(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&nP.util.assert("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}e.s(["assertNotComplex",()=>yK,"bindCanvasToFramebuffer",()=>yI,"bindColorTextureToFramebuffer",()=>yT,"bindTextureToProgramUniformSampler",()=>yk,"bindTextureUnit",()=>yv,"bindVertexBufferToProgramAttribute",()=>yx,"callAndCheck",()=>yr,"canBeRepresented",()=>yn,"createFragmentShader",()=>yo,"createFramebuffer",()=>yb,"createProgram",()=>yh,"createStaticIndexBuffer",()=>yf,"createStaticVertexBuffer",()=>yc,"createTexture",()=>yg,"createVertexShader",()=>yi,"getBatchDim",()=>yD,"getExtensionOrThrow",()=>ys,"getFramebufferErrorMessage",()=>y$,"getMaxTexturesInShader",()=>yB,"getNumChannels",()=>ym,"getProgramUniformLocation",()=>yN,"getProgramUniformLocationOrThrow",()=>yS,"getRowsCols",()=>yF,"getShapeAs3D",()=>yO,"getTextureShapeFromLogicalShape",()=>y_,"getWebGLDisjointQueryTimerVersion",()=>yV,"getWebGLErrorMessage",()=>ya,"getWebGLMaxTextureSize",()=>yL,"hasExtension",()=>yW,"isCapableOfRenderingToFloatTexture",()=>yG,"isDownloadFloatTextureEnabled",()=>yq,"isReshapeFree",()=>yM,"isWebGLFenceEnabled",()=>yj,"isWebGLVersionEnabled",()=>yU,"linkProgram",()=>yp,"logShaderSourceAndInfoLog",()=>yu,"resetMaxTextureSize",()=>yz,"resetMaxTexturesInShader",()=>yP,"unbindColorTextureFromFramebuffer",()=>yC,"unbindTextureUnit",()=>yw,"validateFramebuffer",()=>yE,"validateProgram",()=>yd,"validateTextureSize",()=>yy],19392);let yX=(0,nL.env)();yX.registerFlag("HAS_WEBGL",()=>yX.getNumber("WEBGL_VERSION")>0),yX.registerFlag("WEBGL_VERSION",()=>yU(2)?2:+!!yU(1)),yX.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),yX.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===yX.get("WEBGL_VERSION")),yX.registerFlag("WEBGL_CPU_FORWARD",()=>!0),yX.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),yX.registerFlag("WEBGL_PACK",()=>yX.getBool("HAS_WEBGL")),yX.registerFlag("WEBGL_PACK_NORMALIZATION",()=>yX.getBool("WEBGL_PACK")),yX.registerFlag("WEBGL_PACK_CLIP",()=>yX.getBool("WEBGL_PACK")),yX.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>yX.getBool("WEBGL_PACK")),yX.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>yX.getBool("WEBGL_PACK")),yX.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>yX.getBool("WEBGL_PACK")),yX.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>yX.getBool("WEBGL_PACK")),yX.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>yX.getBool("WEBGL_PACK")),yX.registerFlag("WEBGL_PACK_REDUCE",()=>yX.getBool("WEBGL_PACK")),yX.registerFlag("WEBGL_LAZILY_UNPACK",()=>yX.getBool("WEBGL_PACK")),yX.registerFlag("WEBGL_CONV_IM2COL",()=>yX.getBool("WEBGL_PACK")),yX.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>yX.getBool("WEBGL_PACK")),yX.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>yL(yX.getNumber("WEBGL_VERSION"))),yX.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>yB(yX.getNumber("WEBGL_VERSION"))),yX.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=yX.getNumber("WEBGL_VERSION");return 0===e?0:yV(e)}),yX.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>yX.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!g4.isMobile()),yX.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>yG(yX.getNumber("WEBGL_VERSION"))),yX.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!yX.getBool("WEBGL_FORCE_F16_TEXTURES")&&yX.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),yX.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>yq(yX.getNumber("WEBGL_VERSION"))),yX.registerFlag("WEBGL_FENCE_API_ENABLED",()=>yj(yX.getNumber("WEBGL_VERSION"))),yX.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>4*!!yX.getBool("WEBGL_RENDER_FLOAT32_ENABLED")),yX.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if("number"!=typeof e)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),yX.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>g4.isMobile()?1:-1,e=>{if("number"!=typeof e)throw Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)}),yX.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),yX.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),yX.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),yX.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),yX.registerFlag("WEBGL_EXP_CONV",()=>!1),yX.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>yX.getBool("IS_TEST")),yX.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),yX.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),yX.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),yX.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);var tL=tL,yZ=pR,pD=pD;function yY(){let e,t,r,n,a,s,i,o,l,u;return 2===(0,nL.env)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",r="out",n="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=(0,nL.env)().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",r="varying",n="varying",a="texture2D",s="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:r,varyingFs:n,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}var tL=tL,tL=tL;function yJ(e,t,r="index"){let n=nP.util.computeStrides(t);return n.map((t,a)=>{let s=`int ${e[a]} = ${r} / ${t}`,i=a===n.length-1?`int ${e[a+1]} = ${r} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`;return`${s}; ${i};`}).join("")}function yQ(e,t,r="index"){let n=nP.util.computeStrides(t);return n.map((t,a)=>{let s=`int ${e[a]} = ${r} / outShapeStrides[${a}]`,i=a===n.length-1?`int ${e[a+1]} = ${r} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${s}; ${i};`}).join("")}function y0(e){let t=nP.util.computeStrides(e).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function y1(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}let y2=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:y3}=tL,y4=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,y6=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,y5=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,y8=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function y9(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function y7(e){return`offset${e}`}function be(e){let t=e.name,r=nP.util.sizeFromShape(e.shapeInfo.logicalShape);return r<2?`return ${t};`:`
    for (int i = 0; i < ${r}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function bt(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";else if(6===e)return"ivec6";else throw Error(`GPU for rank ${e} is not yet supported`)}function br(e,t,r){let{newShape:n,keptDims:a}=nP.util.squeezeShape(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):n,l=!e&&s>1&&!nP.util.arraysEqual(t,r)&&n.length<s||i,u=l?o:t;return{useSqueezeShape:l,uniformShape:u,keptDims:a}}function bn(e,t){let r=JSON.parse(JSON.stringify(e));return r.shapeInfo.logicalShape=t,r}function ba(e,t){return t.map(t=>e[t]).join(", ")}function bs(e,t,r){let n,a,s,i=[],o=[],l=null,u=null;for(let n of(u=e.getUniformLocation(r,"NAN",!1),1===(0,nL.env)().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(r,"INFINITY",!1)),t.variableNames)){let a={name:n,uniform:e.getUniformLocation(r,n,!1),offset:e.getUniformLocation(r,`offset${n}`,!1)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(r,`${n}Shape`,!1),a.texShape=e.getUniformLocation(r,`${n}TexShape`,!1)),i.push(a)}if(t.enableShapeUniforms&&(n=e.getUniformLocation(r,"outShape",!1),s=e.getUniformLocation(r,"outShapeStrides",!1),a=e.getUniformLocation(r,"outTexShape",!1)),t.customUniforms)for(let n of t.customUniforms)o.push(e.getUniformLocation(r,n.name,!1));return{variablesLocations:i,customUniformLocations:o,infLoc:l,nanLoc:u,outShapeLocation:n,outShapeStridesLocation:s,outTexShapeLocation:a}}function bi(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,r)=>{let n=e.logicalShape,a=t[r],s=a.shape;if(!nP.util.arraysEqual(n,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${n} and ${s} must match`);if(e.isUniform&&a.isUniform)return;let i=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!nP.util.arraysEqual(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)})}function bo(e){return(0,nL.env)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class bl{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=c.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=yY();this.outputShape=e,this.enableShapeUniforms=bo(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?yQ(["r","c","d"],e):yJ(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}class bu{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=c.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=yY();this.outputShape=e,this.enableShapeUniforms=bo(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?yQ(["r","c","d"],e):yJ(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}class bh{constructor(e){this.variableNames=["A"],this.outTexUsage=f.DOWNLOAD;const t=yY();this.outputShape=e,this.userCode=`
      ${y2}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}class bp{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=f.DOWNLOAD;const t=yY();this.outputShape=e,this.userCode=`
      ${y2}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}let bd={R:0,G:1,B:2,A:3};class bc{constructor(e,t=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=yY();this.outputShape=e,this.enableShapeUniforms=bo(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let e=0;e<r.length;e++){const t=r[e];s+=`
          if(offset == ${e}) {
            result = values[${bd[t]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?y1():y0(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${n.texture2D}(A, uv);
          ${s}
        }
        ${n.output} = vec4(${a}, 0., 0., 0.);
      }
    `}}class bf{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=yY();this.outputShape=e,this.enableShapeUniforms=bo(this.outputShape.length);let n="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let a=0;a<=1;a++){const s=2*t+a;n+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${t};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${s}] = values[0];
            } else if (offset == 1) {
              result[${s}] = values[1];
            } else if (offset == 2) {
              result[${s}] = values[2];
            } else {
              result[${s}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?y1():y0(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${n}

          ${r.output} = ${a};
        }
    `}}function bm(e){let t=yY();return yi(e,`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`)}function bg(e){return yc(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function by(e){return yf(e,new Uint16Array([0,1,2,2,1,3]))}function bb(e,t,r,n,a,s){yy(t,r);let i=yg(e),o=e.TEXTURE_2D;return yr(e,()=>e.bindTexture(o,i)),yr(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),yr(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),yr(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),yr(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),1===(0,nL.env)().getNumber("WEBGL_VERSION")?yr(e,()=>e.texImage2D(o,0,n,t,r,0,a,s,null)):yr(e,()=>e.texStorage2D(o,1,n,t,r)),yr(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[r,t]}}function bx(e){return e.internalFormatFloat}function bv(e,t,r,n){let[a,s]=[r,t];return bb(e,a,s,bx(n),n.textureFormatFloat,e.FLOAT)}function bw(e){return e.internalFormatHalfFloat}function bS(e,t,r,n){let[a,s]=[r,t];return bb(e,a,s,bw(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function bN(e){return e.downloadTextureFormat}function bk(e,t,r,n){let[a,s]=[r,t];return bb(e,a,s,bN(n),e.RGBA,e.UNSIGNED_BYTE)}function bI(e){return e.internalFormatPackedFloat}function bT(e,t,r,n){let[a,s]=ye(t,r);return bb(e,a,s,bI(n),e.RGBA,e.FLOAT)}function bC(e){return e.internalFormatPackedHalfFloat}function bE(e,t,r,n){let[a,s]=ye(t,r);return bb(e,a,s,bC(n),e.RGBA,n.textureTypeHalfFloat)}function b$(e,t,r){return yr(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),yx(e,t,"clipSpacePos",r,3,20,0)&&yx(e,t,"uv",r,2,20,12)}function bA(e,t,r,n,a,s){let i,o,l;yr(e,()=>e.bindTexture(e.TEXTURE_2D,t)),a instanceof Uint8Array?(i=new Uint8Array(r*n*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(r*n*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),2===(0,nL.env)().getNumber("WEBGL_VERSION")?yr(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,r,n,e.RGBA,o,i)):yr(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,r,n,0,e.RGBA,o,i)),yr(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function bR(e,t,r){yr(e,()=>e.bindTexture(e.TEXTURE_2D,t)),r.data instanceof Uint8Array?2===(0,nL.env)().getNumber("WEBGL_VERSION")?yr(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,r.width,r.height,e.RGBA,e.UNSIGNED_BYTE,r.data)):yr(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,r.width,r.height,0,e.RGBA,e.UNSIGNED_BYTE,r.data)):2===(0,nL.env)().getNumber("WEBGL_VERSION")?yr(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,r)):yr(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,r)),yr(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function bD(e,t,r,n){let a=e.createBuffer();yr(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a));let s=16*t*r;return yr(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),yr(e,()=>e.readPixels(0,0,r,t,e.RGBA,e.FLOAT,0)),yr(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),a}function bF(e,t,r){let n=new Float32Array(r);return e.bindBuffer(e.PIXEL_PACK_BUFFER,t),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,n),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),n}function bO(e,t,r,n){let[a,s]=[r,t],i=new Uint8Array(t*r*4);return yr(e,()=>e.readPixels(0,0,a,s,n.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function b_(e,t,r,n,a,s,i,o){let l=new Float32Array(function(e,t){let[r,n]=ye(e,t);return r*n*4}(s,i));return e.bindBuffer(e.PIXEL_PACK_BUFFER,t),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,l),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),l}function bM(e,t,r){let n=new Float32Array(t*r*4);return yr(e,()=>e.readPixels(0,0,r,t,e.RGBA,e.FLOAT,n)),n}e.s(["bindVertexProgramAttributeStreams",()=>b$,"createBufferFromOutputTexture",()=>bD,"createFloat16MatrixTexture",()=>bS,"createFloat16PackedMatrixTexture",()=>bE,"createFloat32MatrixTexture",()=>bv,"createIndexBuffer",()=>by,"createPackedMatrixTexture",()=>bT,"createUnsignedBytesMatrixTexture",()=>bk,"createVertexBuffer",()=>bg,"createVertexShader",()=>bm,"downloadByteEncodedFloatMatrixFromOutputTexture",()=>bO,"downloadFloat32MatrixFromBuffer",()=>bF,"downloadMatrixFromPackedOutputTexture",()=>bM,"downloadPackedMatrixFromBuffer",()=>b_,"getInternalFormatForFloat16MatrixTexture",()=>bw,"getInternalFormatForFloat16PackedMatrixTexture",()=>bC,"getInternalFormatForFloat32MatrixTexture",()=>bx,"getInternalFormatForPackedMatrixTexture",()=>bI,"getInternalFormatForUnsignedBytesMatrixTexture",()=>bN,"uploadDenseMatrixToTexture",()=>bA,"uploadPixelDataToTexture",()=>bR],70798);class bL{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=(0,nL.env)().getNumber("WEBGL_VERSION");if(null!=e){var r;this.gl=e,r=e,g6[t]=r}else this.gl=g9(t);if(e=this.gl,2===(0,nL.env)().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>yr(t,()=>t.createVertexArray()),this.bindVertexArray=e=>yr(t,()=>t.bindVertexArray(e)),this.deleteVertexArray=e=>yr(t,()=>t.deleteVertexArray(e)),this.getVertexArray=()=>yr(t,()=>t.getParameter(t.VERTEX_ARRAY_BINDING))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>yr(e,()=>t.createVertexArrayOES()),this.bindVertexArray=r=>yr(e,()=>t.bindVertexArrayOES(r)),this.deleteVertexArray=r=>yr(e,()=>t.deleteVertexArrayOES(r)),this.getVertexArray=()=>yr(e,()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,nL.env)().getNumber("WEBGL_VERSION")){const e="OES_texture_half_float";if(this.textureFloatExtension=ys(this.gl,"OES_texture_float"),yW(this.gl,e))this.textureHalfFloatExtension=ys(this.gl,e);else if((0,nL.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),yW(this.gl,a))this.colorBufferHalfFloatExtension=ys(this.gl,a);else if((0,nL.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",yW(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(yW(this.gl,a))this.colorBufferHalfFloatExtension=this.gl.getExtension(a);else throw Error("GL context does not support color renderable floats");this.vertexBuffer=bg(this.gl),this.indexBuffer=by(this.gl),this.framebuffer=yb(this.gl),this.textureConfig=yt(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,nL.env)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;yr(e,()=>e.finish()),yr(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),yr(e,()=>e.deleteFramebuffer(this.framebuffer)),yr(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),yr(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),yr(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),bv(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),bS(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),bk(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),bR(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,n){this.throwIfDisposed(),bA(this.gl,e,t,r,n,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),bE(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),bT(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(yC(this.gl,this.framebuffer),this.outputTexture=null),yr(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>bO(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,n,a,s){return b_(this.gl,e,t,r,n,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return bF(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);let n=bD(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),n}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if((0,nL.env)().getBool("WEBGL_FENCE_API_ENABLED")){let n=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{let t=e.clientWaitSync(n,0,0);return t===e.ALREADY_SIGNALED||t===e.CONDITION_SATISFIED},t=n}else(0,nL.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,(0,nL.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>bM(this.gl,t,r))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=bm(t));let r=yh(t);yr(t,()=>t.attachShader(r,this.vertexShader)),yr(t,()=>t.attachShader(r,e)),yp(t,r);let n=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&yd(t,n),n}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;yr(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),b$(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(yr(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&yd(this.gl,this.program),yr(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return(this.throwIfDisposed(),r)?yS(this.gl,e,t):yN(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),yr(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),yk(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();let[n,a]=ye(t,r);this.setOutputMatrixTextureDriver(e,n,a)}setOutputMatrixWriteRegion(e,t,r,n){this.setOutputMatrixWriteRegionDriver(r,e,n,t)}setOutputPackedMatrixWriteRegion(e,t,r,n){throw Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&yd(this.gl,this.program),yE(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;this.debug&&(console.assert(this.getVertexArray()===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()),yr(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),yr(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=ys(this.gl,2===(0,nL.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,nL.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),r=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,r),r}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===(0,nL.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();e.endQuery(t.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await nP.util.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,(0,nL.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,(0,nL.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){let t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{let t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let t=this.gl,r=this.getQueryTimerExtensionWebGL2(),n=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),n&&!this.disjoint}{let t=this.getQueryTimerExtensionWebGL1(),r=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){let r;this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||("setTimeoutCustom"in(0,nL.env)().platform&&(r=(0,nL.env)().platform.setTimeoutCustom.bind((0,nL.env)().platform)),nP.util.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),yT(this.gl,e,this.framebuffer),this.debug&&yE(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(yT(this.gl,this.outputTexture,this.framebuffer),this.debug&&yE(this.gl)):yC(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();let n=this.gl;yT(n,e,this.framebuffer),this.debug&&yE(n),this.outputTexture=e,yr(n,()=>n.viewport(0,0,t,r)),yr(n,()=>n.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,n){this.throwIfDisposed(),yr(this.gl,()=>this.gl.scissor(e,t,r,n))}throwIfDisposed(){if(this.disposed)throw Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw Error("No GPU program is currently set.")}}let{addImpl:bz,bincountImpl:bP,bincountReduceImpl:bB,bitwiseAndImpl:bV,castImpl:bW,ceilImpl:bU,concatImpl:bG,equalImpl:bq,expImpl:bH,expm1Impl:bj,floorImpl:bK,gatherNdImpl:bX,gatherV2Impl:bZ,greaterImpl:bY,greaterEqualImpl:bJ,lessImpl:bQ,lessEqualImpl:b0,linSpaceImpl:b1,logImpl:b2,maxImpl:b3,maximumImpl:b4,minimumImpl:b6,multiplyImpl:b5,negImpl:b8,notEqualImpl:b9,prodImpl:b7,raggedGatherImpl:xe,raggedRangeImpl:xt,raggedTensorToTensorImpl:xr,rangeImpl:xn,rsqrtImpl:xa,scatterImpl:xs,sigmoidImpl:xi,simpleAbsImpl:xo,sliceImpl:xl,sparseFillEmptyRowsImpl:xu,sparseReshapeImpl:xh,sparseSegmentReductionImpl:xp,sqrtImpl:xd,staticRegexReplaceImpl:xc,stridedSliceImpl:xf,stringNGramsImpl:xm,stringSplitImpl:xg,stringToHashBucketFastImpl:xy,subImpl:xb,tileImpl:xx,topKImpl:xv,transposeImpl:xw,uniqueImpl:xS}=cB;function xN(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function xk(e,t){return 1===t?[e]:xN(e,t)}class xI{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=bo(this.outputShape.length),0===this.rank)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const e=xk("rc",this.rank),t=bt(this.rank),r=this.getOutOfBoundsCondition(e),n=this.getSetup(e),a=this.getOutput(e);this.userCode=`
        void main() {
          ${t} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${n}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let r=0;r<=1;r++)for(let n=0;n<=1;n++){let a=`${0===r?"r":"rp1"}, ${0===n?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],n=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${n};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);if(1===this.rank){let e=this.enableShapeUniforms?"outShape":this.outputShape[0];return`getA(rc), (rc + 1 >= ${e} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}class xT{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=bo(this.outputShape.length);let r="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),r+=`
        ${t}
        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${e}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${e>0?"}":""}
      `}this.userCode=`
      ${function(e,t){let r=t?function(e,t,r="index"){let n=function(e,t){let r=e.length,n=e.map(e=>`${t}[${e}]`),a=Array(r-1);a[r-2]=n[r-1];for(let e=r-3;e>=0;--e)a[e]=`(${a[e+1]} * ${n[e+1]})`;return a}(e.map((e,t)=>t),t);return n.map((t,a)=>{let s=`int ${e[a]} = ${r} / ${n[a]}`,i=a===n.length-1?`int ${e[a+1]} = ${r} - ${e[a]} * ${n[a]}`:`index -= ${e[a]} * ${n[a]}`;return`${s}; ${i};`}).join("")}(["r","c","d"],"inputShape"):yJ(["r","c","d"],e);return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${r}
      return ivec3(r, c, d);
    }
  `}(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?y1():y0(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}class xC{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,r){let n,a=x$(t,r),s=xA(e,a,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=xE(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}return a===m.PACKED_2X2_FLOAT32?n=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===m.PACKED_2X2_FLOAT16?n=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===m.UNPACKED_FLOAT32?n=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===m.UNPACKED_FLOAT16?n=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===m.PACKED_4X1_UNSIGNED_BYTE&&(n=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(n),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),n}releaseTexture(e,t,r,n){if(null==this.freeTextures)return;let a=x$(r,n),s=xA(t,a,n);s in this.freeTextures||(this.freeTextures[s]=[]);let i=xE(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,n),o=(0,nL.env)().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],u=l&&l.indexOf(e);if(null==u||u<0)throw Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function xE(e,t,r,n,a){let s,i=function(e,t){switch(e){case m.PACKED_2X2_FLOAT32:return bI(t);case m.PACKED_2X2_FLOAT16:return bC(t);case m.UNPACKED_FLOAT32:return bx(t);case m.UNPACKED_FLOAT16:return bw(t);case m.PACKED_4X1_UNSIGNED_BYTE:return bN(t);default:throw Error(`Unknown physical texture type ${e}`)}}(t,n);if(a){let[t,r]=ye(e[0],e[1]);s=t*r}else{var o;let[t,r]=(o=e[0],[e[1],o]);s=t*r}return s*function(e,t){if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===e.RGBA16F)return 8;else if(t===e.RGBA8)return 4;throw Error(`Unknown internal format ${t}`)}(r,i)}function x$(e,t){if(e===f.UPLOAD)return m.PACKED_2X2_FLOAT32;if(e===f.RENDER||null==e)return(0,nL.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?m.PACKED_2X2_FLOAT32:m.UNPACKED_FLOAT32:t?m.PACKED_2X2_FLOAT16:m.UNPACKED_FLOAT16;if(e===f.DOWNLOAD||e===f.PIXELS)return m.PACKED_4X1_UNSIGNED_BYTE;throw Error(`Unknown logical texture type ${e}`)}function xA(e,t,r){return`${e[0]}_${e[1]}_${t}_${r}`}class xR{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=bo(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}let xD="if (isnan(x)) return x;",xF="return abs(x);",xO=xD+`
  return (x < 0.0) ? 0.0 : x;
`,x_=xD+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,xM="return x;",xL=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,xz=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,xP=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;class xB{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=bo(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class xV{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=bo(this.outputShape.length);const t=e.length,r=xk("rc",t),n=bt(t),a=function(e,t){if(1===e)return"rc";let r="";for(let n=0;n<e;n++)r+=t[n],n<e-1&&(r+=",");return r}(t,r),s=r.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`
      void main() {
        ${n} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}}let xW=pD.whereImpl,xU={},xG=(0,nL.env)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class xq extends yZ.KernelBackend{nextDataId(){return xq.nextDataId++}constructor(e){let t;if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,nL.env)().getBool("HAS_WEBGL"))throw Error("WebGL is not supported on this device");null!=e?(t=e instanceof bL?e:new bL(g9((0,nL.env)().getNumber("WEBGL_VERSION"),e)),this.binaryCache={},this.gpgpuCreatedLocally=!1):(t=new bL(g9((0,nL.env)().getNumber("WEBGL_VERSION"))),this.binaryCache=function(e){return e in xU||(xU[e]={}),xU[e]}((0,nL.env)().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0),this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new xC(this.gpgpu),this.numMBBeforeWarning=null==(0,nL.env)().global.screen?1024:(0,nL.env)().global.screen.height*(0,nL.env)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new yZ.DataStorage(this,(0,nz.engine)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,r,n,a,s){let i=this.makeTensorInfo(t,r),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[n,a]},o.texShape=[n,a];let l=new bc(yO(t),!1,s),u=this.runWebGLProgram(l,[i],r,[[n,a]]);return u.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),u.dataId}write(e,t,r){if(((0,nL.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,nL.env)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===r&&null!=e)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let n={id:this.nextDataId()};return this.texData.set(n,{shape:t,dtype:r,values:e,usage:f.UPLOAD,refCount:1}),n}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,r,n,a){if((0,nL.env)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===n)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:n,values:t,usage:f.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t,r,{values:n,dtype:a,complexTensorInfos:s,slice:i,shape:o,isPacked:l}=this.texData.get(e);if(null!=i){let t;t=l?new xB(o,xM):new xR(o,xM);let r=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:a}],a),n=this.readSync(r.dataId);return this.disposeIntermediateTensorInfo(r),n}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;let u=null!=this.activeTimers;if(u&&(t=nP.util.now()),"complex64"===a){let e=this.readSync(s.real.dataId),t=this.readSync(s.imag.dataId);r=tL.mergeRealAndImagArrays(e,t)}else r=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=nP.util.now()-t),this.convertAndCacheOnCPU(e,r)}async read(e){let t,r;if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}let{values:n,shape:a,slice:s,dtype:i,complexTensorInfos:o,isPacked:l}=this.texData.get(e);if(null!=s){let t;t=l?new xB(a,xM):new xR(a,xM);let r=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:i}],i),n=this.read(r.dataId);return this.disposeIntermediateTensorInfo(r),n}if(null!=n)return this.convertAndCacheOnCPU(e);if((0,nL.env)().getBool("DEBUG")&&!(0,nL.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,nL.env)().getNumber("WEBGL_VERSION"))throw Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null;if("complex64"!==i&&(0,nL.env)().get("WEBGL_BUFFER_SUPPORTED")){t=this.decode(e);let r=this.texData.get(t.dataId);u=this.gpgpu.createBufferFromTexture(r.texture.texture,...g7(a))}if(this.pendingRead.set(e,[]),"complex64"!==i&&await this.gpgpu.createAndWaitForFence(),"complex64"===i){let e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),t=e[0],n=e[1];r=tL.mergeRealAndImagArrays(t,n)}else if(null==u)r=this.getValuesFromTexture(e);else{let e=nP.util.sizeFromShape(a);r=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=t&&this.disposeIntermediateTensorInfo(t),null!=u){let e=this.gpgpu.gl;yr(e,()=>e.deleteBuffer(u))}let h=this.convertAndCacheOnCPU(e,r),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(e=>e(h)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&(0,nz.engine)().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,t={}){let{values:r,shape:n,slice:a,dtype:s,isPacked:i,texture:o}=this.texData.get(e);if("complex64"===s)throw Error("Does not support reading texture for complex64 dtype.");if(null!=a){let r;r=i?new xB(n,xM):new xR(n,xM);let a=this.runWebGLProgram(r,[{dataId:e,shape:n,dtype:s}],s),o=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),o}if(null==o)if(null!=r)throw Error("Data is not on GPU but on CPU.");else throw Error("There is no data on GPU or CPU.");let l=this.decode(e,t.customTexShape);return Object.assign({tensorRef:(0,nz.engine)().makeTensorFromTensorInfo(l)},this.texData.get(l.dataId).texture)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let r=t.map(e=>nP.util.decodeString(e));return(0,pA.buffer)(e.shape,e.dtype,r)}catch(e){throw Error("Failed to decode encoded string bytes into utf-8")}return(0,pA.buffer)(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){let r=e[t];if(!yn(r)){if((0,nL.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${r} cannot be represented on this device.`)}}}getValuesFromTexture(e){let{shape:t,dtype:r,isPacked:n}=this.texData.get(e),a=nP.util.sizeFromShape(t);if((0,nL.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let r=this.decode(e),n=this.texData.get(r.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(n.texture.texture,...g7(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(r),s}let s=(0,nL.env)().getBool("WEBGL_PACK")&&!0===n,i=s?yO(t):t,o=s?new bp(i):new bh(i),l=this.runWebGLProgram(o,[{shape:i,dtype:r,dataId:e}],"float32"),u=this.texData.get(l.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),h}timerAvailable(){return(0,nL.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,r=[],n=!1;null==this.programTimersStack?(this.programTimersStack=r,n=!0):this.activeTimers.push(r),this.activeTimers=r,e();let a=nP.util.flatten(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),s=nP.util.flatten(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,n&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if((0,nL.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let e=await Promise.all(a);i.kernelMs=nP.util.sum(e),i.getExtraProfileInfo=()=>e.map((e,t)=>({name:s[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,nL.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:nP.util.now(),endMs:null}}endTimer(e){return(0,nL.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.endQuery():e.endMs=nP.util.now(),e}async getQueryTime(e){return(0,nL.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:r}=this.texData.get(e);return null!=r&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:r,texShape:n,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(n,r),this.textureManager.releaseTexture(t,n,a,s)));let u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=xG){return(0,nL.env)().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&nP.util.sizeFromShape(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){tL.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return xW(e.shape,t)}packedUnaryOp(e,t,r){let n=new xB(e.shape,t),a=this.compileAndRun(n,[e],r);return(0,nz.engine)().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let t=xo(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if((0,nL.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,xF,e.dtype);let t=new xR(e.shape,xF),r=this.compileAndRun(t,[e]);return(0,nz.engine)().makeTensorFromTensorInfo(r)}makeTensorInfo(e,t,r){let n;if("string"===t&&null!=r&&r.length>0&&nP.util.isString(r[0])){let a=r.map(e=>nP.util.encodeString(e));n=this.write(a,e,t)}else n=this.write(r,e,t);return this.texData.get(n).usage=null,{dataId:n,shape:e,dtype:t}}makeOutput(e,t,r){return(0,nz.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,r),this)}unpackTensor(e){let t=new xV(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new xI(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){let r=[yD(e.shape),...yF(e.shape)],n={dtype:e.dtype,shape:r,dataId:e.dataId},a=new xT([yD(t),...yF(t)],r),s=this.runWebGLProgram(a,[n],e.dtype,[r],!0);return{dataId:s.dataId,shape:t,dtype:s.dtype}}decode(e,t){let r,{isPacked:n,shape:a,dtype:s}=this.texData.get(e);if(null!=t){let e=nP.util.sizeFromShape(a),r=t[0]*t[1]*4;nP.util.assert(e<=r,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let i=yO(a);r=n?new bu(i):new bl(i);let o=[null!=t?t:g7(i)],l=this.runWebGLProgram(r,[{shape:i,dtype:s,dataId:e}],s,o,!0,t);return{dtype:s,shape:a,dataId:l.dataId}}runWebGLProgram(e,t,r,n,a=!1,s){let i,o,l,u=this.makeTensorInfo(e.outputShape,r),h=this.texData.get(u.dataId);if(e.packedOutput&&(h.isPacked=!0),e.outPackingScheme===c.DENSE&&(h.texShape=(null!=s?s:g7(e.outputShape)).map(e=>2*e)),null!=e.outTexUsage&&(h.usage=e.outTexUsage),0===nP.util.sizeFromShape(u.shape))return h.values=nP.util.getTypedArrayFromDType(u.dtype,0),u;let p=[],d=t.map(t=>{if("complex64"===t.dtype)throw Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let r=this.texData.get(t.dataId);if(null==r.texture){if(!e.packedInputs&&nP.util.sizeFromShape(t.shape)<=(0,nL.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:r.values};e.packedInputs&&(r.isPacked=!0,r.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!r.isPacked!=!!e.packedInputs)t=r.isPacked?this.unpackTensor(t):this.packTensor(t),p.push(t),r=this.texData.get(t.dataId);else if(r.isPacked&&!yM(r.shape,t.shape)){let e=t,n=t.shape;t.shape=r.shape,t=this.packedReshape(t,n),p.push(t),r=this.texData.get(t.dataId),e.shape=n}return{shape:t.shape,texData:r,isUniform:!1}});this.uploadToGPU(u.dataId);let f={shape:u.shape,texData:h,isUniform:!1},m=(o="",d.concat(f).forEach(t=>{let r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let n=t.texData.texShape,{useSqueezeShape:a,uniformShape:s,keptDims:i}=br(e.packedInputs,t.shape,n),l="",u="",h="";if(1===s.length&&e.packedInputs){let e=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];l=`${e[0]>1}_${e[1]>1}`}else if(2!==s.length||e.packedInputs){if(s.length>2&&!e.packedInputs){let e=nP.util.computeStrides(s);h=`${e[0]===n[1]}_${e[e.length-1]===n[1]}`}}else u=`${s[0]>1}_${s[1]>1}`;let p=t.shape.length,d=2===s.length&&nP.util.arraysEqual(t.shape,n),c=1===nP.util.sizeFromShape(t.shape),m=tL.getBroadcastDims(t.shape,f.shape),g=!e.packedInputs&&p===f.shape.length&&nP.util.arraysEqual(n,f.texData.texShape),y=e.packedInputs||s.length>2?"":`${n[0]>1}_${n[1]>1}`;o+=`${p}_${g}_${a?i:""}_${s.length}_${c}_${m}_${d}_${l}_${u}_${h}_${y}_${r}`}else{let e=t.isUniform?"uniform":t.texData.texShape;o+=`${t.shape}_${e}_${r}`}}),l=e.userCode,e.constructor.name+("_"+o+"_"+l)+`${(0,nL.env)().getNumber("WEBGL_VERSION")}`),g=this.getAndSaveBinary(m,()=>{var t;let r,n,a,s,i,o;return t=this.gpgpu,n=(r=d.map((t,r)=>{let n={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(n.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[r],shapeInfo:n}})).map(e=>e.shapeInfo),s=function(e,t,r){var n,a,s,i;let o,l,u=[];if(e.forEach(e=>{let t=nP.util.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?u.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(u.push(`uniform sampler2D ${e.name};`),u.push(`uniform int offset${e.name};`)),r.enableShapeUniforms){let{uniformShape:t}=br(r.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:u.push(`uniform int ${e.name}Shape;`);break;case 2:u.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:u.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:u.push(`uniform ivec4 ${e.name}Shape;`)}u.push(`uniform ivec2 ${e.name}TexShape;`)}}),r.enableShapeUniforms){switch(t.logicalShape.length){case 1:u.push("uniform int outShape;");break;case 2:u.push("uniform ivec2 outShape;"),u.push("uniform int outShapeStrides;");break;case 3:u.push("uniform ivec3 outShape;"),u.push("uniform ivec2 outShapeStrides;");break;case 4:u.push("uniform ivec4 outShape;"),u.push("uniform ivec3 outShapeStrides;")}u.push("uniform ivec2 outTexShape;")}r.customUniforms&&r.customUniforms.forEach(e=>{u.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)});let h=u.join("\n"),p=e.map(e=>(function(e,t,r=!1,n){let a="";r?a+=function e(t,r){switch(t.shapeInfo.logicalShape.length){case 0:let n,a,s;return a="get"+(n=t.name).charAt(0).toUpperCase()+n.slice(1),s=yY(),`
    vec4 ${a}() {
      return ${s.texture2D}(${n}, halfCR);
    }
  `;case 1:return function(e,t){let r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,s=yY();if(t)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${r}, uv);
    }
  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${r}, uv);
    }
  `}(t,r);case 2:return function(e,t){let r=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=yY();if(null!=s&&nP.util.arraysEqual(r,s))return t?`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${l.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${n}, uv);
      }
    `;if(t)return`
    vec4 ${a}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${n}, uv);
    }
  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],h=Math.ceil(r[1]/2);return`
    vec4 ${a}(int row, int col) {
      vec2 uv = packedUVfrom2D(${h}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${n}, uv);
    }
  `}(t,r);case 3:return function(t,r){let n=t.shapeInfo.logicalShape,a=t.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),i=t.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===n[0]){let a=bn(t,n.slice(1));return`
        ${e(a,r)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${ba(["b","row","col"],[1,2])});
        }
      `}let l=yY();if(r)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${a}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${l.texture2D}(${a}, uv);
    }
  `;let u=o[0],h=o[1],p=Math.ceil(n[2]/2),d=p*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${h}, ${d}, ${p}, b, row, col);
      return ${l.texture2D}(${a}, uv);
    }
  `}(t,r);default:return function(e,t){let r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1),a=yY();if(t)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${r}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${r}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${r}, uv);
    }
  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],h=l[1],p=Math.ceil(s[i-1]/2),d=p*Math.ceil(s[i-2]/2),c="int b, int row, int col",f=`b * ${d} + (row / 2) * ${p} + (col / 2)`;for(let e=2;e<i-1;e++)c=`int b${e}, `+c,d*=s[i-e-1],f=`b${e} * ${d} + `+f;return`
    vec4 ${n}(${c}) {
      int index = ${f};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${u});
      return ${a.texture2D}(${r}, uv);
    }
  `}(t,r)}}(e,n):a+=function e(t,r=!1){let n=t.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){let r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${r};}`;let[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`
      float ${n}() {
        return sampleTexture(${r}, halfCR);
      }
    `;let i=y7(r);if(t)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], ${i});
      return sampleTexture(${r}, uv);
    }
  `;let[o,l]=e.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${r}, uv);
    }
  `}(t,r);case 1:return function(e,t){let r=e.name,n="get"+r.charAt(0).toUpperCase()+r.slice(1);if(e.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${be(e)}
      }
    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(1===i&&1===s)return`
      float ${n}(int index) {
        return sampleTexture(${r}, halfCR);
      }
    `;let o=y7(r);return 1===i?t?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${r}, uv);
      }
    `:1===s?t?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${r}, uv);
      }
    `:t?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${o});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});
      return sampleTexture(${r}, uv);
    }
  `}(t,r);case 2:return function(t,r){let n=t.shapeInfo.logicalShape,a=t.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),i=t.shapeInfo.texShape;if(null!=i&&nP.util.arraysEqual(n,i)){if(r)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `;let e=i[0],t=i[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${t}.0, ${e}.0);
      return sampleTexture(${a}, uv);
    }
  `}let{newShape:o,keptDims:l}=nP.util.squeezeShape(n);if(o.length<n.length){let n=bn(t,o);return`
      ${e(n,r)}
      float ${s}(int row, int col) {
        return ${s}(${ba(["row","col"],l)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${be(t)}
      }
    `;let u=i[0],h=i[1],p=y7(a);return 1===h?r?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${a}TexShape[0]));
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${a}, uv);
    }
  `:1===u?r?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${a}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${a}TexShape[1]), 0.5);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${a}, uv);
    }
  `:r?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
        return sampleTexture(${a}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${p};
    vec2 uv = uvFromFlat(${u}, ${h}, index);
    return sampleTexture(${a}, uv);
  }
`}(t,r);case 3:return function(t,r){let n=t.shapeInfo.logicalShape,a=t.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),i=n[1]*n[2],o=n[2],{newShape:l,keptDims:u}=nP.util.squeezeShape(n);if(l.length<n.length){let n=bn(t,l);return`
        ${e(n,r)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${ba(["row","col","depth"],u)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${be(t)}
      }
    `;let h=t.shapeInfo.texShape,p=h[0],d=h[1],c=t.shapeInfo.flatOffset;if(d===i&&null==c)return r?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${a}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${p}.0);
          return sampleTexture(${a}, uv);
        }
      `;if(d===o&&null==c)return r?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${a}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${p}.0);
      return sampleTexture(${a}, uv);
    }
  `;let f=y7(a);return r?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${a}Shape[1] * ${a}Shape[2];
      int stride1 = ${a}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);
      return sampleTexture(${a}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${f};
        vec2 uv = uvFromFlat(${p}, ${d}, index);
        return sampleTexture(${a}, uv);
      }
  `}(t,r);case 4:return function(t,r){let n=t.shapeInfo.logicalShape,a=t.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),i=n[3],o=n[2]*i,l=n[1]*o,{newShape:u,keptDims:h}=nP.util.squeezeShape(n);if(u.length<n.length){let n=bn(t,u);return`
      ${e(n,r)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${ba(["row","col","depth","depth2"],h)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${l}, ${o}, ${i}, 1)));
        ${be(t)}
      }
    `;let p=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,c=d[0],f=d[1],m=`int stride2 = ${a}Shape[3];`,g=`int stride1 = ${a}Shape[2] * stride2;`,y=`int stride0 = ${a}Shape[1] * stride1;`;if(f===l&&null==p)return r?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${m}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${c}.0);
        return sampleTexture(${a}, uv);
      }
    `;if(f===i&&null==p)return r?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${a}Shape[1] * ${a}Shape[2], ${a}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${a}TexShape[1], ${a}TexShape[0]);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${c}.0);
        return sampleTexture(${a}, uv);
      }
    `;let b=y7(a);return r?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index + ${b});
      return sampleTexture(${a}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${c}, ${f}, index + ${b});
      return sampleTexture(${a}, uv);
    }
  `}(t,r);case 5:return function(t){let r=t.shapeInfo.logicalShape,n=t.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r[4],i=r[3]*s,o=r[2]*i,l=r[1]*o,{newShape:u,keptDims:h}=nP.util.squeezeShape(r);if(u.length<r.length){let r=bn(t,u);return`
      ${e(r)}
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        return ${a}(${ba(["row","col","depth","depth2","depth3"],h)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${o}, ${i}, ${s})) +
          depth3;
        ${be(t)}
      }
    `;let p=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,c=d[0],f=d[1];if(f===l&&null==p)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===s&&null==p)return`
      float ${a}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${r[1]*r[2]*r[3]},
               ${r[2]*r[3]}, ${r[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=y7(n);return`
    float ${a}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} + depth * ${i} +
          depth2 * ${s} + depth3 + ${m};
      vec2 uv = uvFromFlat(${c}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}(t);case 6:return function(t){let r=t.shapeInfo.logicalShape,n=t.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:i}=nP.util.squeezeShape(r);if(s.length<r.length){let r=bn(t,s);return`
      ${e(r)}
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${a}(${ba(["row","col","depth","depth2","depth3","depth4"],i)});
      }
    `}let o=r[5],l=r[4]*o,u=r[3]*l,h=r[2]*u,p=r[1]*h;if(t.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${p}, ${h}, ${u}, ${l})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${be(t)}
      }
    `;let d=t.shapeInfo.flatOffset,c=t.shapeInfo.texShape,f=c[0],m=c[1];if(m===p&&null==d)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${h}, ${u}, ${l}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(m===o&&null==d)return`
      float ${a}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${r[1]*r[2]*r[3]*r[4]},
               ${r[2]*r[3]*r[4]},
               ${r[3]*r[4]},
               ${r[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;let g=y7(n);return`
    float ${a}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${p} + col * ${h} + depth * ${u} +
          depth2 * ${l} + depth3 * ${o} + depth4 + ${g};
      vec2 uv = uvFromFlat(${f}, ${m}, index);
      return sampleTexture(${n}, uv);
    }
  `}(t);default:throw Error(`${n.length}-D input sampling is not yet supported`)}}(e,n);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(r?a+=function(e,t){let r,n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=y3(e.shapeInfo.logicalShape,t.logicalShape),l=bt(i),u=i-s,h=["x","y","z","w","u","v"];r=0===s?"":i<2&&o.length>=1?"coords = 0;":o.map(e=>`coords.${h[e+u]} = 0;`).join("\n");let p="";p=i<2&&s>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+u]}`).join(", ");let d="return outputValue;",c=1===nP.util.sizeFromShape(e.shapeInfo.logicalShape),f=1===nP.util.sizeFromShape(t.logicalShape);if(1!==s||c||f){if(c&&!f)d=1===i?`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:`
        return vec4(outputValue.x);
      `;else if(o.length){let e=s-2,t=s-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?d="return vec4(outputValue.x);":o.indexOf(e)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}}else d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;return`
    vec4 ${"get"+a+"AtOutCoords"}() {
      ${l} coords = getOutputCoords();
      ${r}
      vec4 outputValue = get${a}(${p});
      ${d}
    }
  `}(e,t):a+=function(e,t){let r,n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),s="get"+a+"AtOutCoords",i=t.texShape,o=e.shapeInfo.texShape,l=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&l===u&&null==e.shapeInfo.flatOffset&&nP.util.arraysEqual(o,i))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let h=bt(u),p=y3(e.shapeInfo.logicalShape,t.logicalShape),d=u-l,c=["x","y","z","w","u","v"];r=0===l?"":u<2&&p.length>=1?"coords = 0;":p.map(e=>`coords.${c[e+d]} = 0;`).join("\n");let f="";return f=u<2&&l>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${c[t+d]}`).join(", "),`
    float ${s}() {
      ${h} coords = getOutputCoords();
      ${r}
      return get${a}(${f});
    }
  `}(e,t)),a})(e,t,r.packedInputs,r.enableShapeUniforms)).join("\n"),d=t.texShape,c=yY(),f=(n=c,`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `),m=(a=c,`${a.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${a.varyingFs} vec2 resultUV;
    ${a.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${a.defineSpecialNaN}
    ${a.defineSpecialInf}
    ${a.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${y4}
    ${y6}
    ${y5}
  `);return t.isPacked?(o=function(e,t,r){switch(e.length){case 0:return y9();case 1:var n,a;let s;return n=t,a=r,1===(s=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)])[0]?a?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:1===s[1]?a?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:a?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `;case 2:var i=e,o=t,l=r;let u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(nP.util.arraysEqual(i,o))return l?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${u[0]}, ${u[1]}));
      }
    `;let h=Math.ceil(i[1]/2);return l?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${u[0]}, ${u[1]}));

      int index = resTexRC.x * ${u[1]} + resTexRC.y;
      int r = 2 * (index / ${h});
      int c = imod(index, ${h}) * 2;

      return ivec2(r, c);
    }
  `;case 3:var p=e,d=t,c=r;if(c)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let f=[Math.ceil(d[0]/2),Math.ceil(d[1]/2)],m=Math.ceil(p[2]/2),g=m*Math.ceil(p[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${f[0]}, ${f[1]}));
      int index = resTexRC.x * ${f[1]} + resTexRC.y;

      int b = index / ${g};
      index -= b * ${g};

      int r = 2 * (index / ${m});
      int c = imod(index, ${m}) * 2;

      return ivec3(b, r, c);
    }
  `;default:return function(e,t,r){if(r)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let t=2;t<e.length-1;t++)i*=e[e.length-t-1],o=`
      int b${t} = index / ${i};
      index -= b${t} * ${i};
    `+o,l=`b${t}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec${e.length}(${l});
    }
  `}(e,t,r)}}(t.logicalShape,d,r.enableShapeUniforms),s=c,l=`
    void setOutput(vec4 val) {
      ${s.output} = val;
    }
  `):(o=function(e,t,r){switch(e.length){case 0:return y9();case 1:return n=t,a=r,1===n[0]?a?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${n[1]}.0);
      }
    `:1===n[1]?a?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${n[0]}.0);
      }
    `:a?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return resTexRC.x * ${n[1]} + resTexRC.y;
    }
  `;case 2:return s=e,i=t,o=r,nP.util.arraysEqual(s,i)?o?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${i[0]}, ${i[1]}));
      }
    `:1===s[1]?o?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${i[0]}, ${i[1]}));
        int index = resTexRC.x * ${i[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:1===s[0]?o?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${i[0]}, ${i[1]}));
        int index = resTexRC.x * ${i[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:o?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));
      int index = resTexRC.x * ${i[1]} + resTexRC.y;
      int r = index / ${s[1]};
      int c = index - r * ${s[1]};
      return ivec2(r, c);
    }
  `;case 3:var n,a,s,i,o,l,u,h,p,d=e,c=t,f=r;if(f){let e=yQ(["r","c","d"],d);return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${e}
    return ivec3(r, c, d);
  }
`}let m=yJ(["r","c","d"],d);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${c[0]}, ${c[1]}));
      int index = resTexRC.x * ${c[1]} + resTexRC.y;
      ${m}
      return ivec3(r, c, d);
    }
  `;case 4:var g=e,y=t,b=r;if(b){let e=yQ(["r","c","d","d2"],g);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${e}
      return ivec4(r, c, d, d2);
    }
  `}let x=yJ(["r","c","d","d2"],g);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${y[0]}, ${y[1]}));
      int index = resTexRC.x * ${y[1]} + resTexRC.y;
      ${x}
      return ivec4(r, c, d, d2);
    }
  `;case 5:let v;return l=e,u=t,v=yJ(["r","c","d","d2","d3"],l),`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${u[0]},
                             ${u[1]}));

      int index = resTexRC.x * ${u[1]} + resTexRC.y;

      ${v}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;case 6:let w;return h=e,p=t,w=yJ(["r","c","d","d2","d3","d4"],h),`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${p[0]}, ${p[1]}));
      int index = resTexRC.x * ${p[1]} + resTexRC.y;

      ${w}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;default:throw Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,d,r.enableShapeUniforms),i=c,l=`
    void setOutput(float val) {
      ${i.output} = vec4(val, 0, 0, 0);
    }
  `),r.packedInputs&&(m+=y8),[m,f,l,h,o,p,r.userCode].join("\n")}(r,a={logicalShape:f.shape,texShape:f.texData.texShape,isUniform:!1,isPacked:f.texData.isPacked,flatOffset:null},e),i=yo(t.gl,s),o=t.createProgram(i),(0,nL.env)().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:i,source:s,webGLProgram:o,inShapeInfos:n,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(o),Object.assign({program:e,fragmentShader:i,source:s,webGLProgram:o,inShapeInfos:n,outShapeInfo:a},bs(t,e,o)))}),y=null!=this.activeTimers;y&&(i=this.startTimer()),(0,nL.env)().get("ENGINE_COMPILE_ONLY")||function(e,t,r,n,a){t.program.enableShapeUniforms||(bi(t.inShapeInfos,r),bi([t.outShapeInfo],[n]));let s=n.texData.texture,i=n.texData.texShape;n.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===(0,nL.env)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let n=0;n<r.length;++n){let a=r[n],{uniform:s,offset:i,shape:o,texShape:l}=t.variablesLocations[n];if(o){let{uniformShape:r}=br(t.program.packedInputs,a.shape,a.texData.texShape);switch(r.length){case 1:e.gl.uniform1iv(o,new Int32Array(r));break;case 2:e.gl.uniform2iv(o,new Int32Array(r));break;case 3:e.gl.uniform3iv(o,new Int32Array(r));break;case 4:e.gl.uniform4iv(o,new Int32Array(r))}}if(l&&e.gl.uniform2i(l,a.texData.texShape[0],a.texData.texShape[1]),null!=s){if(a.isUniform){if(2>nP.util.sizeFromShape(a.shape))e.gl.uniform1f(s,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}continue}null!=a.texData.slice&&null!=i&&e.gl.uniform1i(i,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,s,n)}}let o=t.outShapeLocation;if(o)switch(n.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(n.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(n.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(n.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(n.shape))}if(t.outShapeStridesLocation){let r=nP.util.computeStrides(n.shape);switch(n.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(r));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(r));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(r))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),t.program.customUniforms&&a)for(let r=0;r<t.program.customUniforms.length;++r){let n=t.program.customUniforms[r],s=t.customUniformLocations[r],i=a[r];if("float"===n.type)e.gl.uniform1fv(s,i);else if("vec2"===n.type)e.gl.uniform2fv(s,i);else if("vec3"===n.type)e.gl.uniform3fv(s,i);else if("vec4"===n.type)e.gl.uniform4fv(s,i);else if("int"===n.type)e.gl.uniform1iv(s,i);else if("ivec2"===n.type)e.gl.uniform2iv(s,i);else if("ivec3"===n.type)e.gl.uniform3iv(s,i);else if("ivec4"===n.type)e.gl.uniform4iv(s,i);else throw Error(`uniform type ${n.type} is not supported yet.`)}e.executeProgram()}(this.gpgpu,g,d,f,n),p.forEach(e=>this.disposeIntermediateTensorInfo(e)),y&&(i=this.endTimer(i),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(i)}));let b=(0,nL.env)().getNumber("WEBGL_FLUSH_THRESHOLD");if(b>0){let e=nP.util.now();e-this.lastGlFlushTime>b&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!(0,nL.env)().getBool("WEBGL_LAZILY_UNPACK")&&h.isPacked&&!1===a){let e=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),e}return u}compileAndRun(e,t,r,n,a=!1){return r=r||t[0].dtype,this.runWebGLProgram(e,t,r,n,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,nL.env)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,nz.tidy)(()=>{if(!(0,nL.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=(0,nL.env)().getBool("DEBUG");(0,nL.env)().set("DEBUG",!1);let t=this.abs((0,O.scalar)(1e-8)).dataSync()[0];if((0,nL.env)().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){let t,r=this.texData.get(e),{shape:n,dtype:a,values:s,texture:i,usage:o,isPacked:l}=r;if(null!=i)return;let u=null!=this.activeTimers;u&&(t=nP.util.now());let h=r.texShape;if(null==h&&(r.texShape=h=y_(n,l)),null!=s){let e,i=yO(n),o=h[1],p=h[0],d=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!d)&&([o,p]=ye(h[0],h[1])),e=l?new bf(i,d):new bc(i,d);let c=d?[p,o]:h,m=this.makeTensorInfo(c,a),g=this.texData.get(m.dataId);d?g.usage=f.PIXELS:g.usage=f.UPLOAD,g.texShape=c,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(m.dataId),o,p,s);let y=[[p,o]],b=this.runWebGLProgram(e,[m],a,y,!0),x=this.texData.get(b.dataId);r.texShape=x.texShape,r.isPacked=x.isPacked,r.usage=x.usage,(0,nL.env)().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(r.texture=x.texture,r.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(m),u&&(this.uploadWaitMs+=nP.util.now()-t)}else r.texture=this.acquireTexture(h,o,a,l)}convertAndCacheOnCPU(e,t){let r=this.texData.get(e),{dtype:n}=r;return null!=t&&(r.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let r="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<r.length;++t)r[t]=Math.round(e[t]);return r}throw Error(`Unknown dtype ${t}`)}(t,n)),r.values}acquireTexture(e,t,r,n){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,n)}computeBytes(e,t){return e[0]*e[1]*nP.util.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(let[,t]of Object.entries(this.binaryCache)){let r=new Promise(e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}});e.push(r)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await (0,s7.nextFrame)(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw yu(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),Error("Failed to compile fragment shader.");throw Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:t,customUniformLocations:r,infLoc:n,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=bs(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=r,e.infLoc=n,e.nanLoc=a,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,r){e.channels=e.channels||"RGBA";let{texture:n,height:a,width:s,channels:i}=e,o=(0,nz.engine)().backend;if(!o.gpgpu.gl.isTexture(n))throw Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=o.writeTexture(n,t,r,a,s,i);return(0,nz.engine)().makeTensorFromDataId(l,t,r,o)}}xq.nextDataId=0;var xH=e.i(70798),xj=e.i(19392);function xK(){(0,nL.env)().set("WEBGL_FORCE_F16_TEXTURES",!0)}e.s(["forceHalfFloat",()=>xK],59951),g4.isBrowser()&&(0,nz.registerBackend)("webgl",()=>new xq,2),e.s(["webgl",0,{forceHalfFloat:xK}],59007);var cQ=B,tL=tL,tL=tL;let xX=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class xZ{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=tL.assertAndGetBroadcastShape(t,r),this.enableShapeUniforms=bo(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}var tL=tL;let xY=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class xJ{constructor(e,t,r,n=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=tL.assertAndGetBroadcastShape(t,r);const a=this.outputShape.length;this.enableShapeUniforms=bo(a);let s="";if(n)if(0===a||1===nP.util.sizeFromShape(this.outputShape))s=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else{const e=bt(a);if(s=`
          ${e} coords = getOutputCoords();
        `,1===a)this.enableShapeUniforms?s+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:s+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const e=xk("coords",a);this.enableShapeUniforms?s+=`
            bool nextRowOutOfBounds =
              (${e[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${e[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:s+=`
            bool nextRowOutOfBounds =
              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `}}function xQ(e){let{inputs:t,backend:r}=e,{x:n}=t;return r.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}let x0={kernelName:C.Identity,backendName:"webgl",kernelFunc:xQ};function x1(e){let{inputs:t,backend:r}=e,{real:n,imag:a}=t,s=r.makeTensorInfo(n.shape,"complex64");return r.texData.get(s.dataId).complexTensorInfos={real:xQ({inputs:{x:n},backend:r}),imag:xQ({inputs:{x:a},backend:r})},s}let x2={kernelName:C.Complex,backendName:"webgl",kernelFunc:x1},x3="return (a < 0.) ? b * a : a;",x4=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,x6={kernelName:C.LeakyRelu,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{alpha:s}=n,i=r.makeTensorInfo([],"float32",nP.util.createScalarValue(s,"float32")),o=(0,nL.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xJ(x4,a.shape,i.shape):new xZ(x3,a.shape,i.shape),l=r.runWebGLProgram(o,[a,i],"float32");return r.disposeIntermediateTensorInfo(i),l}},x5="return (a < 0.) ? b * a : a;",x8=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,x9={kernelName:C.Prelu,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{x:n,alpha:a}=t,s=(0,nL.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xJ(x8,n.shape,a.shape):new xZ(x5,n.shape,a.shape);return r.runWebGLProgram(s,[n,a],"float32")}},x7="if (isnan(x)) return x;";function ve({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:r,dtype:n}){return({inputs:a,backend:s})=>{let i,{x:o}=a,l=n||o.dtype;if(s.shouldExecuteOnCPU([o])&&null!=r){let e=r(s.texData.get(o.dataId).values,l);return s.makeTensorInfo(o.shape,l,e)}return i=(0,nL.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new xB(o.shape,t):new xR(o.shape,e),s.runWebGLProgram(i,[o],l)}}function vt({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:r=!1,supportsComplex:n=!1,cpuKernelImpl:a,dtype:s}){return({inputs:i,backend:o})=>{let l,{a:u,b:h}=i;if(n&&"complex64"===u.dtype){let t=o.texData.get(u.dataId),r=o.texData.get(h.dataId),[n,a]=[[t.complexTensorInfos.real,r.complexTensorInfos.real],[t.complexTensorInfos.imag,r.complexTensorInfos.imag]].map(t=>{let[r,n]=t,a={dataId:r.dataId,dtype:r.dtype,shape:u.shape},s={dataId:n.dataId,dtype:n.dtype,shape:h.shape},i=new xZ(e,u.shape,h.shape);return o.runWebGLProgram(i,[a,s],(0,dQ.upcastType)(r.dtype,n.dtype))}),s=x1({inputs:{real:n,imag:a},backend:o});return o.disposeIntermediateTensorInfo(n),o.disposeIntermediateTensorInfo(a),s}let p=s||(0,dQ.upcastType)(u.dtype,h.dtype);if(("string"===u.dtype||"string"===h.dtype||o.shouldExecuteOnCPU([u,h]))&&null!=a){let e=o.texData.get(u.dataId).values,t=o.texData.get(h.dataId).values,r="string"===u.dtype?tL.fromUint8ToStringArray(e):e,n="string"===u.dtype?tL.fromUint8ToStringArray(t):t,[s,i]=a(u.shape,h.shape,r,n,p),l=o.makeTensorInfo(i,p);return o.texData.get(l.dataId).values=s,l}return l=(0,nL.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new xJ(t,u.shape,h.shape,r):new xZ(e,u.shape,h.shape),o.runWebGLProgram(l,[u,h],p)}}function vr(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?xz:xO;if("elu"===e)return t?xL:"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?xP:x_;if("prelu"===e)return t?x8:x5;else if("leakyrelu"===e)return t?x4:x3;else if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class vn{constructor(e,t,r,n=!1,a=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=bo(this.outputShape.length);const u=Math.ceil((n?e[1]:e[2])/2),h=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let d="",c="";i&&(d=o?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:`vec4 activation(vec4 x) {
          ${i}
        }`,c="result = activation(result);"),s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let f="rc.x",m="rc.x";e[0]<t[0]?f=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(m=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${d}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${u}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${f};
        int batchB = ${m};
        for (int i = 0; i < ${u}; i++) {
          vec4 a = getMatrixA(batchA, ${n?"i * 2, rc.y":"rc.y, i * 2"});
          vec4 b = getMatrixB(batchB, ${a?"rc.z, i * 2":"i * 2, rc.z"});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${p[0]});
          result += (${h[1]} * ${p[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${s?"result += getBiasAtOutCoords();":""}

        ${c}

        setOutput(result);
      }
    `}}var tL=tL,tL=tL;class va{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=tL.assertAndGetBroadcastShape(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}let vs="return a * b;";function vi(e){let t,{inputs:r,backend:n}=e,{a,b:s}=r,i=tL.upcastType(a.dtype,s.dtype);if("complex64"===a.dtype){let e=n.texData.get(a.dataId),t=n.texData.get(s.dataId),r=new va("return areal * breal - aimag * bimag;",a.shape,s.shape),i=new va("return areal * bimag + aimag * breal;",a.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=n.runWebGLProgram(r,o,"float32"),u=n.runWebGLProgram(i,o,"float32"),h=x1({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),h}if(n.shouldExecuteOnCPU([a,s])){let e=n.texData.get(a.dataId),t=n.texData.get(s.dataId),[r,o]=b5(a.shape,s.shape,e.values,t.values,i),l=n.makeTensorInfo(o,i);return n.texData.get(l.dataId).values=r,l}return t=(0,nL.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xJ(vs,a.shape,s.shape):new xZ(vs,a.shape,s.shape),n.runWebGLProgram(t,[a,s],i)}let vo={kernelName:C.Multiply,backendName:"webgl",kernelFunc:vi};function vl(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{shape:s}=n,i=nP.util.sizeFromShape(a.shape),o=nP.util.inferFromImplicitShape(s,i),l=nP.util.sizeFromShape(o);nP.util.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);let u=r.texData.get(a.dataId);if(u.isPacked&&!yM(a.shape,o)&&!(null!==u.texture&&yM(u.shape,o))){let e,t,n,s,i;return e=[yD(a.shape),...yF(a.shape)],t={dtype:a.dtype,shape:e,dataId:a.dataId},n=new xT([yD(o),...yF(o)],e),s=[e],{dataId:(i=r.runWebGLProgram(n,[t],a.dtype,s,!0)).dataId,shape:o,dtype:i.dtype}}return r.incRef(a.dataId),{dataId:a.dataId,shape:o,dtype:a.dtype}}let vu={kernelName:C.Reshape,backendName:"webgl",kernelFunc:vl};var tL=tL,tL=tL;class vh{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:n,inSize:a,outSize:s}=e;this.outputShape=[n,s];const i=4*Math.floor(r/4),o=r%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${nP.util.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";a%r>0&&(u=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${1===o}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${2===o}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${3===o}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}}class vp{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:n,inSize:a,outSize:s}=e;this.outputShape=[n,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(r/4),h=r%4;let p=`
      if (${"sum"===t}) {
        sumValue += dot(values, ones);
      } else if (${"prod"===t}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${"min"===t} || ${"max"===t}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";"all"===t?(i="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):"any"===t&&(i="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let c="";a%r>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${u};
        if (${1===h}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${2===h}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${3===h}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${l});
      }
    `}}function vd(e,t,r,n){let a=function(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let r=t.length?t[t.length-1].outSize:e[1],n=tL.computeOptimalWindowSize(r);t.push({inSize:r,windowSize:n,outSize:Math.ceil(r/n)})}return t}(e.shape),s=e;for(let i=0;i<a.length;i++){let o,l,{inSize:u,windowSize:h,outSize:p}=a[i];o="mean"===r?0===i?new vh({windowSize:h,inSize:u,batchSize:e.shape[0],outSize:p},u):new vh({windowSize:h,inSize:u,batchSize:e.shape[0],outSize:p}):new vp({windowSize:h,inSize:u,batchSize:e.shape[0],outSize:p},r),l=s,s=n.runWebGLProgram(o,[s],t),l.dataId!==e.dataId&&n.disposeIntermediateTensorInfo(l)}return s}class vc{constructor(e,t){this.variableNames=["A"];const r=Array(e.length);for(let n=0;n<r.length;n++)r[n]=e[t[n]];this.outputShape=r,this.rank=r.length;const n=bt(this.rank),a=function(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let r=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=Array(t);for(let t=0;t<e.length;t++)n[e[t]]=r[t];return n.join()}(t);this.userCode=`
    void main() {
      ${n} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}class vf{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=Array(e.length);for(let n=0;n<r.length;n++)r[n]=e[t[n]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const n=bt(this.rank),a=xN("rc",this.rank),s=Array(this.rank);for(let e=0;e<t.length;e++)s[t[e]]=a[e];const i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${r[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`
    void main() {
      ${n} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${o}) {
        result[1] = ${l};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${l};
        if(${o}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}}function vm(e,t,r){let n=(0,nL.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vf(e.shape,t):new vc(e.shape,t);return r.runWebGLProgram(n,[e],e.dtype)}function vg(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s,keepDims:i}=n;return function(e,t,r,n){let a=e.shape.length,s=nP.util.parseAxisParam(t,e.shape),i=s,o=tL.getAxesPermutation(i,a),l=null!=o,u=e;l&&(u=vm(e,o,n),i=tL.getInnerMostAxes(i.length,a)),tL.assertAxesAreInnerMostDims("sum",i,a);let[h,p]=tL.computeOutAndReduceShapes(u.shape,i),d=h;r&&(d=tL.expandShapeToKeepDim(h,s));let c=nP.util.sizeFromShape(p),f=vl({inputs:{x:u},attrs:{shape:[nP.util.sizeFromShape(e.shape)/c,c]},backend:n}),m=vd(f,(0,dQ.sumOutType)(e.dtype),"sum",n),g=vl({inputs:{x:m},attrs:{shape:d},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),l&&n.disposeIntermediateTensorInfo(u),g}(a,s,i,r)}let vy={kernelName:C.Sum,backendName:"webgl",kernelFunc:vg};function vb(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s}=r,{perm:i}=a,o=Array(s.shape.length);for(let e=0;e<o.length;e++)o[e]=s.shape[i[e]];if(n.shouldExecuteOnCPU([s])){let e=xw(n.texData.get(s.dataId).values,s.shape,s.dtype,i,o);t=n.makeTensorInfo(o,s.dtype),n.texData.get(t.dataId).values=e}else t=vm(s,i,n);return t}let vx={kernelName:C.Transpose,backendName:"webgl",kernelFunc:vb};function vv({a:e,b:t,transposeA:r,transposeB:n,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let u,h=e.shape.length,p=t.shape.length,d=r?e.shape[h-2]:e.shape[h-1],c=n?t.shape[p-1]:t.shape[p-2],f=r?e.shape[h-1]:e.shape[h-2],m=n?t.shape[p-2]:t.shape[p-1],g=e.shape.slice(0,-2),y=t.shape.slice(0,-2),b=nP.util.sizeFromShape(g),x=nP.util.sizeFromShape(y),v=cQ.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,m]);nP.util.assert(d===c,()=>`Error in matMul: inner shapes (${d}) and (${c}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${r} and transposeB=${n} must match.`);let w=r?[b,d,f]:[b,f,d],S=n?[x,m,c]:[x,c,m],N=vl({inputs:{x:e},backend:a,attrs:{shape:w}}),k=vl({inputs:{x:t},backend:a,attrs:{shape:S}}),I=[N,k],T=Math.max(b,x),C=r?N.shape[1]:N.shape[2],E=null!=s,$=null!=i,A="leakyrelu"===l,R=null!=l?vr(l,!0):null,D=E||$||A||null!=R;if((1===f||1===m)&&C>1e3&&!1===D){let e=N,t=k;r&&(e=vb({inputs:{x:N},backend:a,attrs:{perm:[0,2,1]}}),I.push(e)),n&&(t=vb({inputs:{x:k},backend:a,attrs:{perm:[0,2,1]}}),I.push(t));let s=1!==m,i=1===m,o=e;s&&(o=vl({inputs:{x:e},backend:a,attrs:{shape:[T,C,1]}}),I.push(o));let l=t;i&&(l=vl({inputs:{x:t},backend:a,attrs:{shape:[T,1,C]}}),I.push(l));let h=vi({inputs:{a:o,b:l},backend:a});u=vg({inputs:{x:h},backend:a,attrs:{axis:1===m?2:1,keepDims:!0}}),I.push(h)}else{let l=(0,dQ.upcastType)(e.dtype,t.dtype),h=new vn(w,S,[T,f,m],r,n,E,R,$,A),p=[N,k];if(null!=s&&p.push(s),$&&p.push(i),A){let e=a.makeTensorInfo([],"float32",nP.util.createScalarValue(o,"float32"));p.push(e),I.push(e)}u=a.runWebGLProgram(h,p,l)}let F=vl({inputs:{x:u},backend:a,attrs:{shape:v}});for(let e of(I.push(u),I))a.disposeIntermediateTensorInfo(e);return F}let vw={kernelName:C._FusedMatMul,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:h,leakyreluAlpha:p}=n;return vv({a,b:s,transposeA:l,transposeB:u,backend:r,bias:i,preluActivationWeights:o,leakyreluAlpha:p,activation:h})}},vS="return abs(x);",vN={kernelName:C.Abs,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n}=e,{x:a}=r;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){let e=xo(n.texData.get(a.dataId).values);return n.makeTensorInfo(a.shape,a.dtype,e)}return t=(0,nL.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new xB(a.shape,vS):new xR(a.shape,vS),n.runWebGLProgram(t,[a],a.dtype)}},vk=ve({opSnippet:xD+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`}),vI={kernelName:C.Acos,backendName:"webgl",kernelFunc:vk},vT=ve({opSnippet:xD+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`}),vC={kernelName:C.Acosh,backendName:"webgl",kernelFunc:vT},vE="return a + b;",v$=vt({opSnippet:vE,packedOpSnippet:vE,supportsComplex:!0,cpuKernelImpl:bz}),vA={kernelName:C.Add,backendName:"webgl",kernelFunc:v$};class vR{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const r=[];this.variableNames.forEach(e=>{r.push(`float v${e} = get${e}AtOutCoords();`)});const n=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`
      void main() {
        ${r.join("\n        ")}

        float result = ${n};
        setOutput(result);
      }
    `}}class vD{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const r=[];this.variableNames.forEach(e=>{r.push(`vec4 v${e} = get${e}AtOutCoords();`)});const n=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`
      void main() {
        ${r.join("\n        ")}

        vec4 result = ${n};
        setOutput(result);
      }
    `}}let vF={kernelName:C.AddN,backendName:"webgl",kernelFunc:function e(t){let{inputs:r,backend:n}=t;if(1===r.length)return xQ({inputs:{x:r[0]},backend:n});if(r.length>(0,nL.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let t=Math.floor(r.length/2),a=e({inputs:r.slice(0,t),backend:n}),s=e({inputs:r.slice(t),backend:n});return e({inputs:[a,s],backend:n})}let a=r.map(e=>e.dtype).reduce((e,t)=>(0,dQ.upcastType)(e,t)),s=r.map(e=>e.shape),i=(0,nL.env)().getBool("WEBGL_PACK")?new vD(r[0].shape,s):new vR(r[0].shape,s);return n.runWebGLProgram(i,r,a)}};var tL=tL;let vO={kernelName:C.All,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s}=r,{axis:i,keepDims:o}=a,l=s.shape.length,u=nP.util.parseAxisParam(i,s.shape),h=u,p=tL.getAxesPermutation(h,l),d=s;null!=p&&(d=vb({inputs:{x:s},backend:n,attrs:{perm:p}}),h=tL.getInnerMostAxes(h.length,l)),tL.assertAxesAreInnerMostDims("all",h,l);let[c,f]=tL.computeOutAndReduceShapes(d.shape,h),m=vl({inputs:{x:d},backend:n,attrs:{shape:[-1,nP.util.sizeFromShape(f)]}}),g=vd(m,m.dtype,"all",n);return t=o?vl({inputs:{x:g},backend:n,attrs:{shape:tL.expandShapeToKeepDim(c,u)}}):vl({inputs:{x:g},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=p&&n.disposeIntermediateTensorInfo(d),t}};var tL=tL;let v_={kernelName:C.Any,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s}=r,{axis:i,keepDims:o}=a,l=s.shape.length,u=nP.util.parseAxisParam(i,s.shape),h=u,p=tL.getAxesPermutation(h,l),d=s;null!=p&&(d=vb({inputs:{x:s},backend:n,attrs:{perm:p}}),h=tL.getInnerMostAxes(h.length,l)),tL.assertAxesAreInnerMostDims("any",h,l);let[c,f]=tL.computeOutAndReduceShapes(d.shape,h),m=vl({inputs:{x:d},backend:n,attrs:{shape:[-1,nP.util.sizeFromShape(f)]}}),g=vd(m,m.dtype,"any",n);return t=o?vl({inputs:{x:g},backend:n,attrs:{shape:tL.expandShapeToKeepDim(c,u)}}):vl({inputs:{x:g},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=p&&n.disposeIntermediateTensorInfo(d),t}};var tL=tL,tL=tL;class vM{constructor(e,t,r){this.variableNames=["A"];const{windowSize:n,batchSize:a,outSize:s}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${n}; i++) {
          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};
          float candidate = getA(batch, inIdx);
          if (candidate ${"max"===t?">":"<"} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class vL{constructor(e,t,r,n){let a,s;this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,nP.util.assert(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(e[e.length-1]/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),n||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,u=bt(l),h=xk("coords",l);if(1===i){const e=bt(s=l+1);a=`
        ${e} sourceLocR = ${e}(${h.join()}, 0);
        ++${h[l-1]};
        ${e} sourceLocG = ${e}(${h.join()}, 0);
        ++${h[l-2]};
        ${e} sourceLocA = ${e}(${h.join()}, 0);
        --${h[l-1]};
        ${e} sourceLocB = ${e}(${h.join()}, 0);
        --${h[l-2]};`}else s=l,a=`
        ${u} sourceLocR = coords;
        ++${h[l-1]};
        ${u} sourceLocG = coords;
        ++${h[l-2]};
        ${u} sourceLocA = coords;
        --${h[l-1]};
        ${u} sourceLocB = coords;
        --${h[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,s),d="."+p[s-1],c=p.map(e=>"int "+e),f=xk("sourceLocR",s-1).concat("inIdx.r"),m=xk("sourceLocG",s-1).concat("inIdx.g"),g=xk("sourceLocB",s-1).concat("inIdx.b"),y=xk("sourceLocA",s-1).concat("inIdx.a"),b="max"===r?"greaterThan":"lessThan",x=n?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),
                             getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()})));`,v=`vec4(
            getAChannel(${f.join()}),
            hasNextCol ? getAChannel(${m.join()}) : 0.,
            hasNextRow ? getAChannel(${g.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,w=n?"":`
      float getBestIndicesAChannel(${c.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${c.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${w}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${h[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${h[l-2]} < ${o[l-2]-1};
        ${a}
        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},
          sourceLocB${d}, sourceLocA${d}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${v};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${x}
          vec4 candidate = ${v};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function vz(e,t,r,n){let a=[r];if(tL.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),a,t.shape.length),!(0,nL.env)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let r=[],s=e.texData.get(t.dataId),i=null!==s&&s.isPacked,o=t;i&&r.push(o=e.unpackTensor(t));let[l,u]=tL.computeOutAndReduceShapes(o.shape,a),h=vl({inputs:{x:o},backend:e,attrs:{shape:[-1,nP.util.sizeFromShape(u)]}});r.push(h);let p=function e(t,r,n,a=null){let s=r.shape[0],i=r.shape[1];null!=a&&(s=a.shape[0],i=a.shape[1]);let o=tL.computeOptimalWindowSize(i),l=new vM({windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},n,null==a),u=[r];null!=a&&u.push(a);let h=t.runWebGLProgram(l,u,"int32");if(1===h.shape[1])return h;let p=e(t,r,n,h);return t.disposeIntermediateTensorInfo(h),p}(e,h,n);r.push(p);let d=vl({inputs:{x:p},backend:e,attrs:{shape:l}});return r.forEach(t=>e.disposeIntermediateTensorInfo(t)),d}return function e(t,r,n,a=null){let s=null!=a?a.shape:r.shape,i=s[s.length-1],o=new vL(s,tL.computeOptimalWindowSize(i),n,null==a),l=null==a?[r]:[r,a],u=t.runWebGLProgram(o,l,"int32");if(u.shape.length===r.shape.length){let a=e(t,r,n,u);return t.disposeIntermediateTensorInfo(u),a}return u}(e,t,n)}let vP={kernelName:C.ArgMax,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s}=n,i=nP.util.parseAxisParam(s,a.shape),o=tL.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(u.push(l=vb({inputs:{x:a},backend:r,attrs:{perm:o}})),i=tL.getInnerMostAxes(i.length,l.shape.length)),tL.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let h=vz(r,l,i[0],"max");return u.forEach(e=>r.disposeIntermediateTensorInfo(e)),h}};var tL=tL;let vB={kernelName:C.ArgMin,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s}=n,i=nP.util.parseAxisParam(s,a.shape),o=tL.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(u.push(l=vb({inputs:{x:a},backend:r,attrs:{perm:o}})),i=tL.getInnerMostAxes(i.length,l.shape.length)),tL.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let h=vz(r,l,i[0],"min");return u.forEach(e=>r.disposeIntermediateTensorInfo(e)),h}},vV=ve({opSnippet:xD+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`}),vW={kernelName:C.Asin,backendName:"webgl",kernelFunc:vV},vU=ve({opSnippet:xD+"return log(x + sqrt(x * x + 1.0));"}),vG={kernelName:C.Asinh,backendName:"webgl",kernelFunc:vU},vq=ve({opSnippet:xD+`
  return atan(x);
`}),vH={kernelName:C.Atan,backendName:"webgl",kernelFunc:vq},vj=vt({opSnippet:xX+`
  return atan(a, b);
`,packedOpSnippet:`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xY+`
  return result;
`}),vK={kernelName:C.Atan2,backendName:"webgl",kernelFunc:vj},vX=ve({opSnippet:xD+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`}),vZ={kernelName:C.Atanh,backendName:"webgl",kernelFunc:vX};var tL=tL;class vY{constructor(e,t,r,n=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&r)throw Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterHeight,p=e.effectiveFilterWidth,d=e.padInfo.top,c=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),r){this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${d}, ${c});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${n?a?m:g:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");const x=4*Math.floor(s/4),v=s%4,w=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${d}, ${c});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${x}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${w}
          }

          int xC = xCCorner + ${x};
          if (${1===v}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${w}
          } else if (${2===v}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${w}
          } else if (${3===v}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${w}
          }
        }
        setOutput(${b});
      }
    `}}class vJ{constructor(e,t,r,n=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&r)throw Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,h=e.dilationHeight,p=e.dilationWidth,d=e.effectiveFilterDepth,c=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let x="0.0";if(b||(x="-1.0 / 1e-20"),r){this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${l});
        const ivec3 pads = ivec3(${m}, ${g}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${c};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${n?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${c} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / max(count, 1.0)");const w=4*Math.floor(s/4),S=s%4,N=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${c};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${w}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${N}
            }

            int xC = xCCorner + ${w};
            if (${1===S}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${2===S}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${3===S}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${N}
            }
          }
        }
        setOutput(${v});
      }
    `}}let vQ={kernelName:C.AvgPool,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t;yK(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;nP.util.assert(tL.eitherStridesOrDilationsAreOne(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);let u=tL.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&nP.util.arraysEqual(u.inShape,u.outShape))return xQ({inputs:{x:a},backend:r});let h=new vY(u,"avg",!1);return r.runWebGLProgram(h,[a],"float32")}};var tL=tL;let v0={kernelName:C.AvgPool3D,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=n,h=new vJ(tL.computePool3DInfo(a.shape,s,i,[1,1,1],o,l,u),"avg",!1);return r.runWebGLProgram(h,[a],"float32")}};var tL=tL;class v1{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,n=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,h=l-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${1/(t*r)});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class v2{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,n=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,c=h-1-e.padInfo.front,f=p-1-e.padInfo.top,m=d-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${f}, ${m});
      const float avgMultiplier = float(${1/(t*r*n)});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}let v3={kernelName:C.AvgPool3DGrad,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,h=new v2(tL.computePool3DInfo(s.shape,i,o,[1,1,1],l,u));return r.runWebGLProgram(h,[a],s.dtype)}};var tL=tL;let v4={kernelName:C.AvgPoolGrad,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:s}=t;yK([a,s],"avgPoolGrad");let{filterSize:i,strides:o,pad:l}=n,u=new v1(tL.computePool2DInfo(s.shape,i,o,1,l));return r.runWebGLProgram(u,[a],s.dtype)}},v6={kernelName:C.BatchMatMul,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=n;return vv({a,b:s,transposeA:i,transposeB:o,backend:r})}};var tL=tL;class v5{constructor(e,t,r,n,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],tL.assertAndGetBroadcastShape(e,t),tL.assertAndGetBroadcastShape(e,r);let i="0.0";null!=n&&(tL.assertAndGetBroadcastShape(e,n),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=a&&(tL.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}var tL=tL;class v8{constructor(e,t,r,n,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],tL.assertAndGetBroadcastShape(e,t),tL.assertAndGetBroadcastShape(e,r);let i="vec4(0.0)";null!=n&&(tL.assertAndGetBroadcastShape(e,n),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(tL.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `}}let v9={kernelName:C.FusedBatchNorm,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:r})=>{let{x:n,mean:a,variance:s,offset:i,scale:o}=e;nP.util.assert(a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),nP.util.assert(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),nP.util.assert(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=r;null==l&&(l=.001);let u=[n,a,s],h=null;null!=i&&(h=i.shape,u.push(i));let p=null;null!=o&&(p=o.shape,u.push(o));let d=(0,nL.env)().getBool("WEBGL_PACK_NORMALIZATION")?new v8(n.shape,a.shape,s.shape,h,p,l):new v5(n.shape,a.shape,s.shape,h,p,l);return t.runWebGLProgram(d,u,u[0].dtype)}};var tL=tL,cp=t9;class v7{constructor(e){let t;this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const r=bt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return we.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank),a=e.map((e,t)=>`sourceLoc.${we[t]} = start[${t}] + coords.${we[t]};`);t=`
        ${r} sourceLoc;
        ${r} coords = getOutputCoords();
        ${a.join("\n")}
      `,this.userCode=`
      void main() {
        ${t}
        setOutput(getSource(${n}));
      }
    `}}let we=["x","y","z","w","u","v"];class wt{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=bt(this.rank),r=xk("coords",this.rank),n=xk("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${n.slice(-2).join()})`,s=`getChannel(getSource(${n.join()}), ${a})`,i=`
      result.x = ${s};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${n[this.rank-1]};
        result.y = ${s};
        --${n[this.rank-1]};
      }
    `,o=1===this.rank?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${n[this.rank-2]};
        result.z = ${s};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${n[this.rank-1]};
          result.w = ${s};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${n[t]} = ${r[t]} + start[${t}];`).join("\n");this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}}function wr(e){let t,r,n,a,s,{inputs:i,backend:o,attrs:l}=e,{x:u}=i,{begin:h,size:p}=l,[d,c]=cp.parseSliceParams(u,h,p);if(cp.assertParamsValid(u,d,c),0===nP.util.sizeFromShape(c))return o.makeTensorInfo(c,u.dtype,[]);if(o.shouldExecuteOnCPU([u])||"string"===u.dtype){let e=xl(o.texData.get(u.dataId).values,d,c,u.shape,u.dtype);return o.makeTensorInfo(c,u.dtype,e)}let{isPacked:f}=o.texData.get(u.dataId),m=cp.isSliceContinous(u.shape,d,c);if(f||!m){let e=(0,nL.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wt(c):new v7(c),t=[d];return o.runWebGLProgram(e,[u],u.dtype,t)}return o.uploadToGPU(u.dataId),t=o.texData.get(u.dataId),r=o.makeTensorInfo(c,u.dtype),Object.assign(n=o.texData.get(r.dataId),t),n.refCount=1,n.shape=c,n.dtype=u.dtype,a=cp.computeFlatOffset(d,nP.util.computeStrides(u.shape)),t.slice&&(a+=t.slice.flatOffset),n.slice={flatOffset:a,origDataId:t.slice&&t.slice.origDataId||u.dataId},s=o.dataRefCount.get(n.slice.origDataId)||1,o.dataRefCount.set(n.slice.origDataId,s+1),r}let wn={kernelName:C.Slice,backendName:"webgl",kernelFunc:wr},wa={kernelName:C.BatchToSpaceND,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{blockShape:s,crops:i}=n;nP.util.assert(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((e,t)=>e*t),l=tL.getReshaped(a.shape,s,o),u=tL.getPermuted(l.length,s.length),h=tL.getReshapedPermuted(a.shape,s,o),p=tL.getSliceBeginCoords(i,s.length),d=tL.getSliceSize(h,i,s.length),c=[],f=vl({inputs:{x:a},backend:r,attrs:{shape:l}}),m=vb({inputs:{x:f},backend:r,attrs:{perm:u}}),g=vl({inputs:{x:m},backend:r,attrs:{shape:h}}),y=wr({inputs:{x:g},backend:r,attrs:{begin:p,size:d}});return c.push(f),c.push(m),c.push(g),c.forEach(e=>r.disposeIntermediateTensorInfo(e)),y}},ws={kernelName:C.Bincount,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,weights:s}=t,{size:i}=n,o=bP(r.readSync(a.dataId),r.readSync(s.dataId),s.dtype,s.shape,i);return r.makeTensorInfo([i],s.dtype,o)}},wi=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,wo=`
  return float(int(a.r) & int(b.r));
`,wl={kernelName:C.BitwiseAnd,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n}=e,{a,b:s}=r,i=(0,nL.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=(0,nL.env)().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,s])||1===o){let e=n.texData.get(a.dataId).values,t=n.texData.get(s.dataId).values,[r,i]=bV(a.shape,s.shape,e,t,a.dtype),o=n.makeTensorInfo(i,a.dtype);return n.texData.get(o.dataId).values=r,o}return t=i?new xJ(wi,a.shape,s.shape,!1):new xZ(wo,a.shape,s.shape),n.runWebGLProgram(t,[a,s],a.dtype)}};var tL=tL;let wu={kernelName:C.BroadcastArgs,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{s0:n,s1:a}=t,s=r.readSync(n.dataId),i=r.readSync(a.dataId),o=tL.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return r.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},wh=vt({opSnippet:"return float(a != b);",cpuKernelImpl:b9,dtype:"bool"}),wp={kernelName:C.NotEqual,backendName:"webgl",kernelFunc:wh};function wd(e){let{inputs:t,backend:r}=e,{input:n}=t;return xQ({inputs:{x:r.texData.get(n.dataId).complexTensorInfos.real},backend:r})}let wc={kernelName:C.Real,backendName:"webgl",kernelFunc:wd},wf={kernelName:C.Cast,backendName:"webgl",kernelFunc:function e(t){let{inputs:r,backend:n,attrs:a}=t,{x:s}=r,{dtype:i}=a;if("complex64"===i){if("complex64"===s.dtype)return xQ({inputs:{x:s},backend:n});let t=tC.zeros(s.shape),r=e({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),a=x1({inputs:{real:r,imag:t},backend:n});return t.dispose(),n.disposeIntermediateTensorInfo(r),a}if("complex64"===s.dtype){let t=wd({inputs:{input:s},backend:n}),r=e({inputs:{x:t},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(t),r}if(!nP.util.hasEncodingLoss(s.dtype,i)){let e=xQ({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(n.shouldExecuteOnCPU([s])){let[e,t,r]=bW(n.texData.get(s.dataId).values,s.shape,s.dtype,i);return n.makeTensorInfo(e,t,r)}if("int32"===i){let e,t;return e=new xR(s.shape,"return float(int(x));"),{dataId:(t=n.runWebGLProgram(e,[s],"int32")).dataId,shape:t.shape,dtype:t.dtype}}if("bool"===i){let e=n.makeTensorInfo([],"bool",nP.util.getTypedArrayFromDType("bool",1)),t=wh({inputs:{a:s,b:e},backend:n});return n.disposeIntermediateTensorInfo(e),t}throw Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},wm="return ceil(x);",wg=ve({opSnippet:wm,packedOpSnippet:wm,cpuKernelImpl:bU}),wy={kernelName:C.Ceil,backendName:"webgl",kernelFunc:wg};class wb{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class wx{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}let wv={kernelName:C.ClipByValue,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s}=r,{clipValueMin:i,clipValueMax:o}=a;return t=(0,nL.env)().getBool("WEBGL_PACK_CLIP")?new wx(s.shape):new wb(s.shape),n.runWebGLProgram(t,[s],s.dtype,[[i],[o]])}};class ww{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function wS(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}let wN={kernelName:C.ComplexAbs,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{x:n}=t,a=r.texData.get(n.dataId),s=new ww(n.shape),i=[wS(n,a.complexTensorInfos.real),wS(n,a.complexTensorInfos.imag)];return r.runWebGLProgram(s,i,i[0].dtype)}};var tL=tL,tL=tL,tL=tL;class wk{constructor(e){this.outputShape=[],this.outputShape=tL.computeOutShape(e,1),this.variableNames=e.map((e,t)=>`T${t}`);const t=Array(e.length-1);t[0]=e[0][1];for(let r=1;r<t.length;r++)t[r]=t[r-1]+e[r][1];const r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const n=t[e-1];r.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${n}));`)}const n=t.length,a=t[t.length-1];r.push(`else setOutput(getT${n}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join("\n        ")}
      }
    `}}var tL=tL;class wI{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=tL.computeOutShape(e,t);const r=this.outputShape,n=r.length,a=bt(n),s=xk("coords",n),i=["x","y","z","w","u","v"].slice(0,n);this.variableNames=e.map((e,t)=>`T${t}`);const o=Array(e.length-1);o[0]=e[0][t];for(let r=1;r<o.length;r++)o[r]=o[r-1]+e[r][t];const l=i[t],u=i.slice(-2),h=i.join();let p=`if (${l} < ${o[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;for(let e=1;e<o.length;e++){const t=o[e-1];p+=`
        if (${l} < ${o[e]}  && ${l} >= ${o[e-1]}) {
          return getChannel(
            getT${e}(${wT(i,l,t)}),
            vec2(${wT(u,l,t)}));
        }`}const d=o.length,c=o[o.length-1];p+=`
        return getChannel(
          getT${d}(${wT(i,l,c)}),
          vec2(${wT(u,l,c)}));`,this.userCode=`
      float getValue(${i.map(e=>"int "+e)}) {
        ${p}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[n-1]} = ${s[n-1]} + 1;
        if (${s[n-1]} < ${r[n-1]}) {
          result.g = getValue(${s});
        }

        ${s[n-2]} = ${s[n-2]} + 1;
        if (${s[n-2]} < ${r[n-2]}) {
          result.a = getValue(${s});
        }

        ${s[n-1]} = ${s[n-1]} - 1;
        if (${s[n-2]} < ${r[n-2]} &&
            ${s[n-1]} < ${r[n-1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `}}function wT(e,t,r){let n=e.indexOf(t);return e.map((e,t)=>t===n?`${e} - ${r}`:e).join()}function wC(e){let{inputs:t,backend:r}=e,{input:n}=t;return xQ({inputs:{x:r.texData.get(n.dataId).complexTensorInfos.imag},backend:r})}let wE={kernelName:C.Imag,backendName:"webgl",kernelFunc:wC};function w$(e){let{inputs:t,backend:r,attrs:n}=e,{axis:a}=n,s=nP.util.parseAxisParam(a,t[0].shape)[0],i=t.map(e=>e.shape);tL.assertParamsConsistent(i,s);let o=tL.computeOutShape(t.map(e=>e.shape),s);if(0===nP.util.sizeFromShape(o))return r.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(e=>nP.util.sizeFromShape(e.shape)>0);return 1===l.length?xQ({inputs:{x:l[0]},backend:r}):function e(t,r,n){var a,s,i;let o,l=t[0].dtype;if("complex64"===l){let a=t.map(e=>wd({inputs:{input:e},backend:n})),s=t.map(e=>wC({inputs:{input:e},backend:n})),i=e(a,r,n),o=e(s,r,n),l=x1({inputs:{real:i,imag:o},backend:n});return a.forEach(e=>n.disposeIntermediateTensorInfo(e)),s.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}let u=n.shouldExecuteOnCPU(t);if("string"===l&&(u=!0),u){let e=t.map(e=>{let t=nP.util.sizeFromShape(e.shape.slice(r));return vl({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})}),a=bG(e.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),tL.computeOutShape(e.map(e=>e.shape),1),l,1===e[0].shape[0]),s=tL.computeOutShape(t.map(e=>e.shape),r),i=n.makeTensorInfo(s,l,a);return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),i}let h=t.filter(e=>nP.util.sizeFromShape(e.shape)>0),p=(0,nL.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&h[0].shape.length>1;if(1===h.length){let e=p?new xR(t[0].shape,xM):new xB(t[0].shape,xM);return n.runWebGLProgram(e,t,l)}let d=(0,nL.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(h.length>d){let t=[];for(let a=0;a<h.length;a+=d){let s=h.slice(a,a+d);t.push(e(s,r,n))}let a=e(t,r,n);for(let e of t)n.disposeIntermediateTensorInfo(e);return a}if(p){let e=new wI(h.map(e=>e.shape),r);return n.runWebGLProgram(e,h,l)}let{tensors2D:c,outShape:f}=(a=h,s=r,i=n,o=tL.computeOutShape(a.map(e=>e.shape),s),{tensors2D:a.map(e=>vl({inputs:{x:e},attrs:{shape:[-1,nP.util.sizeFromShape(e.shape.slice(s))]},backend:i})),outShape:o}),m=new wk(c.map(e=>e.shape)),g=n.runWebGLProgram(m,c,l);c.forEach(e=>n.disposeIntermediateTensorInfo(e));let y=vl({inputs:{x:g},attrs:{shape:f},backend:n});return n.disposeIntermediateTensorInfo(g),y}(l,s,r)}let wA={kernelName:C.Concat,backendName:"webgl",kernelFunc:w$};var tL=tL;class wR{constructor(e,t=!1,r=null,n=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,h=e.dilationWidth,p=e.filterHeight,d=e.filterWidth,c=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat;let g="",y="";r&&(g=n?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:`
          float activation(float x) {
            ${r}
          }
        `,y="result = activation(result);"),t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${g}

      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${m?3:1}];

        ivec2 xRCCorner =
            ivec2(coords[${m?1:2}], coords[${m?2:3}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${c}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${1===f}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${c}) *
                    getW(wR, wC, ${c}, d2);
              } else {
                dotProd +=
                    getX(batch, ${c}, xR, xC) *
                    getW(wR, wC, ${c}, d2);
              }

            } else if (${2===f}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${c}, d2),
                getW(wR, wC, ${c} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${c}),
                  getX(batch, xR, xC, ${c} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${c}, xR, xC),
                  getX(batch, ${c} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${3===f}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${c}, d2),
                getW(wR, wC, ${c} + 1, d2),
                getW(wR, wC, ${c} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${c}),
                  getX(batch, xR, xC, ${c} + 1),
                  getX(batch, xR, xC, ${c} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${c}, xR, xC),
                  getX(batch, ${c} + 1, xR, xC),
                  getX(batch, ${c} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${t?"result += getBiasAtOutCoords();":""}
        ${y}
        setOutput(result);
      }
    `}}class wD{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,r=e.padInfo.top,n=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,h=e.filterDepth,p=e.filterHeight,d=e.filterWidth,c=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${s}, ${i});
      const ivec3 pads = ivec3(${t}, ${r}, ${n});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${c}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${1===f}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${c}) *
                  getW(wF, wR, wC, ${c}, d2);
              } else if (${2===f}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${c}),
                  getX(batch, xF, xR, xC, ${c} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${c}, d2),
                  getW(wF, wR, wC, ${c} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${3===f}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${c}),
                  getX(batch, xF, xR, xC, ${c} + 1),
                  getX(batch, xF, xR, xC, ${c} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${c}, d2),
                  getW(wF, wR, wC, ${c} + 1, d2),
                  getW(wF, wR, wC, ${c} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class wF{constructor(e,t=!1,r=null,n=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=bo(this.outputShape.length);const s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth;let h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let e=0;e<u;e++)h+=`
           vec4 xTexelC${2*e};
           int xTexelC${2*e}Ready;
           vec4 xTexelC${2*e+1};
           int xTexelC${2*e+1}Ready;
           vec4 xC${e};`;h+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let e=0;e<u;e++)h+=`
           xTexelC${2*e} = vec4(0.0);
           xTexelC${2*e}Ready = 0;
           xTexelC${2*e+1} = vec4(0.0);
           xTexelC${2*e+1}Ready = 0;
           xC${e} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let t=0;t<(u+1)/2;t++){const r=2*t;if(h+=`
           xC = xCCorner + ${r*o};
           `,1===i){if(r<u&&(s%2==1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${r}Ready == 0) {
                   xTexelC${r} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${r}.zw = vec2(0.0);
                   }
                   xTexelC${r}Ready = 1;
                 }
               `,1===o&&r>0?h+=`
                 xC${r} = vec4(xTexelC${r-2}.zw, xTexelC${r}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${r} = vec4(previous.zw, xTexelC${r}.xy);
                   } else {
                     xC${r} = vec4(0.0, 0.0, xTexelC${r}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${r}Ready == 0) {
                   xTexelC${r} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${r}.zw = vec2(0.0);
                   }
                   xTexelC${r}Ready = 1;
                 }

                 xC${r} = xTexelC${r};
                 `,r+1<u)){const e=s%2==0?nP.util.nearestLargerEven(o):o;o%2==0&&s%2==1||o%2!=0&&s%2!=1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${e};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${r+1}Ready == 0) {
                     xTexelC${r+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${r+1}.zw = vec2(0.0);
                     }
                     xTexelC${r+1}Ready = 1;
                   }
                   `,o>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${r+1} = vec4(previous.zw, xTexelC${r+1}.xy);
                     } else {
                      xC${r+1} = vec4(0.0, 0.0, xTexelC${r+1}.xy);
                     }
                     `:h+=`
                     xC${r+1} = vec4(xTexelC${r}.zw, xTexelC${r+1}.xy);
                     `):1===e?h+=`
                     xC${r+1} = xTexelC${r};
                     `:h+=`
                     xCOffset = xC + ${e};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${r+1}Ready == 0) {
                       xTexelC${r+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${r+1}.zw = vec2(0.0);
                       }
                       xTexelC${r+1}Ready = 1;
                     }

                     xC${r+1} = xTexelC${r+1};
                     `}}else r<u&&(s%2==1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${r}Ready == 0) {
                   xTexelC${r} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${r}.zw = vec2(0.0);
                   }
                   xTexelC${r}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${r+1}Ready == 0) {
                   xTexelC${r+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${r+1}.zw = vec2(0.0);
                   }
                   xTexelC${r+1}Ready = 1;
                 }

                 xC${r} = vec4(xTexelC${r}.zw, xTexelC${r+1}.zw);
               `,r+1<u&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${r+1} = vec4(xTexelC${r+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${r}Ready == 0) {
                   xTexelC${r} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${r}.zw = vec2(0.0);
                   }
                   xTexelC${r}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${r+1}Ready == 0) {
                   xTexelC${r+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${r+1}.zw = vec2(0.);
                   }
                   xTexelC${r+1}Ready = 1;
                 }

                 xC${r} = vec4(
                   xTexelC${r}.xy, xTexelC${r+1}.xy);
               `,r+1<u&&(h+=`
                   xC${r+1} = vec4(xTexelC${r}.zw, xTexelC${r+1}.zw);
                 `)));r<u&&(h+=`
             wTexel = getW(r, ${r}, d1, d2);
             dotProd += xC${r}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${r}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,r+1<u&&(h+=`
               wTexel = getW(r, ${r+1}, d1, d2);
               dotProd += xC${r+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${r+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   
     }
   
     }
   `;let p="",d="";r&&(p=n?`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:a?`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:`vec4 activation(vec4 x) {
           ${r}
         }`,d="result = activation(result);"),t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${t?"result += getBiasAtOutCoords();":""}
         ${d}
         setOutput(result);
       }
     `}}class wO{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=bo(this.outputShape.length);const{dataFormat:r}=t,n=yY(),a="channelsLast"===r,s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)l+=`
          blockIndex = rc.z + ${t};
          pos = rc.y + ${e};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${2*e+t}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${2*e+t}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${n.output} = result;
      }
    `}}function w_(e,t){let r=e.length;return r>=3?t?[...e.slice(0,-3),e[r-3]*e[r-2],e[r-1]]:[...e.slice(0,-3),e[r-3],e[r-2]*e[r-1]]:!t&&1===r&&e[0]>1?[e[0],1]:null}function wM({x:e,filter:t,convInfo:r,backend:n,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l,u=e.shape,h=n.texData.get(e.dataId),p=r.inChannels,d=u[0]*u[1]*u[2],c=r.outChannels,f="channelsLast"===r.dataFormat,m=[];if(null!=s){let e=w_(s.shape,f);null!=e&&(s=vl({inputs:{x:s},backend:n,attrs:{shape:e}}),m.push(s))}if(null!=a){let e=w_(a.shape,f);null!=e&&(a=vl({inputs:{x:a},backend:n,attrs:{shape:e}}),m.push(a))}if(!((1===d||1===c)&&p>1e3)&&h.isPacked&&f&&null!=h.texture&&u[2]%2!=0&&nP.util.arraysEqual(h.shape.slice(-3),u.slice(-3))){let p=u[0]*u[1]*(u[2]+1),d={dataId:e.dataId,shape:[1,p,r.inChannels],dtype:e.dtype},c=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,nP.util.assert(yM(h.shape,d.shape),()=>`packed reshape ${h.shape} to ${d.shape} isn't free`);let f=vl({inputs:{x:t},backend:n,attrs:{shape:[1,r.inChannels,r.outChannels]}});m.push(f);let g=vv({a:d,b:f,backend:n,transposeA:!1,transposeB:!1,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),y=n.texData.get(g.dataId);nP.util.assert(y.isPacked,()=>"batchMatMul result is expected to be packed"),h.shape=c,y.shape=r.outShape,(l=xQ({inputs:{x:g},backend:n})).shape=r.outShape,m.push(g)}else{let u=r.outHeight*r.outWidth,h=vl({inputs:{x:e},backend:n,attrs:{shape:f?[r.batchSize,u,r.inChannels]:[r.batchSize,r.inChannels,u]}}),p=vl({inputs:{x:t},backend:n,attrs:{shape:[1,r.inChannels,r.outChannels]}}),d=vv({a:f?h:p,b:f?p:h,transposeA:!f,transposeB:!1,backend:n,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i});l=vl({inputs:{x:d},backend:n,attrs:{shape:r.outShape}}),m.push(h),m.push(p),m.push(d)}for(let e of m)n.disposeIntermediateTensorInfo(e);return l}function wL({x:e,filter:t,convInfo:r,backend:n,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:h,outWidth:p,outHeight:d,dataFormat:c}=r,f="channelsLast"===c,m=l*u*h,g=d*p,y=[r.batchSize,m,g],b=[];if(null!=s){let e=w_(s.shape,f);null!=e&&(s=vl({inputs:{x:s},backend:n,attrs:{shape:e}}),b.push(s))}if(null!=a){let e=w_(a.shape,f);null!=e&&(a=vl({inputs:{x:a},backend:n,attrs:{shape:e}}),b.push(a))}let x=vl({inputs:{x:t},backend:n,attrs:{shape:[1,m,nP.util.sizeFromShape(t.shape)/m]}});b.push(x);let v=new wO(y,r),w=[e.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=n.runWebGLProgram(v,[e],"float32",w),N=vl({inputs:{x:S},backend:n,attrs:{shape:y}});b.push(S),b.push(N);let k=null!=a,I=null!=s,T="leakyrelu"===o,C=o?vr(o,!0):null,E=new vn(f?N.shape:x.shape,f?x.shape:N.shape,f?[r.batchSize,g,r.outChannels]:[r.batchSize,r.outChannels,g],!0,!1,k,C,I,T),$=f?[N,x]:[x,N];if(a&&$.push(a),I&&$.push(s),T){let e=n.makeTensorInfo([],"float32",nP.util.createScalarValue(i,"float32"));$.push(e),b.push(e)}let A=n.runWebGLProgram(E,$,"float32"),R=vl({inputs:{x:A},backend:n,attrs:{shape:r.outShape}});for(let e of(b.push(A),b))n.disposeIntermediateTensorInfo(e);return R}let wz={kernelName:C.Conv2D,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s,filter:i}=r,{strides:o,pad:l,dataFormat:u,dilations:h,dimRoundingMode:p}=a,d=tL.convertConv2DDataFormat(u),c=tL.computeConv2DInfo(s.shape,i.shape,o,h,l,p,!1,d);if(1===c.filterHeight&&1===c.filterWidth&&1===c.dilationHeight&&1===c.dilationWidth&&1===c.strideHeight&&1===c.strideWidth&&("SAME"===c.padInfo.type||"VALID"===c.padInfo.type))t=wM({x:s,filter:i,convInfo:c,backend:n});else if(c.strideWidth<=2&&"channelsLast"===d&&(0,nL.env)().getBool("WEBGL_EXP_CONV")){let e=new wF(c),r=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];t=n.runWebGLProgram(e,[s,i],"float32",r)}else if((0,nL.env)().getBool("WEBGL_CONV_IM2COL"))t=wL({x:s,filter:i,convInfo:c,backend:n});else{let e=new wR(c);t=n.runWebGLProgram(e,[s,i],"float32")}let f=vl({inputs:{x:t},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(t),f}};var tL=tL;class wP{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,n=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${n};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${s?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class wB{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,n=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${s?3:1}];

        ivec2 dyCorner = ivec2(coords[${s?1:2}], coords[${s?2:3}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class wV{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,r=e.strideHeight,n=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${s};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${n} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class wW{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,n=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=r-1-e.padInfo.top,u=n-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${n}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${n} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}let wU={kernelName:C.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:h}=n,p=tL.convertConv2DDataFormat(l),d=new wP(tL.computeConv2DInfo(a.shape,h,i,1,o,u,!1,p));return r.runWebGLProgram(d,[a,s],"float32")}};var tL=tL;class wG{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=bo(this.outputShape.length);const t=e.filterHeight,r=e.filterWidth,n=t-1-e.padInfo.top,a=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${n}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}let wq={kernelName:C.Conv2DBackpropInput,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:h}=n,p=tL.convertConv2DDataFormat(u),d=tL.computeConv2DInfo(i,s.shape,o,1,l,h,!1,p);if((0,nL.env)().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===p){let e=[[d.strideHeight,d.strideWidth]],t=new wG(d);return r.runWebGLProgram(t,[a,s],"float32",e)}{let e=new wB(d);return r.runWebGLProgram(e,[a,s],"float32")}}};var tL=tL;let wH={kernelName:C.Conv3D,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=n,u=new wD(tL.computeConv3DInfo(a.shape,s.shape,i,l,o));return r.runWebGLProgram(u,[a,s],"float32")}};var tL=tL;let wj={kernelName:C.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=n,u=new wV(tL.computeConv3DInfo(a.shape,l,i,1,o));return r.runWebGLProgram(u,[a,s],"float32")}};var tL=tL;let wK={kernelName:C.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=n,u=new wW(tL.computeConv3DInfo(l,s.shape,o,1,i));return r.runWebGLProgram(u,[a,s],"float32")}},wX=ve({opSnippet:x7+`
  return cos(x);
`,packedOpSnippet:`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${xY}
  return result;
`}),wZ={kernelName:C.Cos,backendName:"webgl",kernelFunc:wX},wY=ve({opSnippet:`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`}),wJ={kernelName:C.Cosh,backendName:"webgl",kernelFunc:wY};class wQ{constructor(e,t,r,n,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,i,o,l]=e,[u]=t,[h,p]=r;this.outputShape=[u,h,p,l];const[d,c]=[`${i-1}.0`,`${o-1}.0`],[f,m,g]=h>1?[`${(i-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`],[y,b,x]=p>1?[`${(o-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${c} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${c}`];this.userCode=`
      const float height_ratio = float(${f});
      const float width_ratio = float(${y});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${m};
        float width_scale = ${b};

        float in_y = ${g};
        if( in_y < 0.0 || in_y > ${d} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${x};
        if( in_x < 0.0 || in_x > ${c} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${+("bilinear"===n)} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}let w0={kernelName:C.CropAndResize,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=n,h=new wQ(a.shape,s.shape,o,l,u);return r.runWebGLProgram(h,[a,s,i],"float32")}};(h=g||(g={})).Prod="*",h.Sum="+";class w1{constructor(e,t,r,n){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,s=this.op===g.Prod?"1.0":"0.0",i=r?s:`getX(${w2(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";r?(l=n?`end != ${o-1}`:"end != 0",u=n?"end + 1":"end - 1"):(l=n?`end + pow2 < ${o}`:"end >= pow2",u=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${bt(a)} coords = getOutputCoords();
        int end = ${w3(a,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${w3(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${w2(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function w2(e,t,r){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${r} for rank ${e} is not yet supported`)}function w3(e,t,r){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative ${r} for rank ${e} is not yet supported`)}var tL=tL;function w4(e,t,r,n,a,s){let i=t.shape.length,o=tL.getAxesPermutation([n],i),l=t;null!=o&&(l=vb({inputs:{x:t},backend:r,attrs:{perm:o}}));let u=tL.getInnerMostAxes(1,i)[0];if(u!==i-1)throw Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${n}`);let h=l.shape[u],p=xQ({inputs:{x:l},backend:r});for(let t=0;t<=Math.ceil(Math.log2(h))-1;t++){let n=new w1(e,l.shape,!1,s),a=[[t]],i=p;p=r.runWebGLProgram(n,[p],p.dtype,a),r.disposeIntermediateTensorInfo(i)}if(a){let t=new w1(e,l.shape,a,s),n=p;p=r.runWebGLProgram(t,[p],p.dtype),r.disposeIntermediateTensorInfo(n)}if(null!=o){let e=vb({inputs:{x:p},backend:r,attrs:{perm:tL.getUndoAxesPermutation(o)}});return r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(l),e}return p}let w6={kernelName:C.Cumprod,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=n;return w4(g.Prod,a,r,s,i,o)}},w5={kernelName:C.Cumsum,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=n;return w4(g.Sum,a,r,s,i,o)}},w8={kernelName:C.DenseBincount,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=n;if(1===a.shape.length){let e=bP(r.readSync(a.dataId),r.readSync(s.dataId),s.dtype,s.shape,i);return r.makeTensorInfo([i],s.dtype,e)}if(2===a.shape.length){let e=bB(r.bufferSync(a),r.bufferSync(s),i,o);return r.makeTensorInfo(e.shape,s.dtype,e.values)}throw Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};class w9{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}let w7={kernelName:C.DepthToSpace,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{blockSize:s,dataFormat:i}=n,o=a.shape[0],l="NHWC"===i?a.shape[1]:a.shape[2],u="NHWC"===i?a.shape[2]:a.shape[3],h="NHWC"===i?a.shape[3]:a.shape[1],p=l*s,d=u*s,c=h/(s*s),f=new w9("NHWC"===i?[o,p,d,c]:[o,c,p,d],s,i);return r.runWebGLProgram(f,[a],a.dtype)}};var tL=tL;class Se{constructor(e,t=!1,r=null,n=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=bo(this.outputShape.length);const s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";r&&(l=n?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:`
          float activation(float x) {
            ${r}
          }
        `,u="result = activation(result);"),t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${t?"result += getBiasAtOutCoords();":""}
        ${u}
        setOutput(result);
      }
    `}}class St{constructor(e,t=!1,r=null,n=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=bo(this.outputShape.length);const s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,h=e.filterWidth;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let e=0;e<h;e++)p+=`
          vec4 xTexelC${2*e};
          int xTexelC${2*e}Ready;
          vec4 xTexelC${2*e+1};
          int xTexelC${2*e+1}Ready;
          vec4 xC${e};`;p+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let e=0;e<h;e++)p+=`
          xTexelC${2*e} = vec4(0.0);
          xTexelC${2*e}Ready = 0;
          xTexelC${2*e+1} = vec4(0.0);
          xTexelC${2*e+1}Ready = 0;
          xC${e} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let e=0;e<(h+1)/2;e++){const t=2*e;if(p+=`
          xC = xCCorner + ${t*l};
          `,1===o){if(t<h&&(i%2==1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }
              `,1===l&&t>0?p+=`
                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);
                  } else {
                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }

                xC${t} = xTexelC${t};
                `,t+1<h)){const e=i%2==0?nP.util.nearestLargerEven(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${e};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {
                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${t+1}.zw = vec2(0.0);
                    }
                    xTexelC${t+1}Ready = 1;
                  }
                  `,l>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);
                    } else {
                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);
                    }
                    `:p+=`
                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);
                    `):1===e?p+=`
                    xC${t+1} = xTexelC${t};
                    `:p+=`
                    xCOffset = xC + ${e};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {
                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${t+1}.zw = vec2(0.0);
                      }
                      xTexelC${t+1}Ready = 1;
                    }

                    xC${t+1} = xTexelC${t+1};
                    `}}else t<h&&(i%2==1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {
                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${t+1}.zw = vec2(0.0);
                  }
                  xTexelC${t+1}Ready = 1;
                }

                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);
              `,t+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {
                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${t+1}.zw = vec2(0.);
                  }
                  xTexelC${t+1}Ready = 1;
                }

                xC${t} = vec4(
                  xTexelC${t}.xy, xTexelC${t+1}.xy);
              `,t+1<h&&(p+=`
                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);
                `)));t<h&&(p+=`
            wTexel = getW(r, ${t}, d1, q);
            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);
          `,t+1<h&&(p+=`
              wTexel = getW(r, ${t+1}, d1, q);
              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  
      }
    `;let d="",c="";r&&(d=n?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:`vec4 activation(vec4 x) {
          ${r}
        }`,c="result = activation(result);"),t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${d}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${t?"result += getBiasAtOutCoords();":""}
        ${c}
        setOutput(result);
      }
    `}}let Sr={kernelName:C.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s,filter:i}=r,{strides:o,pad:l,dilations:u,dimRoundingMode:h}=a,p=u;null==p&&(p=[1,1]),nP.util.assert(tL.eitherStridesOrDilationsAreOne(o,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`);let d=tL.computeConv2DInfo(s.shape,i.shape,o,p,l,h,!0);t=(0,nL.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new St(d):new Se(d);let c=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(t,[s,i],"float32",c)}};var tL=tL;class Sn{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,n=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${n};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Sa{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,n=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=r-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}let Ss={kernelName:C.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:h}=n,p=new Sn(tL.computeConv2DInfo(a.shape,h,i,o,l,u,!0));return r.runWebGLProgram(p,[a,s],"float32")}};var tL=tL;let Si={kernelName:C.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:h}=n,p=new Sa(tL.computeConv2DInfo(h,s.shape,i,o,l,u,!0));return r.runWebGLProgram(p,[a,s],"float32")}};class So{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}let Sl={kernelName:C.Diag,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{x:n}=t,a=[...n.shape,...n.shape],s=nP.util.sizeFromShape(n.shape),i=vl({inputs:{x:n},backend:r,attrs:{shape:[s]}}),o=new So(s),l=r.runWebGLProgram(o,[i],i.dtype),u=vl({inputs:{x:l},backend:r,attrs:{shape:a}});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(l),u}};var tL=tL;class Su{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:r,padInfo:n,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:h,left:p}=n;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${s});
      const ivec2 pads = ivec2(${h}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}let Sh={kernelName:C.Dilation2D,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s,filter:i}=r,{strides:o,pad:l,dilations:u}=a,h=tL.computeDilation2DInfo(s.shape,i.shape,o,l,"NHWC",u),p=new Su(h),d=vl({inputs:{x:t=n.runWebGLProgram(p,[s,i],"float32")},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(t),d}};var tL=tL;let Sp={kernelName:C.Einsum,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{equation:a}=n,{allDims:s,summedDims:i,idDims:o}=tL.decodeEinsumEquation(a,t.length);tL.checkEinsumDimSizes(s.length,o,t);let{path:l,steps:u}=tL.getEinsumComputePath(i,o),h=u.length,p=null,d=s.length,c=[];for(let e=0;e<h;++e){for(let n of u[e]){let e,{permutationIndices:a,expandDims:s}=tL.getEinsumPermutation(d,o[n]);tL.isIdentityPermutation(a)?e=t[n]:(e=vb({inputs:{x:t[n]},backend:r,attrs:{perm:a}}),c.push(e));let i=e.shape.slice();for(let e=0;e<s.length;++e)i.splice(s[e],0,1);nP.util.arraysEqual(e.shape,i)||(e=vl({inputs:{x:e},backend:r,attrs:{shape:i}}),c.push(e)),null===p?p=e:(p=vi({inputs:{a:e,b:p},backend:r}),c.push(p))}e<h-1&&(l[e]>=0&&(p=vg({inputs:{x:p},backend:r,attrs:{axis:l[e]-(s.length-d),keepDims:!1}}),c.push(p)),d--)}for(let e of c)e!==p&&r.disposeIntermediateTensorInfo(e);return p}},Sd=ve({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`}),Sc={kernelName:C.Elu,backendName:"webgl",kernelFunc:Sd},Sf=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Sm={kernelName:C.EluGrad,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r}=e,{dy:n,y:a}=t,s=(0,nL.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xJ(Sf,n.shape,a.shape):new xZ("return (b >= 0.0) ? a : a * (b + 1.0);",n.shape,a.shape);return r.runWebGLProgram(s,[n,a],n.dtype)}},Sg=vt({opSnippet:"return float(a == b);",packedOpSnippet:`
  return vec4(equal(a, b));
`,dtype:"bool",cpuKernelImpl:bq}),Sy={kernelName:C.Equal,backendName:"webgl",kernelFunc:Sg};var tL=tL;let Sb=ve({opSnippet:`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${tL.ERF_P};
  float a1 = ${tL.ERF_A1};
  float a2 = ${tL.ERF_A2};
  float a3 = ${tL.ERF_A3};
  float a4 = ${tL.ERF_A4};
  float a5 = ${tL.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`}),Sx={kernelName:C.Erf,backendName:"webgl",kernelFunc:Sb},Sv=ve({opSnippet:x7+`
  return exp(x);
`,packedOpSnippet:`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:bH,dtype:"float32"}),Sw={kernelName:C.Exp,backendName:"webgl",kernelFunc:Sv};function SS(e){let{inputs:t,attrs:r,backend:n}=e,{dim:a}=r,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(nP.util.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),vl({inputs:{x:s},backend:n,attrs:{shape:o}})}let SN={kernelName:C.ExpandDims,backendName:"webgl",kernelFunc:SS},Sk="return exp(x) - 1.0;",SI=ve({opSnippet:Sk,packedOpSnippet:Sk,cpuKernelImpl:bj}),ST={kernelName:C.Expm1,backendName:"webgl",kernelFunc:SI};class SC{constructor(e,t,r){let n;this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${a}.0`:"1.0";if("real"===e)n="return real * expR - imag * expI;";else if("imag"===e)n="return real * expI + imag * expR;";else throw Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${n}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${a});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${a}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function SE(e,t,r){let n=r.texData.get(e.dataId),a=nP.util.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=vl({inputs:{x:e},backend:r,attrs:{shape:[a/s,s]}}),o=i.shape,l=new SC("real",o,t),u=new SC("imag",o,t),h=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:o},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:o}],p=r.runWebGLProgram(l,h,"float32"),d=r.runWebGLProgram(u,h,"float32"),c=x1({inputs:{real:p,imag:d},backend:r});r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(d);let f=vl({inputs:{x:c},backend:r,attrs:{shape:e.shape}});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(c),f}let S$={kernelName:C.FFT,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{input:n}=t;return SE(n,!1,r)}};class SA{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function SR(e){let{backend:t,attrs:r}=e,{shape:n,value:a}=r,{dtype:s}=r;if("string"===(s=s||nP.util.inferDtype(a))){let e=nP.util.getArrayFromDType(s,nP.util.sizeFromShape(n));return e.fill(a),t.makeTensorInfo(n,s,e)}{let e=new SA(n,a),r=[[a]];return t.runWebGLProgram(e,[],s,r)}}let SD={kernelName:C.Fill,backendName:"webgl",kernelFunc:SR};class SF{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}let SO={kernelName:C.FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:r}=e,n=new SF(r.shape);return t.runWebGLProgram(n,[r],r.dtype)}},S_="return floor(x);",SM=ve({opSnippet:S_,packedOpSnippet:S_,cpuKernelImpl:bK}),SL={kernelName:C.Floor,backendName:"webgl",kernelFunc:SM},Sz=vt({opSnippet:`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,packedOpSnippet:`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,dtype:"int32"}),SP={kernelName:C.FloorDiv,backendName:"webgl",kernelFunc:Sz};class SB{constructor(e){this.variableNames=["A"];const t=yY(),[r,n]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class SV{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=yY(),[r,n]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${n}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}let SW={kernelName:C.FromPixels,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{pixels:s}=t,{numChannels:i}=n,o="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,l="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[u,h]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],p=[h,u],d=[h,u,i];if(l||o){let e=(0,nL.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==a||e!==SU)&&(SU=e,a=document.createElement("canvas").getContext("2d",{willReadFrequently:SU})),a.canvas.width=u,a.canvas.height=h,a.drawImage(s,0,0,u,h),s=a.canvas}let c=r.makeTensorInfo(p,"int32");r.texData.get(c.dataId).usage=f.PIXELS,r.gpgpu.uploadPixelDataToTexture(r.getTexture(c.dataId),s);let m=(0,nL.env)().getBool("WEBGL_PACK")?new SV(d):new SB(d),g=r.runWebGLProgram(m,[c],"int32");return r.disposeData(c.dataId),g}},SU=(0,nL.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");var tL=tL;let SG={kernelName:C.FusedConv2D,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s,filter:i,bias:o,preluActivationWeights:l}=r,{strides:u,pad:h,dataFormat:p,dilations:d,dimRoundingMode:c,activation:f,leakyreluAlpha:m}=a,g=tL.convertConv2DDataFormat(p),y=tL.computeConv2DInfo(s.shape,i.shape,u,d,h,c,!1,g),b=[],x=null!=o,v=null!=l,w="leakyrelu"===f,S=()=>{let e=[s,i],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){let t=vl({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(x&&e.push(t(o,p)),v&&e.push(t(l,p)),w){let t=n.makeTensorInfo([],"float32",nP.util.createScalarValue(m,"float32"));e.push(t),b.push(t)}return e};if(1===y.filterHeight&&1===y.filterWidth&&1===y.dilationHeight&&1===y.dilationWidth&&1===y.strideHeight&&1===y.strideWidth&&("SAME"===y.padInfo.type||"VALID"===y.padInfo.type))t=wM({x:s,filter:i,convInfo:y,backend:n,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else if(y.strideWidth<=2&&"channelsLast"===g&&(0,nL.env)().getBool("WEBGL_EXP_CONV")){let e=new wF(y,x,f?vr(f,!0):null,v,w),r=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],a=S();t=n.runWebGLProgram(e,a,"float32",r)}else if((0,nL.env)().getBool("WEBGL_CONV_IM2COL"))t=wL({x:s,filter:i,convInfo:y,backend:n,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else{let e=new wR(y,x,f?vr(f,!1):null,v,w),r=S();t=n.runWebGLProgram(e,r,"float32")}let N=vl({inputs:{x:t},backend:n,attrs:{shape:y.outShape}});return b.push(t),b.forEach(e=>n.disposeIntermediateTensorInfo(e)),N}};var tL=tL;let Sq={kernelName:C.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s,filter:i,bias:o,preluActivationWeights:l}=r,{strides:u,pad:h,dilations:p,dimRoundingMode:d,activation:c,leakyreluAlpha:f}=a,m=[],g=p;null==g&&(g=[1,1]),nP.util.assert(tL.eitherStridesOrDilationsAreOne(u,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${g}'`);let y=tL.computeConv2DInfo(s.shape,i.shape,u,g,h,d,!0),b=(0,nL.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels==1,x=c?vr(c,b):null,v=[s,i],w=null!=o,S=null!=l,N="leakyrelu"===c;if(w&&v.push(o),S&&v.push(l),N){let e=n.makeTensorInfo([],"float32",nP.util.createScalarValue(f,"float32"));v.push(e),m.push(e)}t=b?new St(y,w,x,S,N):new Se(y,w,x,S,N);let k=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],I=n.runWebGLProgram(t,v,"float32",k);return m.forEach(e=>n.disposeIntermediateTensorInfo(e)),I}};var tL=tL;class SH{constructor(e,t,r,n){this.sliceDim=e,this.strides=t,this.paramsShape=n,this.variableNames=["x","indices"],this.outputShape=r;const a=bt(r.length);let s=`
    int index;`;for(let e=0;e<this.sliceDim;e++)s+=`
          index = round(getIndices(coords[0], ${e}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};
          flattenIndex += index * ${this.strides[e]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}let Sj={kernelName:C.GatherNd,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{params:n,indices:a}=t,s=a.shape,i=s[s.length-1],o=nP.util.sizeFromShape(n.shape),[l,u,h,p]=tL.prepareAndValidate(n,a),d=vl({inputs:{x:a},backend:r,attrs:{shape:[u,i]}}),c=vl({inputs:{x:n},backend:r,attrs:{shape:[nP.util.sizeFromShape(n.shape)/h,h]}});if(r.shouldExecuteOnCPU([n,a])||"string"===n.dtype){let e=bX(r.readSync(a.dataId),r.bufferSync(n),n.dtype,u,i,h,p,n.shape,o);return r.makeTensorInfo(l,n.dtype,e.values)}let f=new SH(i,p,[u,h],n.shape),m=r.runWebGLProgram(f,[c,d],c.dtype),g=vl({inputs:{x:m},backend:r,attrs:{shape:l}});return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(m),g}};var tL=tL;class SK{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const r=bt(this.rank),n=function(e,t){let r=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let t=0;t<e.length;t++)2===t?n.push("index"):n.push(`${r[t]}`);return n.join()}(e,0);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${n}));
      }
    `}}function SX(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=n,l=nP.util.parseAxisParam(i,a.shape)[0];if((0,nL.env)().get("DEBUG")){let e=r.readSync(s.dataId),t=a.shape[l];for(let r=0;r<e.length;++r){let n=e[r];nP.util.assert(n<=t-1&&n>=0,()=>`GatherV2: the index value ${n} is not in [0, ${t-1}]`)}}let u=tL.segment_util.collectGatherOpShapeInfo(a,s,l,o),h=nP.util.sizeFromShape(s.shape),p=[],d=vl({inputs:{x:a},backend:r,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),c=vl({inputs:{x:s},backend:r,attrs:{shape:[u.batchSize,h/u.batchSize]}});p.push(d),p.push(c);let f=[u.batchSize,u.outerSize,h/u.batchSize,u.sliceSize];if(r.shouldExecuteOnCPU([a,s])||"string"===a.dtype){let e=r.bufferSync(c),t=bZ(r.bufferSync(d),e,f);return p.forEach(e=>r.disposeIntermediateTensorInfo(e)),r.makeTensorInfo(u.outputShape,t.dtype,t.values)}let m=new SK(d.shape,f),g=r.runWebGLProgram(m,[d,c],d.dtype);p.push(g);let y=vl({inputs:{x:g},backend:r,attrs:{shape:u.outputShape}});return p.forEach(e=>r.disposeIntermediateTensorInfo(e)),y}let SZ={kernelName:C.GatherV2,backendName:"webgl",kernelFunc:SX},SY=vt({opSnippet:"return float(a > b);",packedOpSnippet:`
  return vec4(greaterThan(a, b));
`,cpuKernelImpl:bY,dtype:"bool"}),SJ={kernelName:C.Greater,backendName:"webgl",kernelFunc:SY},SQ=vt({opSnippet:"return float(a >= b);",packedOpSnippet:`
  return vec4(greaterThanEqual(a, b));
`,dtype:"bool",cpuKernelImpl:bJ}),S0={kernelName:C.GreaterEqual,backendName:"webgl",kernelFunc:SQ},S1={kernelName:C.IFFT,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{input:n}=t;return SE(n,!0,r)}},S2=ve({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),S3={kernelName:C.IsFinite,backendName:"webgl",kernelFunc:S2},S4=ve({opSnippet:"return float(isinf(x));",dtype:"bool"}),S6={kernelName:C.IsInf,backendName:"webgl",kernelFunc:S4},S5=ve({opSnippet:"return float(isnan(x));",dtype:"bool"}),S8={kernelName:C.IsNan,backendName:"webgl",kernelFunc:S5},S9=vt({opSnippet:"return float(a < b);",packedOpSnippet:`
  return vec4(lessThan(a, b));
`,cpuKernelImpl:bQ,dtype:"bool"}),S7={kernelName:C.Less,backendName:"webgl",kernelFunc:S9},Ne=vt({opSnippet:"return float(a <= b);",packedOpSnippet:`
  return vec4(lessThanEqual(a, b));
`,cpuKernelImpl:b0,dtype:"bool"}),Nt={kernelName:C.LessEqual,backendName:"webgl",kernelFunc:Ne},Nr={kernelName:C.LinSpace,backendName:"webgl",kernelFunc:function(e){let{backend:t,attrs:r}=e,{start:n,stop:a,num:s}=r,i=b1(n,a,s);return t.makeTensorInfo([i.length],"float32",i)}},Nn=ve({opSnippet:x7+`
  return x < 0.0 ? 0./0. : log(x);
`,packedOpSnippet:`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,cpuKernelImpl:b2}),Na={kernelName:C.Log,backendName:"webgl",kernelFunc:Nn},Ns=ve({opSnippet:x7+`
  return log(1.0 + x);
`}),Ni={kernelName:C.Log1p,backendName:"webgl",kernelFunc:Ns},No=vt({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,dtype:"bool"}),Nl={kernelName:C.LogicalAnd,backendName:"webgl",kernelFunc:No},Nu=ve({opSnippet:"return float(!(x >= 1.0));"}),Nh={kernelName:C.LogicalNot,backendName:"webgl",kernelFunc:Nu},Np=vt({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,dtype:"bool"}),Nd={kernelName:C.LogicalOr,backendName:"webgl",kernelFunc:Np};class Nc{constructor(e,t,r,n,a){let s;this.variableNames=["x"],this.outputShape=[];const i=e[3]-1;this.outputShape=e;const o=`float(${r}) + float(${n}) * sum`;s=.5===a?`inversesqrt(${o})`:1===a?`1.0/(${o})`:`exp(log(${o}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${t}; j <= ${t}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${s};
        setOutput(val);
      }
    `}}class Nf{constructor(e,t,r,n,a){let s;this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e[3]-1;this.outputShape=e;const o=`float(${r}) + float(${n}) * sum`;s=.5===a?`inversesqrt(${o})`:1===a?`1.0/(${o})`:`exp(log(${o}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${t};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${t}; j <= ${t}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${s};
        setOutput(result);
      }
    `}}let Nm={kernelName:C.LRN,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n,u=(0,nL.env)().getBool("WEBGL_PACK_NORMALIZATION")?new Nf(a.shape,s,i,o,l):new Nc(a.shape,s,i,o,l);return r.runWebGLProgram(u,[a],a.dtype)}};class Ng{constructor(e,t,r,n,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=n,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${n}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${n})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}let Ny={kernelName:C.LRNGrad,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:h}=n,p=new Ng(a.shape,o,l,u,h);return r.runWebGLProgram(p,[a,s,i],a.dtype)}};var tL=tL;function Nb(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s}=r,{reductionIndices:i,keepDims:o}=a,l=s.shape.length,u=nP.util.parseAxisParam(i,s.shape),h=u,p=tL.getAxesPermutation(h,l),d=null!=p,c=n.shouldExecuteOnCPU([s]),f=s;if(d){if(c){let e=n.texData.get(f.dataId).values,t=Array(l);for(let e=0;e<t.length;e++)t[e]=s.shape[p[e]];let r=xw(e,s.shape,s.dtype,p,t);f=n.makeTensorInfo(t,s.dtype),n.texData.get(f.dataId).values=r}else f=vm(s,p,n);h=tL.getInnerMostAxes(h.length,l)}tL.assertAxesAreInnerMostDims("max",h,l);let[m,g]=tL.computeOutAndReduceShapes(f.shape,h),y=m;if(o&&(y=tL.expandShapeToKeepDim(m,u)),c){let e=b3(n.texData.get(f.dataId).values,nP.util.sizeFromShape(g),y,s.dtype);t=n.makeTensorInfo(y,s.dtype),n.texData.get(t.dataId).values=e}else{var b,x;let e,r,a,s,i;b=f,x=y,e=nP.util.sizeFromShape(g),r=nP.util.sizeFromShape(b.shape),s=vd(a=vl({inputs:{x:b},attrs:{shape:[r/e,e]},backend:n}),b.dtype,"max",n),i=vl({inputs:{x:s},attrs:{shape:x},backend:n}),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),t=i}return d&&n.disposeIntermediateTensorInfo(f),t}let Nx={kernelName:C.Max,backendName:"webgl",kernelFunc:Nb},Nv=vt({opSnippet:xX+`
  return max(a, b);
`,packedOpSnippet:`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xY+`
  return result;
`,cpuKernelImpl:b4}),Nw={kernelName:C.Maximum,backendName:"webgl",kernelFunc:Nv};var tL=tL;let NS={kernelName:C.MaxPool,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t;yK(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;nP.util.assert(tL.eitherStridesOrDilationsAreOne(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);let u=tL.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&nP.util.arraysEqual(u.inShape,u.outShape))return xQ({inputs:{x:a},backend:r});let h=new vY(u,"max",!1);return r.runWebGLProgram(h,[a],a.dtype)}};var tL=tL;let NN={kernelName:C.MaxPool3D,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=n,h=new vJ(tL.computePool3DInfo(a.shape,s,i,[1,1,1],o,u,l),"max",!1);return r.runWebGLProgram(h,[a],a.dtype)}};var tL=tL;class Nk{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,r=e.strideWidth,n=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${n}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${a*s-1} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class NI{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,r=e.strideHeight,n=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,h=o-1-e.padInfo.front,p=l-1-e.padInfo.top,d=u-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${p}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${n}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${o*l*u-1} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}let NT={kernelName:C.MaxPool3DGrad,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,h=tL.computePool3DInfo(s.shape,i,o,[1,1,1],l,u),p=new vJ(h,"max",!0),d=r.runWebGLProgram(p,[s],s.dtype),c=new NI(h),f=r.runWebGLProgram(c,[a,d],s.dtype);return r.disposeIntermediateTensorInfo(d),f}};var tL=tL;let NC={kernelName:C.MaxPoolGrad,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:s,output:i}=t;yK([s,i],"maxPoolGrad");let{filterSize:o,strides:l,pad:u,dimRoundingMode:h}=n,p=tL.computePool2DInfo(s.shape,o,l,1,u,h),d=new vY(p,"max",!0),c=r.runWebGLProgram(d,[s],s.dtype),f=new Nk(p),m=r.runWebGLProgram(f,[a,c],s.dtype);return r.disposeIntermediateTensorInfo(c),m}};var tL=tL;let NE={kernelName:C.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let n,a,{x:s}=e,{filterSize:i,strides:o,pad:l,includeBatchInIndex:u}=t;nP.util.assert(4===s.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);let h=[1,1];nP.util.assert(tL.eitherStridesOrDilationsAreOne(o,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);let p=tL.computePool2DInfo(s.shape,i,o,h,l),[d,c]=(n=new vY(p,"max",!1),a=r.runWebGLProgram(n,[s],"float32"),n=new vY(p,"max",!0,!0,u),[a,r.runWebGLProgram(n,[s],"float32")]);return[d,c]}};var tL=tL;let N$={kernelName:C.Mean,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:r})=>{var n,a;let s,i,o,l,u,{x:h}=e,{keepDims:p,axis:d}=t,c=h.shape.length,f=nP.util.parseAxisParam(d,h.shape),m=f,g=tL.getAxesPermutation(m,c),y=null!=g,b=r.shouldExecuteOnCPU([h]),x=[],v=h;if(y){if(b){let e=r.texData.get(v.dataId).values,t=Array(c);for(let e=0;e<t.length;e++)t[e]=h.shape[g[e]];let n=xw(e,h.shape,h.dtype,g,t);v=r.makeTensorInfo(t,h.dtype),r.texData.get(v.dataId).values=n}else v=vm(h,g,r);x.push(v),m=tL.getInnerMostAxes(m.length,c)}tL.assertAxesAreInnerMostDims("sum",m,c);let[w,S]=tL.computeOutAndReduceShapes(v.shape,m),N=w;p&&(N=tL.expandShapeToKeepDim(w,f));let k=(n=v,a=N,s=nP.util.sizeFromShape(S),i=nP.util.sizeFromShape(n.shape),l=vd(o=vl({inputs:{x:n},attrs:{shape:[i/s,s]},backend:r}),"float32","mean",r),u=vl({inputs:{x:l},attrs:{shape:a},backend:r}),r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),u);for(let e of x)r.disposeIntermediateTensorInfo(e);return k}};var tL=tL;let NA={kernelName:C.Min,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s}=r,{axis:i,keepDims:o}=a,l=s.shape.length,u=nP.util.parseAxisParam(i,s.shape),h=u,p=tL.getAxesPermutation(h,l),d=s;null!=p&&(d=vb({inputs:{x:s},backend:n,attrs:{perm:p}}),h=tL.getInnerMostAxes(h.length,s.shape.length)),tL.assertAxesAreInnerMostDims("min",h,l);let[c,f]=tL.computeOutAndReduceShapes(d.shape,h),m=vl({inputs:{x:d},backend:n,attrs:{shape:[-1,nP.util.sizeFromShape(f)]}}),g=vd(m,m.dtype,"min",n);return t=o?vl({inputs:{x:g},backend:n,attrs:{shape:tL.expandShapeToKeepDim(c,u)}}):vl({inputs:{x:g},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=p&&n.disposeIntermediateTensorInfo(d),t}},NR=vt({opSnippet:xX+`
  return min(a, b);
`,packedOpSnippet:`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xY+`
  return result;
`,cpuKernelImpl:b6}),ND={kernelName:C.Minimum,backendName:"webgl",kernelFunc:NR};class NF{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((t,r)=>t[0]+e[r]+t[1]);const n=e.length,a=bt(n),s=t.map(e=>e[0]).join(","),i=t.map((t,r)=>t[0]+e[r]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n),l=+("reflect"!==r);if(1===n){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${n}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}}class NO{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,r)=>t[0]+e[r]+t[1]);const n=e.length,a=bt(n),s=t.map(e=>e[0]).join(","),i=t.map((t,r)=>t[0]+e[r]).join(","),o=xk("rc",n),l=xk("source",n),u=`${o[n-1]} < ${this.outputShape[n-1]}`,h=1===n?"source":`vec2(${l.slice(-2).join()})`,p=+("reflect"!==r);let d="";if(1===n){const e=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;d=`
        ${a} rc = outputLoc;
        ${e}
        result[0] = getChannel(getX(${l.join()}), ${h});
        ${o[n-1]} += 1;
        if(${u}) {
          ${e}
          result[1] = getChannel(getX(${l.join()}), ${h});
        }
      `}else{const e=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;d=`
        ${a} rc = outputLoc;
        ${e}
        result[0] = getChannel(getX(${l.join()}), ${h});
        ${o[n-1]} += 1;
        if(${u}) {
          ${e}
          result[1] = getChannel(getX(${l.join()}), ${h});
        }
        rc = outputLoc;
        ${o[n-2]} += 1;
        if(${o[n-2]} < ${this.outputShape[n-2]}) {
          ${e}
          result[2] = getChannel(getX(${l.join()}), ${h});
          ${o[n-1]} += 1;
          if(${u}) {
            ${e}
            result[3] = getChannel(getX(${l.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}}let N_={kernelName:C.MirrorPad,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:r})=>{let{x:n}=e,{paddings:a,mode:s}=r,i=(0,nL.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new NO(n.shape,a,s):new NF(n.shape,a,s);return t.runWebGLProgram(i,[n],n.dtype)}},NM=vt({opSnippet:`if (b == 0.0) return NAN;
  return mod(a, b);`,packedOpSnippet:`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+xY+`
  return result;
`}),NL={kernelName:C.Mod,backendName:"webgl",kernelFunc:NM};class Nz{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}var tL=tL;let NP=vt({opSnippet:`
if (a == b) {
  return 1.0;
};
return a / b;`,packedOpSnippet:`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,checkOutOfBounds:!0}),NB={kernelName:C.RealDiv,backendName:"webgl",kernelFunc:NP},NV="return a - b;",NW=vt({opSnippet:NV,packedOpSnippet:NV,supportsComplex:!0,cpuKernelImpl:xb}),NU={kernelName:C.Sub,backendName:"webgl",kernelFunc:NW};function NG(e){let{inputs:t,backend:r,attrs:n}=e,{logits:a}=t,{dim:s}=n,i=nP.util.parseAxisParam([s],a.shape),o=Nb({inputs:{x:a},backend:r,attrs:{reductionIndices:i,keepDims:!1}}),l=tL.expandShapeToKeepDim(o.shape,i),u=vl({inputs:{x:o},backend:r,attrs:{shape:l}}),h=NW({inputs:{a:a,b:u},backend:r}),p=Sv({inputs:{x:h},backend:r}),d=vg({inputs:{x:p},backend:r,attrs:{axis:i,keepDims:!1}}),c=vl({inputs:{x:d},backend:r,attrs:{shape:l}}),f=NP({inputs:{a:p,b:c},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(c),f}let Nq={kernelName:C.Softmax,backendName:"webgl",kernelFunc:NG},NH={kernelName:C.Multinomial,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=n,l=o?a:NG({inputs:{logits:a},backend:r,attrs:{dim:a.shape.length-1}}),u=new Nz(l.shape[0],l.shape[1],s),h=r.runWebGLProgram(u,[l],"int32",[[i]]);return o||r.disposeIntermediateTensorInfo(l),h}},Nj=xD+`
  return -x;
`,NK=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,NX={kernelName:C.Neg,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n}=e,{x:a}=r;if(n.shouldExecuteOnCPU([a])){let[e,t]=b8(n.texData.get(a.dataId).values,a.shape,a.dtype);return n.makeTensorInfo(t,a.dtype,e)}return t=(0,nL.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new xB(a.shape,NK):new xR(a.shape,Nj),n.runWebGLProgram(t,[a],a.dtype)}};var tL=tL,pD=pD;let NZ=pD.nonMaxSuppressionV3Impl,NY={kernelName:C.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function(e){tL.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:r,attrs:n}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=n,{selectedIndices:u}=NZ(r.readSync(a.dataId),r.readSync(s.dataId),i,o,l);return r.makeTensorInfo([u.length],"int32",new Int32Array(u))}};var tL=tL,pD=pD;let NJ=pD.nonMaxSuppressionV4Impl,NQ={kernelName:C.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function(e){tL.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:r,attrs:n}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=n,{selectedIndices:h,validOutputs:p}=NJ(r.readSync(a.dataId),r.readSync(s.dataId),i,o,l,u);return[r.makeTensorInfo([h.length],"int32",new Int32Array(h)),r.makeTensorInfo([],"int32",new Int32Array([p]))]}};var tL=tL,pD=pD;let N0=pD.nonMaxSuppressionV5Impl,N1={kernelName:C.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function(e){tL.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:r,attrs:n}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=n,{selectedIndices:h,selectedScores:p}=N0(r.readSync(a.dataId),r.readSync(s.dataId),i,o,l,u);return[r.makeTensorInfo([h.length],"int32",new Int32Array(h)),r.makeTensorInfo([p.length],"float32",new Float32Array(p))]}};class N2{constructor(e,t,r,n){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${n}), float(${r}),
                      float(index == coords.y)));
      }
    `}}let N3={kernelName:C.OneHot,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=n,u=nP.util.sizeFromShape(a.shape),h=new N2(u,i,o,l),p=vl({inputs:{x:a},backend:r,attrs:{shape:[u]}}),d=r.runWebGLProgram(h,[p],s);r.disposeIntermediateTensorInfo(p);let c=vl({inputs:{x:d},backend:r,attrs:{shape:[...a.shape,i]}});return r.disposeIntermediateTensorInfo(d),c}};function N4(e){let{inputs:t,backend:r}=e,{x:n}=t;if("complex64"!==n.dtype)return SR({attrs:{shape:n.shape,dtype:n.dtype,value:"string"===n.dtype?"":0},backend:r});{let e=wd({inputs:{input:n},backend:r}),t=N4({inputs:{x:e},backend:r}),a=wC({inputs:{input:n},backend:r}),s=N4({inputs:{x:a},backend:r}),i=x1({inputs:{real:t,imag:s},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(s),i}}let N6={kernelName:C.ZerosLike,backendName:"webgl",kernelFunc:N4},N5={kernelName:C.OnesLike,backendName:"webgl",kernelFunc:function e(t){let{inputs:r,backend:n}=t,{x:a}=r;if("string"===a.dtype)throw Error("onesLike is not supported under string dtype");if("complex64"!==a.dtype)return SR({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:n});{let t=wd({inputs:{input:a},backend:n}),r=e({inputs:{x:t},backend:n}),s=wC({inputs:{input:a},backend:n}),i=N4({inputs:{x:s},backend:n}),o=x1({inputs:{real:r,imag:i},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}}},N8={kernelName:C.Pack,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{axis:a}=n;if(1===t.length)return SS({inputs:{input:t[0]},backend:r,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(e=>{nP.util.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),nP.util.assert(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=w$({inputs:t.map(e=>{let t=SS({inputs:{input:e},backend:r,attrs:{dim:a}});return o.push(t),t}),backend:r,attrs:{axis:a}});return o.forEach(e=>r.disposeIntermediateTensorInfo(e)),l}};class N9{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,r)=>t[0]+e[r]+t[1]);const n=e.length,a=bt(n),s=t.map(e=>e[0]).join(","),i=t.map((t,r)=>t[0]+e[r]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n);if(1===n){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}}class N7{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,r)=>t[0]+e[r]+t[1]);const n=e.length,a=bt(n),s=t.map(e=>e[0]).join(","),i=t.map((t,r)=>t[0]+e[r]).join(","),o=xk("rc",n),l=xk("source",n),u=`${o[n-1]} < ${this.outputShape[n-1]}`,h=1===n?"source":`vec2(${l.slice(-2).join()})`,p=[`${a} rc = outputLoc;`,`${o[n-1]} += 1;
       if(${u}) {
      `,1===n?"":`}
       rc = outputLoc;
       ${o[n-2]} += 1;
       if(${o[n-2]} < ${this.outputShape[n-2]}) {`,1===n?"":`  ${o[n-1]} += 1;
         if(${u}) {`],d=1===n?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let c="";for(let e=0,t=1===n?2:4;e<t;e++)c+=`
        ${p[e]}
        if (${d}) {
          result[${e}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${e}] = getChannel(getX(${l.join()}), ${h});
        }
      `;c+=1===n?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${c}
        setOutput(result);
      }
    `}}let ke=e=>{let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{paddings:s,constantValue:i}=n;if(0===nP.util.sizeFromShape(a.shape))return SR({backend:r,attrs:{shape:s.map((e,t)=>e[0]+a.shape[t]+e[1]),value:i,dtype:a.dtype}});let o=(0,nL.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new N7(a.shape,s,i):new N9(a.shape,s,i),l=[[i]];return r.runWebGLProgram(o,[a],a.dtype,l)},kt={kernelName:C.PadV2,backendName:"webgl",kernelFunc:ke},kr=vt({opSnippet:`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,packedOpSnippet:`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+xY+`
  return result;
`}),kn={kernelName:C.Pow,backendName:"webgl",kernelFunc:kr};var tL=tL;let ka={kernelName:C.Prod,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s}=r,{axis:i,keepDims:o}=a,l=s.shape.length,u=[],h=nP.util.parseAxisParam(i,s.shape),p=h,d=tL.getAxesPermutation(p,l),c=s;if(null!=d&&(c=vb({inputs:{x:s},backend:n,attrs:{perm:d}}),p=tL.getInnerMostAxes(p.length,l),u.push(c)),tL.assertAxesAreInnerMostDims("prod",p,l),n.shouldExecuteOnCPU([c])){let e=n.texData.get(c.dataId).values,{outVals:r,outShape:a,outDtype:s}=b7(c.shape,c.dtype,e,p);t=n.makeTensorInfo(a,s,r)}else{let[e,r]=tL.computeOutAndReduceShapes(c.shape,p),a=vl({inputs:{x:c},backend:n,attrs:{shape:[-1,nP.util.sizeFromShape(r)]}}),i=vd(a,(0,dQ.sumOutType)(s.dtype),"prod",n);t=vl({inputs:{x:i},backend:n,attrs:{shape:e}}),u.push(a),u.push(i)}if(o){u.push(t);let e=tL.expandShapeToKeepDim(t.shape,h);t=vl({inputs:{x:t},backend:n,attrs:{shape:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),t}},ks={kernelName:C.RaggedGather,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=n,l=a.map(e=>r.readSync(e.dataId)),u=a.map(e=>e.shape),h=r.readSync(s.dataId),p=r.readSync(i.dataId),[d,c,f]=xe(l,u,h,s.shape,s.dtype,p,i.shape,o),m=d.map(e=>r.makeTensorInfo([e.length],"int32",e)),g=r.makeTensorInfo(f,s.dtype,c);return m.concat([g])}},ki={kernelName:C.RaggedRange,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{starts:n,limits:a,deltas:s}=t,i=r.readSync(n.dataId),o=r.readSync(a.dataId),l=r.readSync(s.dataId),[u,h]=xt(i,n.shape,n.dtype,o,a.shape,l,s.shape);return[r.makeTensorInfo([u.length],"int32",u),r.makeTensorInfo([h.length],n.dtype,h)]}},ko={kernelName:C.RaggedTensorToTensor,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=n,u=r.readSync(a.dataId),h=r.readSync(s.dataId),p=r.readSync(i.dataId),d=o.map(e=>r.readSync(e.dataId)),c=o.map(e=>e.shape),[f,m]=xr(u,a.shape,h,s.shape,s.dtype,p,i.shape,d,c,l);return r.makeTensorInfo(f,s.dtype,m)}},kl=e=>{let{backend:t,attrs:r}=e,{start:n,stop:a,step:s,dtype:i}=r,o=xn(n,a,s,i);return t.makeTensorInfo([o.length],i,o)},ku={kernelName:C.Range,backendName:"webgl",kernelFunc:kl},kh=ve({opSnippet:"return 1.0 / x;"}),kp={kernelName:C.Reciprocal,backendName:"webgl",kernelFunc:kh},kd=ve({opSnippet:xD+`
  return (x < 0.0) ? 0.0 : x;
`,packedOpSnippet:`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),kc={kernelName:C.Relu,backendName:"webgl",kernelFunc:kd},kf=ve({opSnippet:xD+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,packedOpSnippet:`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),km={kernelName:C.Relu6,backendName:"webgl",kernelFunc:kf};class kg{constructor(e,t,r,n,a){this.variableNames=["A"],this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,r,l];const u=[n&&t>1?i-1:i,n&&r>1?o-1:o],h=[n&&t>1?t-1:t,n&&r>1?r-1:r];this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class ky{constructor(e,t,r,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,r,l];const u=[n&&t>1?i-1:i,n&&r>1?o-1:o],h=[n&&t>1?t-1:t,n&&r>1?r-1:r];this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}let kb={kernelName:C.ResizeBilinear,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=n,[l,u]=o,h=(0,nL.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ky(a.shape,l,u,s,i):new kg(a.shape,l,u,s,i);return r.runWebGLProgram(h,[a],"float32")}};class kx{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,n,a]=t,[,s,i]=e,o=[r&&s>1?n-1:n,r&&i>1?a-1:a],l=[r&&s>1?s-1:s,r&&i>1?i-1:i],u=o[0]/l[0],h=o[1]/l[1],p=1/u,d=1/h,c=2*Math.ceil(p)+2,f=2*Math.ceil(d)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${c});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${n-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}let kv={kernelName:C.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a,dy:s}=t,{alignCorners:i}=n,o=new kx(s.shape,a.shape,i);return r.runWebGLProgram(o,[s],s.dtype)}};class kw{constructor(e,t,r,n,a){this.variableNames=["A"],this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,r,l];const u=[n&&t>1?i-1:i,n&&r>1?o-1:o],h=[n&&t>1?t-1:t,n&&r>1?r-1:r];this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${n?"0.5":"0.0"})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class kS{constructor(e,t,r,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,r,l];const u=[n&&t>1?i-1:i,n&&r>1?o-1:o],h=[n&&t>1?t-1:t,n&&r>1?r-1:r];this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${n?"0.5":"0.0"})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}let kN={kernelName:C.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=n,[l,u]=o,h=(0,nL.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new kS(a.shape,l,u,s,i):new kw(a.shape,l,u,s,i);return r.runWebGLProgram(h,[a],a.dtype)}};class kk{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,n,a]=t,[,s,i]=e,o=[r&&s>1?n-1:n,r&&i>1?a-1:a],l=[r&&s>1?s-1:s,r&&i>1?i-1:i],u=o[0]/l[0],h=o[1]/l[1],p=1/u,d=1/h,c=2*Math.ceil(p)+2,f=2*Math.ceil(d)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${c});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${n}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}let kI={kernelName:C.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a,dy:s}=t,{alignCorners:i}=n,o=new kk(s.shape,a.shape,i);return r.runWebGLProgram(o,[s],s.dtype)}};class kT{constructor(e,t){this.variableNames=["x"];const r=e.length;if(r>4)throw Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,1===r){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const n=e.map((r,n)=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`).join(","),a=bt(r);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${n}));
      }
    `}}class kC{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const n=xk("rc",r),a=`${n[r-1]} + 1 < ${this.outputShape[r-1]}`,s=`${n[r-2]} + 1 < ${this.outputShape[r-2]}`,i=bt(r);function o(r){let n=e.map((n,a)=>{var s,i;return s=a,i=r,-1!==t.indexOf(s)&&1!==e[s]?`${e[s]} - ${i[s]} - 1`:`${i[s]}`}),a=n.join(","),s=n.slice(-2).join(",");return`getChannel(getX(${a}), vec2(${s}))`}1===r?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(n.slice())};
          if(${a}){
            result.g = ${function(e){return e[r-1]="("+e[r-1]+" + 1)",o(e)}(n.slice())};
          }
          if(${s}) {
            result.b = ${function(e){return e[r-2]="("+e[r-2]+" + 1)",o(e)}(n.slice())};
            if(${a}) {
              result.a = ${function(e){return e[r-1]="("+e[r-1]+" + 1)",e[r-2]="("+e[r-2]+" + 1)",o(e)}(n.slice())};
            }
          }
          setOutput(result);
        }
    `}}let kE={kernelName:C.Reverse,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{dims:s}=n,i=a.shape.length,o=nP.util.parseAxisParam(s,a.shape);if(0===i)return xQ({inputs:{x:a},backend:r});let l=(0,nL.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kC(a.shape,o):new kT(a.shape,o);return r.runWebGLProgram(l,[a],a.dtype)}};var tL=tL;class k${constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],n=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${n} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}let kA={kernelName:C.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{image:n}=e,{radians:a,fillValue:s,center:i}=t,o=new k$(n.shape,s),[l,u]=tL.getImageCenter(i,n.shape[1],n.shape[2]),h=[[l,u,Math.sin(a),Math.cos(a)]];return r.runWebGLProgram(o,[n],n.dtype,h)}},kR=ve({opSnippet:`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`}),kD={kernelName:C.Round,backendName:"webgl",kernelFunc:kR},kF=ve({opSnippet:"return inversesqrt(x);",cpuKernelImpl:xa}),kO={kernelName:C.Rsqrt,backendName:"webgl",kernelFunc:kF};var tL=tL;class k_{constructor(e,t,r,n,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const l=bt(a.length),u=bt(s.length);let h="";1===r?h="i":2===r&&(h="i, j");const p=`getIndices(${h})`;let d="";1===n?d="i":2===n&&(d="i, coords[1]");const c=`getUpdates(${d})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`;this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${t>1?"strides[j]":"strides"};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${c};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}}class kM{constructor(e,t,r,n,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const l=bt(a.length),u=bt(s.length);let h="";1===r?h="i":2===r&&(h="i, j");const p=`getIndices(${h})`;let d="";1===n?d="i":2===n&&(d="i, coords[1]");const c=`getUpdates(${d})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`;this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${t>1?"strides[j]":"strides"};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${t>1?"strides[j + 1]":"strides"};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${c};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}}let kL={kernelName:C.ScatterNd,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{indices:s,updates:i}=r,{shape:o}=a,{sliceRank:l,numUpdates:u,sliceSize:h,strides:p,outputSize:d}=tL.calculateShapes(i,s,o),c=[d/h,h];if(0===d)return n.makeTensorInfo(o,s.dtype);let f=vl({inputs:{x:s},backend:n,attrs:{shape:[u,l]}}),m=vl({inputs:{x:i},backend:n,attrs:{shape:[u,h]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));t=(0,nL.env)().getBool("WEBGL_PACK")?new kM(u,l,f.shape.length,m.shape.length,p,c):new k_(u,l,f.shape.length,m.shape.length,p,c);let y=n.runWebGLProgram(t,[m,f,g],m.dtype),b=vl({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(g),b}};class kz{constructor(e,t,r,n){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===(0,nL.env)().getNumber("WEBGL_VERSION")?"while (left < right) {":a;this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${s}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${"left"===n?"<":"<="} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}let kP={kernelName:C.SearchSorted,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{sortedSequence:a,values:s}=t,{side:i}=n,o=new kz(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return r.runWebGLProgram(o,[a,s],"int32",l)}};class kB{constructor(e,t,r){let n,a;if(this.variableNames=["c","a","b"],this.outputShape=t,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)a="resRC",n="resRC";else{const r=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let n=0;n<t.length;n++)i.push(`${r[n]}`),n<e&&s.push(`${r[n]}`);n=s.join(),a=i.join()}const s=bt(r);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${n});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}let kV={kernelName:C.Select,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{condition:n,t:a,e:s}=t,i=new kB(n.shape.length,a.shape,a.shape.length);return r.runWebGLProgram(i,[n,a,s],(0,dQ.upcastType)(a.dtype,s.dtype))}};var tL=tL;let kW=ve({opSnippet:`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${tL.SELU_SCALEALPHA};
  float scale = ${tL.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`}),kU={kernelName:C.Selu,backendName:"webgl",kernelFunc:kW},kG=ve({opSnippet:x7+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,packedOpSnippet:`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:xi}),kq={kernelName:C.Sigmoid,backendName:"webgl",kernelFunc:kG},kH=ve({opSnippet:`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`}),kj={kernelName:C.Sign,backendName:"webgl",kernelFunc:kH},kK=ve({opSnippet:x7+`
  return sin(x);
`,packedOpSnippet:`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${xY}
  return result;
`}),kX={kernelName:C.Sin,backendName:"webgl",kernelFunc:kK},kZ=ve({opSnippet:`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`}),kY={kernelName:C.Sinh,backendName:"webgl",kernelFunc:kZ},kJ=ve({opSnippet:`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`}),kQ={kernelName:C.Softplus,backendName:"webgl",kernelFunc:kJ};var tL=tL;let k0={kernelName:C.SpaceToBatchND,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{blockShape:s,paddings:i}=n;nP.util.assert(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((e,t)=>e*t),l=[[0,0]];l.push(...i);for(let e=1+s.length;e<a.shape.length;++e)l.push([0,0]);let u=[],h=ke({inputs:{x:a},backend:r,attrs:{paddings:l,constantValue:0}}),p=tL.getReshaped(h.shape,s,o,!1),d=tL.getPermuted(p.length,s.length,!1),c=tL.getReshapedPermuted(h.shape,s,o,!1),f=vl({inputs:{x:h},backend:r,attrs:{shape:p}}),m=vb({inputs:{x:f},backend:r,attrs:{perm:d}}),g=vl({inputs:{x:m},backend:r,attrs:{shape:c}});return u.push(h),u.push(f),u.push(m),u.forEach(e=>r.disposeIntermediateTensorInfo(e)),g}},k1={kernelName:C.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{indices:n,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(2!==n.shape.length)throw Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(1!==a.shape.length)throw Error(`Values must be a vector, saw:
         ${a.shape}`);if(0!==i.shape.length)throw Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=r.readSync(n.dataId),l=r.readSync(a.dataId),u=r.readSync(s.dataId),h=r.readSync(i.dataId)[0],[p,d,c,f,m]=xu(o,n.shape,n.dtype,l,a.dtype,u,h);return[r.makeTensorInfo(d,n.dtype,p),r.makeTensorInfo([d[0]],a.dtype,c),r.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),r.makeTensorInfo([m.length],n.dtype,new Int32Array(m))]}},k2={kernelName:C.SparseReshape,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{inputIndices:n,inputShape:a,newShape:s}=t;if(2!==n.shape.length)throw Error(`Input indices should be a matrix but received shape ${n.shape}`);if(1!==a.shape.length)throw Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(r.readSync(a.dataId)),o=r.readSync(n.dataId),l=Array.from(r.readSync(s.dataId)),[u,h,p]=xh(o,n.shape,n.dtype,i,l);return[r.makeTensorInfo(h,n.dtype,u),r.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}},k3={kernelName:C.SparseSegmentMean,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{data:n,indices:a,segmentIds:s}=t;if(n.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw Error(`Indices should be a vector but received shape
              ${a.shape}`);if(1!==s.shape.length)throw Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=r.readSync(n.dataId),o=r.readSync(a.dataId),l=r.readSync(s.dataId),[u,h]=xp(i,n.shape,n.dtype,o,l,!0);return r.makeTensorInfo(h,n.dtype,u)}},k4={kernelName:C.SparseSegmentSum,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{data:n,indices:a,segmentIds:s}=t;if(n.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw Error(`Indices should be a vector but received shape
             ${a.shape}`);if(1!==s.shape.length)throw Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=r.readSync(n.dataId),o=r.readSync(a.dataId),l=r.readSync(s.dataId),[u,h]=xp(i,n.shape,n.dtype,o,l);return r.makeTensorInfo(h,n.dtype,u)}};var tL=tL;let k6={kernelName:C.SparseToDense,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=n,{sliceRank:l,numUpdates:u,sliceSize:h,strides:p,outputSize:d}=tL.calculateShapes(s,a,o);if("string"===s.dtype){let e=xs(r.bufferSync(a),r.bufferSync(s),o,d,h,u,l,p,nP.util.decodeString(r.readSync(i.dataId)[0]),!1);return r.makeTensorInfo(o,e.dtype,e.values)}let c=new k_(u,l,a.shape.length,s.shape.length,p,[d,1],!1),f=r.runWebGLProgram(c,[s,a,i],s.dtype),m=vl({inputs:{x:f},backend:r,attrs:{shape:o}});return r.disposeIntermediateTensorInfo(f),m}};var tL=tL;let k5={kernelName:C.SplitV,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=nP.util.parseAxisParam(i,a.shape)[0],l=tL.prepareSplitSize(a,s,o),u=Array(a.shape.length).fill(0),h=a.shape.slice();return l.map(e=>{let t=[...h];t[o]=e;let n=wr({inputs:{x:a},backend:r,attrs:{begin:u,size:t}});return u[o]+=e,n})}},k8="return sqrt(x);",k9=ve({opSnippet:k8,packedOpSnippet:k8,cpuKernelImpl:xd}),k7={kernelName:C.Sqrt,backendName:"webgl",kernelFunc:k9},Ie=ve({opSnippet:"return x * x;"}),It={kernelName:C.Square,backendName:"webgl",kernelFunc:Ie},Ir="return (a - b) * (a - b);",In=vt({opSnippet:Ir,packedOpSnippet:Ir}),Ia={kernelName:C.SquaredDifference,backendName:"webgl",kernelFunc:In};var tL=tL;let Is={kernelName:C.StaticRegexReplace,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t;if("string"!==a.dtype)throw Error("Input must be of datatype string");let s=r.readSync(a.dataId),i=xc(tL.fromUint8ToStringArray(s),"string",n);return r.makeTensorInfo(a.shape,"string",i)}},Ii={kernelName:C.Step,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:r}){let{x:n}=e,a=xD+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new xR(n.shape,a);return r.runWebGLProgram(s,[n],n.dtype)}};var cp=t9;class Io{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;const n=r.length,a=bt(r.length),s=bt(r.length);let i="";if(1===n)i="coords * strides + begin";else{let e=0;i=r.map((t,n)=>(e++,1===r.length?`coords * strides[${n}] + begin[${n}]`:`coords[${e-1}] * strides[${n}] + begin[${n}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}let Il={kernelName:C.StridedSlice,backendName:"webgl",kernelFunc:function(e){let t,{inputs:r,backend:n,attrs:a}=e,{x:s}=r,{begin:i,end:o,strides:l,beginMask:u,endMask:h,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:c}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:x,end:v,strides:w}=cp.sliceInfo(s.shape,i,o,l,u,h,p,d,c);if(g)t=vl({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||b){nP.util.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let e=cp.computeOutShape(x,v,w),r=wr({inputs:{x:s},backend:n,attrs:{begin:x,size:e}});t=vl({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(r)}else if(n.shouldExecuteOnCPU([s])){let e=n.readSync(s.dataId),r=xf(f,(0,pA.buffer)(s.shape,s.dtype,e),w,x);t=n.makeTensorInfo(m,s.dtype,r.values)}else{let e=new Io(x,w,f);t=n.runWebGLProgram(e,[s],s.dtype)}let S=vl({inputs:{x:t},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(t),S}},Iu={kernelName:C.StringNGrams,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=n,{data:h,dataSplits:p}=t,[d,c]=xm(r.readSync(h.dataId),r.readSync(p.dataId),a,s,i,o,l,u);return[r.makeTensorInfo([d.length],"string",d),r.makeTensorInfo(p.shape,"int32",c)]}},Ih={kernelName:C.StringSplit,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{skipEmpty:a}=n,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw Error("Input must be of datatype string");if(1!==s.shape.length)throw Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let[o,l,u]=xg(r.readSync(s.dataId),r.readSync(i.dataId)[0],a),h=l.length;return[r.makeTensorInfo([h,2],"int32",o),r.makeTensorInfo([h],"string",l),r.makeTensorInfo([2],"int32",new Int32Array(u))]}},Ip={kernelName:C.StringToHashBucketFast,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{numBuckets:a}=n,{input:s}=t;if("string"!==s.dtype)throw Error("Input must be of datatype string");if(a<=0)throw Error("Number of buckets must be at least 1");let i=xy(r.readSync(s.dataId),a);return r.makeTensorInfo(s.shape,"int32",i)}},Id=ve({opSnippet:"return tan(x);"}),Ic={kernelName:C.Tan,backendName:"webgl",kernelFunc:Id},If=ve({opSnippet:`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`}),Im={kernelName:C.Tanh,backendName:"webgl",kernelFunc:If};var tL=tL;let Ig={kernelName:C.TensorScatterUpdate,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{tensor:a,indices:s,updates:i}=t,{}=n,{sliceRank:o,numUpdates:l,sliceSize:u,strides:h,outputSize:p}=tL.calculateShapes(i,s,a.shape),d=[p/u,u];if(0===p)return r.makeTensorInfo(a.shape,s.dtype);let c=vl({inputs:{x:s},backend:r,attrs:{shape:[l,o]}}),f=vl({inputs:{x:i},backend:r,attrs:{shape:[l,u]}}),m=vl({inputs:{x:a},backend:r,attrs:{shape:d}}),g=new k_(l,o,c.shape.length,f.shape.length,h,d,!1,!0),y=r.runWebGLProgram(g,[f,c,m],m.dtype),b=vl({inputs:{x:y},backend:r,attrs:{shape:a.shape}});return r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(y),b}};class Iy{constructor(e,t){this.variableNames=["A"];const r=Array(e.length);for(let n=0;n<r.length;n++)r[n]=e[n]*t[n];this.outputShape=r,this.rank=r.length;const n=bt(this.rank),a=function(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;let r=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let t=0;t<e.length;t++)n.push(`imod(${r[t]}, ${e[t]})`);return n.join()}(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function Ib(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{reps:s}=n;if("string"===a.dtype||a.shape.length>5){let e=r.readSync(a.dataId),t="string"===a.dtype?e.map(e=>nP.util.decodeString(e)):e,n=xx((0,pA.buffer)(a.shape,a.dtype,t),s);return r.makeTensorInfo(n.shape,n.dtype,n.values)}let i=new Iy(a.shape,s);return r.runWebGLProgram(i,[a],a.dtype)}let Ix={kernelName:C.Tile,backendName:"webgl",kernelFunc:Ib};class Iv{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Iw{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function IS(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function IN(e){let t=1;for(;t<e;)t*=2;return t}let Ik={kernelName:C.TopK,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{k:s,sorted:i}=n,o=(0,nL.env)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=(0,nL.env)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,h=u[u.length-1];if(r.shouldExecuteOnCPU([a])||h<o||s>l){let[e,t]=xv(r.readSync(a.dataId),u,a.dtype,s,i);return[r.makeTensorInfo(e.shape,e.dtype,e.values),r.makeTensorInfo(t.shape,t.dtype,t.values)]}if(0===s)return u[u.length-1]=0,[r.makeTensorInfo(u,a.dtype,[]),r.makeTensorInfo(u,"int32",[])];if(1===h)return[a,SR({attrs:{shape:u,dtype:"int32",value:0},backend:r})];let p=r.texData.get(a.dataId),d=null!==p&&p.isPacked,c=d?r.unpackTensor(a):a,f=nP.util.sizeFromShape(u)/h,m=vl({inputs:{x:c},attrs:{shape:[f,h]},backend:r});d&&IS(r,c);let g=IN(s),y=IN(h),b=null,x=()=>null===b?[m,m]:[m,b],v=(e,t,n)=>{let a=x(),s=new Iv(n),i=[[h],[+(null===b)],[-1/0],[e],[t]],o=b;b=r.runWebGLProgram(s,a,"int32",i),IS(r,o)};for(let e=1;e<g;e*=2){let t=2*e;for(let r=e;r>=1;r/=2)v(t,r,[f,y])}for(let e=y;e>g;e/=2){let t=x(),n=new Iw([f,e/2]),a=[[h],[+(null===b)],[g]],s=b;b=r.runWebGLProgram(n,t,"int32",a),IS(r,s);let i=g/2,o=2*i;for(let e=i;e>=1;e/=2)v(o,e,b.shape)}let w=b;b=wr({inputs:{x:b},backend:r,attrs:{begin:0,size:[f,s]}}),IS(r,w);let S=SX({inputs:{x:m,indices:b},backend:r,attrs:{axis:1,batchDims:1}});IS(r,m);let N=u.slice(0,-1);N.push(s),w=b,b=vl({inputs:{x:b},attrs:{shape:N},backend:r}),IS(r,w);let k=S;return S=vl({inputs:{x:S},attrs:{shape:N},backend:r}),IS(r,k),[S,b]}};class II{constructor(e,t,r,n,a,s){let i;switch(this.variableNames=["Image","Transforms"],this.outputShape=s,n){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${i} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${"nearest"===r?1:2} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}let IT={kernelName:C.Transform,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[h,p,d,c]=a.shape,[f,m]=null!=u?u:[p,d],g=new II(p,d,i,o,l,[h,f,m,c]);return r.runWebGLProgram(g,[a,s],"float32")}},IC={kernelName:C.Unique,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:r,backend:n}=e,{axis:a}=r,{x:s}=t;yK(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let{outputValues:i,outputShape:o,indices:l}=xS(n.readSync(s.dataId),a,s.shape,s.dtype);return[n.makeTensorInfo(o,s.dtype,i),n.makeTensorInfo([l.length],"int32",l)]}},IE={kernelName:C.Unpack,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{value:a}=t,{axis:s}=n;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=Array(i-1),u=0;for(let e=0;e<i;e++)e!==s&&(l[u++]=a.shape[e]);let h=[],p=Array(i).fill(0),d=a.shape.slice();d[s]=1;let c=Array(o);for(let e=0;e<c.length;e++){p[s]=e;let t=wr({inputs:{x:a},backend:r,attrs:{begin:p,size:d}}),n=vl({inputs:{x:t},backend:r,attrs:{shape:l}});c[e]=n,h.push(t)}return h.forEach(e=>r.disposeIntermediateTensorInfo(e)),c}};var tL=tL;class I${constructor(e,t){this.variableNames=["x","segmentIds"];const r=e.windowSize,n=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/r);this.outputShape=[n,i];const o=4*Math.floor(r/4),l=r%4,u=`
        sumValue += dot(values, segFilter);
    `;let h="";a%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let p="";a%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${u}
        }

        int inIdx = inOffset + ${o};
        if (${1===l}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${u}
        } else if (${2===l}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${u}
        } else if (${3===l}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${u}
        }
        setOutput(sumValue);
      }
    `}}for(let e of[vw,vN,vI,vC,vA,vF,vO,v_,vP,vB,vW,vG,vH,vK,vZ,vQ,v0,v3,v4,v6,v9,wa,ws,wl,wu,wf,wy,wv,x2,wN,wA,wz,wU,wq,wH,wj,wK,wZ,wJ,w0,w6,w5,w8,w7,Sr,Ss,Si,Sl,Sh,Sp,Sc,Sm,Sy,Sx,Sw,SN,ST,S$,SD,SO,SL,SP,SW,SG,Sq,Sj,SZ,SJ,S0,x0,S1,wE,S3,S6,S8,x6,S7,Nt,Nr,Na,Ni,Nl,Nh,Nd,Nm,Ny,Nx,Nw,NS,NN,NT,NC,NE,N$,NA,ND,N_,NL,NH,vo,NX,NY,NQ,N1,wp,N3,N5,N8,kt,kn,x9,ka,ks,ki,ko,ku,wc,NB,kp,kc,km,vu,kb,kv,kN,kI,kE,kA,kD,kO,kL,kP,kV,kU,kq,kj,kX,kY,wn,Nq,kQ,k0,k1,k2,k3,k4,k6,k5,k7,It,Ia,Is,Ii,Il,Iu,Ih,Ip,NU,vy,Ic,Im,Ig,Ix,Ik,IT,vx,IC,IE,{kernelName:C.UnsortedSegmentSum,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,segmentIds:s}=t,{numSegments:i}=n,o=a.shape.length,l=[],u=0,h=tL.getAxesPermutation([u],o),p=a;null!=h&&(p=vb({inputs:{x:a},backend:r,attrs:{perm:h}}),l.push(p),u=tL.getInnerMostAxes(1,o)[0]);let d=tL.segment_util.computeOutShape(p.shape,u,i),c=nP.util.sizeFromShape([p.shape[u]]),f=vl({inputs:{x:p},backend:r,attrs:{shape:[-1,c]}});l.push(f);let m=(0,dQ.sumOutType)(a.dtype),g=(e,t,n,a,s)=>{let i=e.shape[0],o=e.shape[1],u=tL.segment_util.segOpComputeOptimalWindowSize(o,s),h=new I$({windowSize:u,inSize:o,batchSize:i,numSegments:s},t),p=r.compileAndRun(h,[e,n],a);if(l.push(p),p.shape[1]===s)return p;let d=kl({backend:r,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),c=Ib({inputs:{x:d},backend:r,attrs:{reps:[o/u]}});return l.push(d),l.push(c),g(p,t,c,a,s)},y=vl({inputs:{x:g(f,"unsortedSegmentSum",s,m,i)},backend:r,attrs:{shape:d}}),b=y;return null!=h&&(l.push(y),b=vb({inputs:{x:b},backend:r,attrs:{perm:tL.getUndoAxesPermutation(h)}})),l.forEach(e=>r.disposeIntermediateTensorInfo(e)),b}},N6])(0,rN.registerKernel)(e);var IA=e.i(55785),IA=IA;e.i(81217),e.i(59007),e.i(59951),e.s(["GPGPUContext",()=>bL,"MathBackendWebGL",()=>xq,"forceHalfFloat",()=>xK,"gpgpu_util",0,xH,"setWebGLContext",()=>g8,"webgl_util",0,xj],4916),e.i(4916);var IR=e.i(66841),IR=IR;IA.version,IR.version,e.s(["default",0,({externalVideoElement:e,autoStart:t=!1,showUI:r=!0})=>{let n=(0,b.useRef)(null),a=(0,b.useRef)(null),s=(0,b.useRef)(""),i=(0,b.useRef)(0),o=(0,b.useRef)(0),l=(0,b.useRef)(null),[u,h]=(0,b.useState)(null),[p,d]=(0,b.useState)(!0),[c,f]=(0,b.useState)(!1),[m,g]=(0,b.useState)([]),[x,v]=(0,b.useState)(!1),[w,S]=(0,b.useState)(""),[N,C]=(0,b.useState)(!1);(0,b.useEffect)(()=>(E(),()=>{e||L()}),[]),(0,b.useEffect)(()=>{e&&u&&(e.readyState>=2?v(!0):e.addEventListener("loadeddata",()=>{v(!0)},{once:!0}))},[e,u]),(0,b.useEffect)(()=>{x&&u&&F()},[x,u,e]);let E=async()=>{try{d(!0);let e=await T.load();h(e),d(!1)}catch(e){S("Failed to load model: "+e.message),d(!1)}},$=async e=>{if(!N&&(!window.speechSynthesis||!window.speechSynthesis.speaking))try{C(!0);let t=await fetch("/api/tts",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({text:e})});if(!t.ok)throw Error("Speech failed");let r=await t.blob(),n=URL.createObjectURL(r),a=new Audio(n);l.current=a,a.onended=()=>{C(!1),URL.revokeObjectURL(n),l.current=null},a.onerror=()=>{C(!1),URL.revokeObjectURL(n),l.current=null},await a.play()}catch(e){console.error("TTS Error:",e),C(!1),l.current=null}};(0,b.useEffect)(()=>{if(!window.speechSynthesis)return;let e=setInterval(()=>{window.speechSynthesis.speaking&&l.current&&(l.current.pause(),l.current.currentTime=0,l.current=null,C(!1))},100);return()=>clearInterval(e)},[]);let A=e=>{let t=e.toLowerCase().trim();return"refrigerator"===t||"fridge"===t||"freezer"===t?"wall":e},R=async e=>{if(0===e.length||N||window.speechSynthesis&&window.speechSynthesis.speaking)return;let t={"Very Close":[],Close:[],Medium:[],Far:[],"Very Far":[]};e.forEach(e=>{let r=A(e.class),n=O(e);t[n].includes(r)||t[n].push(r)});let r="";for(let e of["Very Close","Close","Medium","Far","Very Far"])t[e].length>0&&(r+=`${e}: ${t[e].join(", ")}. `);r!==s.current&&(s.current=r,await $(r))},D=async()=>{await $("Audio system is active.")},F=async()=>{if(!u||!x)return;f(!0);let t=async()=>{let r=e||n.current;if(x&&r)try{let e=(await u.detect(r)).filter(e=>e.score>.6).map(e=>({...e,class:A(e.class)}));g(e),e.length>0&&.01>Math.random()&&console.log("Detected objects:",e.map(e=>e.class)),(e=>{let t=Date.now();if(t-o.current<3e3||window.speechSynthesis&&window.speechSynthesis.speaking)return;let r=e.filter(e=>"Very Close"===O(e));if(r.length>0){o.current=t;let e=r.map(e=>e.class).join(", ");$(`Warning! Objects very close: ${e}`)}})(e);let n=Date.now();if(!(n-i.current>=5e3)||N||!(e.length>0)||window.speechSynthesis&&window.speechSynthesis.speaking||(i.current=n,R(e)),a.current&&r){let t=a.current,n=t.getContext("2d");t.width=r.videoWidth||1280,t.height=r.videoHeight||720,n&&(n.drawImage(r,0,0,t.width,t.height),_(e,t))}requestAnimationFrame(t)}catch(e){console.error("Detection loop error:",e)}};t()},O=e=>{let[t,r,n,s]=e.bbox,i=n*s/((a.current?.width||1280)*(a.current?.height||720))*100,o=["person","car","bicycle","tv","couch"].includes(e.class),l=["bottle","cup","cell phone","mouse","remote"].includes(e.class),u={vClose:25,close:10,med:3};return(l&&(u={vClose:8,close:3,med:1}),o&&(u={vClose:40,close:20,med:8}),i>u.vClose)?"Very Close":i>u.close?"Close":i>u.med?"Medium":i>.5?"Far":"Very Far"},_=(e,t)=>{let r=t.getContext("2d");r&&e.forEach(e=>{let[t,n,a,s]=e.bbox,i=O(e),o={"Very Close":"#FF0000",Close:"#FF9900",Medium:"#FFFF00",Far:"#00FF00","Very Far":"#00FFFF"};r.strokeStyle=o[i]||"#00FF00",r.lineWidth=3,r.strokeRect(t,n,a,s),r.fillStyle=o[i]||"#00FF00",r.font="bold 16px Arial";let l=`${e.class} (${Math.round(100*e.score)}%)`,u=`Dist: ${i}`,h=Math.max(r.measureText(l).width,r.measureText(u).width)+10;r.fillRect(t,n-45,h,45),r.fillStyle="#000000",r.fillText(l,t+5,n-28),r.fillText(u,t+5,n-10)})},M=async()=>{try{let e=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}});n.current&&(n.current.srcObject=e,n.current.onloadedmetadata=()=>{n.current?.play(),v(!0)})}catch(e){S("Camera access denied")}},L=()=>{n.current?.srcObject&&(n.current.srcObject.getTracks().forEach(e=>e.stop()),n.current.srcObject=null),v(!1),f(!1)};return r?(0,y.jsx)("div",{className:"min-h-screen bg-gray-900 p-6 text-white font-sans",children:(0,y.jsxs)("div",{className:"max-w-4xl mx-auto text-center",children:[(0,y.jsx)("h1",{className:"text-3xl font-bold mb-4",children:"PathPilot Vision Assistant"}),w&&(0,y.jsx)("div",{className:"bg-red-900 border border-red-500 p-3 mb-4 rounded",children:w}),(0,y.jsxs)("div",{className:"flex justify-center gap-4 mb-8",children:[!e&&(0,y.jsx)(y.Fragment,{children:x?(0,y.jsxs)("button",{onClick:L,className:"bg-red-600 px-6 py-2 rounded flex items-center gap-2 hover:bg-red-500",children:[(0,y.jsx)(I,{size:20})," Stop Camera"]}):(0,y.jsxs)("button",{onClick:M,className:"bg-green-600 px-6 py-2 rounded flex items-center gap-2 hover:bg-green-500",children:[(0,y.jsx)(k,{size:20})," Start Camera"]})}),(0,y.jsx)("button",{onClick:D,disabled:N,className:"bg-purple-600 px-6 py-2 rounded disabled:opacity-50",children:N?" Speaking...":" Test Audio"})]}),(0,y.jsxs)("div",{className:"relative bg-black rounded-xl overflow-hidden aspect-video border-4 border-gray-700",children:[p&&(0,y.jsx)("div",{className:"absolute inset-0 flex items-center justify-center bg-black/50",children:"Loading Model..."}),(0,y.jsx)("video",{ref:n,className:"absolute inset-0 w-full h-full object-cover hidden",playsInline:!0}),(0,y.jsx)("canvas",{ref:a,className:"absolute inset-0 w-full h-full object-cover"})]}),m.length>0&&(0,y.jsxs)("div",{className:"mt-6",children:[(0,y.jsx)("h3",{className:"text-lg font-bold mb-3",children:"Detected Objects"}),(0,y.jsx)("div",{className:"grid grid-cols-2 md:grid-cols-4 gap-4",children:m.map((e,t)=>{let r=O(e),n="Very Close"===r?"border-red-500":"Close"===r?"border-orange-500":"Medium"===r?"border-yellow-500":"border-green-500";return(0,y.jsxs)("div",{className:`bg-gray-800 p-3 rounded-lg border-l-4 ${n}`,children:[(0,y.jsx)("p",{className:"font-bold capitalize",children:e.class}),(0,y.jsx)("p",{className:"text-sm text-gray-400",children:r}),"Very Close"===r&&(0,y.jsx)("p",{className:"text-xs text-red-400 mt-1",children:" Warning!"})]},t)})})]})]})}):(0,y.jsx)("div",{className:"absolute inset-0 pointer-events-none",style:{zIndex:1e3},children:(0,y.jsx)("canvas",{ref:a,className:"absolute inset-0 w-full h-full object-cover"})})}],50461)}]);